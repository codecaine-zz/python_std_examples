<html>
    <head>
        <title>Python 3.12 Standard Library</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="A collection of standard library documents converted from markdown to HTML.">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
        <link rel="icon" href="favicon.png" type="image/png">
        <style>
            body {
                font-family: Arial, sans-serif;
                line-height: 1.6;
                margin: 0;
                padding: 20px;
                background-color: #2e2e2e;
                color: #f4f4f4;
            }
            h1, h2, h3 {
                color: #f4f4f4;
                margin-top: 20px;
            }
            ul {
                list-style-type: none;
                padding: 0;
            }
            li {
                margin: 5px 0;
            }
            a {
                text-decoration: none;
                color: #1e90ff;
                border-bottom: 1px dashed #1e90ff;
                transition: color 0.3s, border-bottom-color 0.3s;
            }
            a:hover {
                color: #63a4ff;
                border-bottom-color: #63a4ff;
            }
            pre {
                background: #3e3e3e;
                padding: 10px;
                border: 1px solid #555;
                border-radius: 5px;
                overflow-x: auto;
                margin-top: 10px;
            }
            code {
                font-family: Consolas, "Courier New", monospace;
                color: #f4f4f4;
            }
            button {
                display: inline-block;
                margin-top: 10px;
                padding: 10px 15px;
                font-size: 14px;
                background-color: #1e90ff;
                color: #fff;
                border: none;
                border-radius: 5px;
                cursor: pointer;
            }
            button:hover {
                background-color: #1c86ee;
            }
            #scrollToTopBtn {
                position: fixed;
                bottom: 20px;
                right: 30px;
                display: none;
                padding: 10px 15px;
                font-size: 16px;
                background-color: #000;
                color: #fff;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                z-index: 1000;
            }
            #scrollToTopBtn:hover {
                background-color: #555;
            }
            @media (max-width: 600px) {
                body {
                    padding: 10px;
                }
                h1 {
                    font-size: 24px;
                }
                h2 {
                    font-size: 20px;
                }
                h3 {
                    font-size: 18px;
                }
                button {
                    font-size: 12px;
                    padding: 8px 12px;
                }
                #scrollToTopBtn {
                    font-size: 14px;
                    padding: 8px 12px;
                }
            }
        </style>
    </head>
    <body>
        <h1>Python 3.12 Standard Library</h1>
        <hr>
        <ul>
            <li><a href='#Internet Protocols and Support'>Internet Protocols and Support</a></li><li><a href='#Data Compression and Archiving'>Data Compression and Archiving</a></li><li><a href='#Generic Operating System Services'>Generic Operating System Services</a></li><li><a href='#File and Directory Access'>File and Directory Access</a></li><li><a href='#Internet Data Handling'>Internet Data Handling</a></li><li><a href='#Importing Modules'>Importing Modules</a></li><li><a href='#Internationalization'>Internationalization</a></li><li><a href='#Text Processing Services'>Text Processing Services</a></li><li><a href='#Concurrent Execution'>Concurrent Execution</a></li><li><a href='#Structured Markup Processing Tools'>Structured Markup Processing Tools</a></li><li><a href='#Miscellaneous Services'>Miscellaneous Services</a></li><li><a href='#Software Packaging and Distribution'>Software Packaging and Distribution</a></li><li><a href='#XML Processing Modules'>XML Processing Modules</a></li><li><a href='#Custom Python Interpreters'>Custom Python Interpreters</a></li><li><a href='#Multimedia Services'>Multimedia Services</a></li><li><a href='#Cryptographic Services'>Cryptographic Services</a></li><li><a href='#Python Runtime Services'>Python Runtime Services</a></li><li><a href='#Networking and Interprocess Communication'>Networking and Interprocess Communication</a></li><li><a href='#Program Frameworks'>Program Frameworks</a></li><li><a href='#Numeric and Mathematical Modules'>Numeric and Mathematical Modules</a></li><li><a href='#Development Tools'>Development Tools</a></li><li><a href='#Microsoft Windows Specific Services'>Microsoft Windows Specific Services</a></li><li><a href='#Unix Specific Services'>Unix Specific Services</a></li><li><a href='#Binary Data Services'>Binary Data Services</a></li><li><a href='#Python Language Services'>Python Language Services</a></li><li><a href='#Data Persistence'>Data Persistence</a></li><li><a href='#Functional Programming Modules'>Functional Programming Modules</a></li><li><a href='#Debugging and Profiling'>Debugging and Profiling</a></li><li><a href='#Superseded Modules'>Superseded Modules</a></li><li><a href='#Graphical User Interfaces with Tk'>Graphical User Interfaces with Tk</a></li><li><a href='#File Formats'>File Formats</a></li>
        </ul>
        <hr>
        <h2 id='Internet Protocols and Support'>Internet Protocols and Support</h2><ul><li><a href='#standard_library_documents/Internet Protocols and Support/ipaddress - IPv4 IPv6 manipulation library.md'>ipaddress - IPv4 IPv6 manipulation library.md</a></li><li><a href='#standard_library_documents/Internet Protocols and Support/http.server - HTTP servers.md'>http.server - HTTP servers.md</a></li><li><a href='#standard_library_documents/Internet Protocols and Support/poplib - POP3 protocol client.md'>poplib - POP3 protocol client.md</a></li><li><a href='#standard_library_documents/Internet Protocols and Support/imaplib - IMAP4 protocol client.md'>imaplib - IMAP4 protocol client.md</a></li><li><a href='#standard_library_documents/Internet Protocols and Support/urllib.error - Exception classes raised by urllib.request.md'>urllib.error - Exception classes raised by urllib.request.md</a></li><li><a href='#standard_library_documents/Internet Protocols and Support/http.client - HTTP protocol client.md'>http.client - HTTP protocol client.md</a></li><li><a href='#standard_library_documents/Internet Protocols and Support/nntplib - NNTP protocol client.md'>nntplib - NNTP protocol client.md</a></li><li><a href='#standard_library_documents/Internet Protocols and Support/http.cookies - HTTP state management.md'>http.cookies - HTTP state management.md</a></li><li><a href='#standard_library_documents/Internet Protocols and Support/xmlrpc.client - XMLRPC client access.md'>xmlrpc.client - XMLRPC client access.md</a></li><li><a href='#standard_library_documents/Internet Protocols and Support/smtplib - SMTP protocol client.md'>smtplib - SMTP protocol client.md</a></li><li><a href='#standard_library_documents/Internet Protocols and Support/xmlrpc.server - Basic XMLRPC servers.md'>xmlrpc.server - Basic XMLRPC servers.md</a></li><li><a href='#standard_library_documents/Internet Protocols and Support/wsgiref - WSGI Utilities and Reference Implementation.md'>wsgiref - WSGI Utilities and Reference Implementation.md</a></li><li><a href='#standard_library_documents/Internet Protocols and Support/xmlrpc - XMLRPC server and client modules.md'>xmlrpc - XMLRPC server and client modules.md</a></li><li><a href='#standard_library_documents/Internet Protocols and Support/urllib - URL handling modules.md'>urllib - URL handling modules.md</a></li><li><a href='#standard_library_documents/Internet Protocols and Support/urllib.request - Extensible library for opening URLs.md'>urllib.request - Extensible library for opening URLs.md</a></li><li><a href='#standard_library_documents/Internet Protocols and Support/webbrowser - Convenient web-browser controller.md'>webbrowser - Convenient web-browser controller.md</a></li><li><a href='#standard_library_documents/Internet Protocols and Support/ftplib - FTP protocol client.md'>ftplib - FTP protocol client.md</a></li><li><a href='#standard_library_documents/Internet Protocols and Support/http - HTTP modules.md'>http - HTTP modules.md</a></li><li><a href='#standard_library_documents/Internet Protocols and Support/urllib.response - Response classes used by urllib.md'>urllib.response - Response classes used by urllib.md</a></li><li><a href='#standard_library_documents/Internet Protocols and Support/urllib.robotparser - Parser for robots.txt.md'>urllib.robotparser - Parser for robots.txt.md</a></li><li><a href='#standard_library_documents/Internet Protocols and Support/http.cookiejar - Cookie handling for HTTP clients.md'>http.cookiejar - Cookie handling for HTTP clients.md</a></li><li><a href='#standard_library_documents/Internet Protocols and Support/urllib.parse - Parse URLs into components.md'>urllib.parse - Parse URLs into components.md</a></li></ul>
<h3 id='standard_library_documents/Internet Protocols and Support/ipaddress - IPv4 IPv6 manipulation library.md'>ipaddress - IPv4 IPv6 manipulation library.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># ipaddress - IPv4/IPv6 manipulation library

Here&#x27;s an example of using the `ipaddress` module from Python&#x27;s standard library:

```python
# Import the ipaddress module
import ipaddress

# Create an IPv4 address object
ipv4_addr = ipaddress.IPv4Address(&quot;192.168.1.100&quot;)

# Get the IP address as a string
print(f&quot;IPv4 Address: {ipv4_addr}&quot;)

# Check if the address is valid
print(f&quot;Is Valid: {ipv4_addr.is_valid()}&quot;)

# Create an IPv6 address object
ipv6_addr = ipaddress.IPv6Address(&quot;2001:0db8:85a3:0000:0000:8a2e:0370:7334&quot;)

# Get the IP address as a string
print(f&quot;IPv6 Address: {ipv6_addr}&quot;)

# Check if the address is valid
print(f&quot;Is Valid: {ipv6_addr.is_valid()}&quot;)

# Create an IPv4 network object
ipv4_network = ipaddress.IPv4Network(&quot;192.168.1.0/24&quot;, strict=False)

# Get the network as a string
print(f&quot;IPv4 Network: {ipv4_network}&quot;)

# Check if the address is in the network
print(f&quot;Is Address in Network: {ipv4_addr in ipv4_network}&quot;)

# Create an IPv6 network object
ipv6_network = ipaddress.IPv6Network(&quot;2001:0db8:85a3:0000:0000:8a2e:0370:7334/64&quot;, strict=False)

# Get the network as a string
print(f&quot;IPv6 Network: {ipv6_network}&quot;)

# Check if the address is in the network
print(f&quot;Is Address in Network: {ipv6_addr in ipv6_network}&quot;)

# Create an IPv4 prefix object
ipv4_prefix = ipaddress.IPv4PrefixNetwork(&quot;192.168.1.0/24&quot;, strict=False)

# Get the prefix as a string
print(f&quot;IPv4 Prefix: {ipv4_prefix}&quot;)

# Create an IPv6 prefix object
ipv6_prefix = ipaddress.IPv6PrefixNetwork(&quot;2001:0db8:85a3:0000:0000:8a2e:0370:7334/64&quot;, strict=False)

# Get the prefix as a string
print(f&quot;IPv6 Prefix: {ipv6_prefix}&quot;)

# Create an IPv4 network with specific parameters
ipv4_network_params = ipaddress.IPv4Network(&quot;192.168.1.100/32&quot;)

# Get the network as a string
print(f&quot;IPv4 Network Parameters: {ipv4_network_params}&quot;)

# Create an IPv6 network with specific parameters
ipv6_network_params = ipaddress.IPv6Network(&quot;2001:0db8:85a3:0000:0000:8a2e:0370:7334/64&quot;)

# Get the network as a string
print(f&quot;IPv6 Network Parameters: {ipv6_network_params}&quot;)

# Create an IPv4 address from a string (valid)
ipv4_addr_str = ipaddress.IPv4Address(&quot;192.168.1.100&quot;)

# Check if the address is valid
print(f&quot;Is Valid Address: {ipv4_addr_str.is_valid()}&quot;)

# Create an IPv6 address from a string (valid)
ipv6_addr_str = ipaddress.IPv6Address(&quot;2001:0db8:85a3:0000:0000:8a2e:0370:7334&quot;)

# Check if the address is valid
print(f&quot;Is Valid Address: {ipv6_addr_str.is_valid()}&quot;)
```

This script creates various objects from the `ipaddress` module, including addresses and networks, and demonstrates how to manipulate them. The output includes information about each object&#x27;s validity, string representation, and other properties.

Here are some key concepts demonstrated in this code:

*   Creating IP address objects: You can create IP address objects using the `IP` class from the `ipaddress` module.
*   Validating IP addresses: You can use the `is_valid()` method to check if an IP address is valid or not.
*   Working with networks: You can create network objects using the `IPv4Network` and `IPv6Network` classes, which provide methods for working with networks such as checking if an address is within a given network range.
*   Creating prefixes: You can create prefix objects using the `IPv4PrefixNetwork` and `IPv6PrefixNetwork` classes, which provide methods for working with prefixes.
*   Converting between strings and IP address objects: You can use the `IP` class to create IP address objects from string representations.
</code></pre>

<h3 id='standard_library_documents/Internet Protocols and Support/http.server - HTTP servers.md'>http.server - HTTP servers.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># http.server — HTTP servers

**http.server Module Code Generation**
=====================================

The `http.server` module in Python&#x27;s standard library provides a simple way to create an HTTP server.

### HTTPServer Class
-------------------

```python
import http.server

class CustomHttpServer(http.server.HTTPServer):
    &quot;&quot;&quot;
    A custom HTTP server class that inherits from the base HTTPServer class.
    &quot;&quot;&quot;

    def __init__(self, *args, **kwargs):
        # Initialize the parent class with the provided arguments
        super().__init__(*args, **kwargs)

    def serve_forever(self):
        # Instead of calling the parent&#x27;s method, handle errors and exceptions here
        try:
            self.serve_forever()
        except Exception as e:
            print(f&quot;Error occurred: {e}&quot;)

# Usage
if __name__ == &quot;__main__&quot;:
    # Create a custom HTTP server with port 8080
    server = CustomHttpServer((&quot;localhost&quot;, 8080), http.server.SimpleHTTPRequestHandler)

    # Start the server in the foreground
    server.serve_forever()
```

### SimpleHTTPRequestHandler Class
---------------------------------

```python
import http.server

class CustomSimpleHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):
    &quot;&quot;&quot;
    A custom SimpleHTTPRequestHandler class that inherits from the base class.
    &quot;&quot;&quot;

    def do_GET(self):
        # Override the do_GET method to handle GET requests differently
        self.send_response(200)
        self.end_headers()
        self.wfile.write(b&quot;Hello, World!&quot;)

    def do_POST(self):
        # Override the do_POST method to handle POST requests differently
        content_length = int(self.headers[&#x27;Content-Length&#x27;])
        body = self.rfile.read(content_length)

# Usage
if __name__ == &quot;__main__&quot;:
    # Create a custom HTTP server with port 8080 and our custom handler
    server = http.server.HTTPServer((&quot;localhost&quot;, 8080), CustomSimpleHTTPRequestHandler)

    # Start the server in the foreground
    server.serve_forever()
```

### BasicHTTPServer Class
------------------------

```python
import http.server

class CustomBasicHTTPServer(http.server.BasicHTTPServer):
    &quot;&quot;&quot;
    A custom BasicHTTPServer class that inherits from the base class.
    &quot;&quot;&quot;

    def do_GET(self, path):
        # Override the do_GET method to handle GET requests differently
        self.send_response(200)
        self.end_headers()
        return b&quot;Hello, World!&quot;

# Usage
if __name__ == &quot;__main__&quot;:
    # Create a custom HTTP server with port 8080 and our custom handler
    server = CustomBasicHTTPServer((&quot;localhost&quot;, 8080), http.server.SimpleHTTPRequestHandler)

    # Start the server in the foreground
    server.serve_forever()
```

### SimpleProxyServer Class
---------------------------

```python
import http.server

class CustomSimpleProxyServer(http.server.SimpleProxyServer):
    &quot;&quot;&quot;
    A custom SimpleProxyServer class that inherits from the base class.
    &quot;&quot;&quot;

    def proxy_connect(self, conn):
        # Override the proxy_connect method to handle connection establishment differently
        print(&quot;Establishing connection...&quot;)
        return super().proxy_connect(conn)

# Usage
if __name__ == &quot;__main__&quot;:
    # Create a custom HTTP server with port 8080 and our custom handler
    server = http.server.HTTPServer((&quot;localhost&quot;, 8080), CustomSimpleProxyServer((&quot;localhost&quot;, 80)))

    # Start the server in the foreground
    server.serve_forever()
```

### BaseHTTPServer Class
----------------------

```python
import http.server

class CustomBasicHTTPServer(http.server.BaseHTTPRequestHandler):
    &quot;&quot;&quot;
    A custom BasicHTTPServer class that inherits from the base class.
    &quot;&quot;&quot;

    def do_GET(self):
        # Override the do_GET method to handle GET requests differently
        self.send_response(200)
        self.end_headers()
        return b&quot;Hello, World!&quot;

# Usage
if __name__ == &quot;__main__&quot;:
    # Create a custom HTTP server with port 8080 and our custom handler
    server = http.server.HTTPServer((&quot;localhost&quot;, 8080), CustomBasicHTTPServer)

    # Start the server in the foreground
    server.serve_forever()
```

### HTTPMessage Class
--------------------

```python
import http.client

class CustomHTTPRequestMessage(http.client.HTTPMessage):
    &quot;&quot;&quot;
    A custom HTTPMessage class that inherits from the base class.
    &quot;&quot;&quot;

    def __init__(self, *args, **kwargs):
        # Initialize the parent class with the provided arguments
        super().__init__(*args, **kwargs)

# Usage
if __name__ == &quot;__main__&quot;:
    # Create a custom HTTP message object
    message = CustomHTTPRequestMessage()

    # Access attributes and methods of the original message
    print(message.status)
    print(message.version)
```

### HTTPSConnection Class
-------------------------

```python
import http.client

class CustomHTTPSConnection(http.client.HTTPSConnection):
    &quot;&quot;&quot;
    A custom HTTPSConnection class that inherits from the base class.
    &quot;&quot;&quot;

    def __init__(self, *args, **kwargs):
        # Initialize the parent class with the provided arguments
        super().__init__(*args, **kwargs)

# Usage
if __name__ == &quot;__main__&quot;:
    # Create a custom HTTPS connection object
    connection = CustomHTTPSConnection()

    # Access attributes and methods of the original connection
    print(connection.host)
    print(connection.port)
```

### HTTPServerFactory Class
---------------------------

```python
import http.server

class CustomHTTPServerFactory(http.server.HTTPServerFactory):
    &quot;&quot;&quot;
    A custom HTTPServerFactory class that inherits from the base class.
    &quot;&quot;&quot;

    def create_server(self, server_address, server_class):
        # Override the create_server method to handle server creation differently
        print(&quot;Creating server...&quot;)
        return super().create_server(server_address, server_class)

# Usage
if __name__ == &quot;__main__&quot;:
    # Create a custom HTTP server factory object
    factory = CustomHTTPServerFactory()

    # Create an HTTP server using our custom factory
    server = factory.create_server((&quot;localhost&quot;, 8080), http.server.HTTPServer)

    # Start the server in the foreground
    server.serve_forever()
```
</code></pre>

<h3 id='standard_library_documents/Internet Protocols and Support/poplib - POP3 protocol client.md'>poplib - POP3 protocol client.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># poplib — POP3 protocol client

**poplib Module**
================

The `poplib` module provides an interface to access and manipulate POP3 mailboxes.

**Installation**
---------------

To use the `poplib` module, you need to install a Python IMAP/POP3 library such as `imaplib` and `smtplib`. These libraries are included in the standard library of Python 3.x.

**Example Usage**
-----------------

Here&#x27;s an example of how to use the `poplib` module:

```python
import poplib

def main():
    # Define POP3 server details
    host = &#x27;example.com&#x27;
    port = 995
    username = &#x27;username&#x27;
    password = &#x27;password&#x27;

    # Create a POP3 connection object
    try:
        conn = poplib.POP3S(host, port)
    except Exception as e:
        print(f&quot;Failed to connect: {e}&quot;)
        return

    # Authentication
    conn.login(username, password)

    # Get the number of messages in the mailbox
    num_messages = conn.get_num_messages()
    print(f&quot;Number of messages: {num_messages}&quot;)

    # Retrieve a message by ID
    msg_id = 1
    try:
        raw_message = conn.retr(msg_id)
    except Exception as e:
        print(f&quot;Failed to retrieve message {msg_id}: {e}&quot;)
        return

    # Print the message
    print(&quot;Message:&quot;)
    for line in raw_message.decode(&#x27;utf-8&#x27;):
        print(line)

    # Quit the connection
    conn.quit()

if __name__ == &quot;__main__&quot;:
    main()
```

**Available Methods**
--------------------

Here&#x27;s a list of available methods and their descriptions:

### Connection Object

* `login(username, password)`: Logs in to the POP3 server.
* `quit()`: Quits the connection.
* `get_num_messages()`: Returns the number of messages in the mailbox.
* `retr(msg_id)`: Retrieves a message by ID.

### Mailbox Methods

* `select()`: Selects an email folder or mailbox.
* `append(message_data, filename)`: Appends a file to the selected mailbox.
* `list()`: Lists all the files in the selected mailbox.

**Common Exceptions**
---------------------

Here are some common exceptions you may encounter when using the `poplib` module:

* `ConnectionRefusedError`: Raised if the POP3 server cannot be connected to.
* `AuthenticationError`: Raised if authentication fails.
* `MessageNotFoundError`: Raised if a message is not found by ID.

Note: The above examples and documentation are for Python 3.x.
</code></pre>

<h3 id='standard_library_documents/Internet Protocols and Support/imaplib - IMAP4 protocol client.md'>imaplib - IMAP4 protocol client.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># imaplib — IMAP4 protocol client

**IMAPlib: A Python Client for IMAP4 Protocol**
====================================================

The `imaplib` module is a Python interface to the Internet Message Access Protocol (IMAP) version 4, which is a standard for accessing and managing email messages on a remote server.

### Installation

You don&#x27;t need to install anything as it&#x27;s part of the Python Standard Library.

### Example Usage
```python
import imaplib

# Connect to the IMAP server
def connect_to_imap(server, username, password):
    &quot;&quot;&quot;
    Establishes a connection to an IMAP server.

    Args:
        server (str): The hostname or IP address of the IMAP server.
        username (str): The username to use for authentication.
        password (str): The password to use for authentication.

    Returns:
        imaplib.IMAP4: An IMAP4 client object.
    &quot;&quot;&quot;
    # Create an IMAP4 client object
    mail = imaplib.IMAP4(server)

    # Login to the IMAP server
    mail.login(username, password)

    return mail

# Search for emails with a specific subject or keyword
def search_for_emails(mail, subject=None, keyword=None):
    &quot;&quot;&quot;
    Searches for emails on the IMAP server.

    Args:
        mail (imaplib.IMAP4): An IMAP4 client object.
        subject (str, optional): The subject of the email to search for. Defaults to None.
        keyword (str, optional): A keyword to search for in the email body or subject. Defaults to None.

    Returns:
        list: A list of message IDs matching the search criteria.
    &quot;&quot;&quot;
    # Search for emails with a specific subject
    if subject:
        result = mail.search(None, &#x27;SUBJECT&#x27;, subject)
    else:
        result = mail.search(None, &#x27;*&#x27;)

    # Check if any messages were found
    if result[0] != b&#x27;&#x27;:
        return result[1].decode(&#x27;utf-8&#x27;).split()
    else:
        return []

# Fetch an email message by ID
def fetch_email(mail, msgid):
    &quot;&quot;&quot;
    Fetches an email message from the IMAP server.

    Args:
        mail (imaplib.IMAP4): An IMAP4 client object.
        msgid (int or str): The message ID of the email to fetch.

    Returns:
        tuple: A tuple containing the email body and subject.
    &quot;&quot;&quot;
    result = mail.fetch(str(msgid), &#x27;(BODY[TEXT])&#x27;)
    return result[0].split(&#x27;\n&#x27;)

# Close the IMAP connection
def close_connection(mail):
    &quot;&quot;&quot;
    Closes the IMAP connection.

    Args:
        mail (imaplib.IMAP4): An IMAP4 client object.
    &quot;&quot;&quot;
    # Logout from the IMAP server
    mail.logout()

    # Close the connection to the IMAP server
    mail.close()
    mail.logout()

# Usage example
if __name__ == &#x27;__main__&#x27;:
    # Connect to the IMAP server
    mail = connect_to_imap(&#x27;imap.gmail.com&#x27;, &#x27;your_email@gmail.com&#x27;, &#x27;your_password&#x27;)

    # Search for emails with a specific subject
    subject = &#x27;Example Email&#x27;
    email_ids = search_for_emails(mail, subject)
    print(f&quot;Found {len(email_ids)} email(s) with subject &#x27;{subject}&#x27;:&quot;)
    for emailid in email_ids:
        print(f&quot;- Message ID: {emailid}&quot;)

    # Fetch an email message by ID
    msgid = 1
    email_body, email_subject = fetch_email(mail, msgid)
    print(f&quot;Email Subject: {email_subject}&quot;)
    print(f&quot;Email Body:\n{email_body}&quot;)

    # Close the IMAP connection
    close_connection(mail)
```
This example demonstrates how to connect to an IMAP server, search for emails with a specific subject or keyword, fetch an email message by ID, and close the IMAP connection.

**Note**: This code snippet is just an illustration of the `imaplib` module&#x27;s capabilities. You should replace `&#x27;your_email@gmail.com&#x27;`, `&#x27;your_password&#x27;`, and `&#x27;imap.gmail.com&#x27;` with your actual email credentials and IMAP server address.
</code></pre>

<h3 id='standard_library_documents/Internet Protocols and Support/urllib.error - Exception classes raised by urllib.request.md'>urllib.error - Exception classes raised by urllib.request.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># urllib.error — Exception classes raised by urllib.request

Here&#x27;s an example of all exception classes raised by `urllib.request`:
```python
# Importing the required modules
import urllib.request

# Urllib error exceptions
class URLError(urllib.error.URLError):
    &quot;&quot;&quot;
    Base class for all urllib-related errors.

    Attributes:
        - msg (str): The error message.
        - reason (str): A human-readable representation of the error.
        - code (int): The HTTP status code.
    &quot;&quot;&quot;

    def __init__(self, msg, reason, code=None):
        self.msg = msg
        self.reason = reason
        self.code = code

class HTTPError(URLError):
    &quot;&quot;&quot;
    Exception raised when an HTTP error occurs.

    Attributes:
        - msg (str): The error message.
        - reason (str): A human-readable representation of the error.
        - code (int): The HTTP status code.
    &quot;&quot;&quot;

    def __init__(self, msg, reason, code):
        super().__init__(msg, reason)
        self.code = code

class RequestProxyError(URLError):
    &quot;&quot;&quot;
    Exception raised when a request proxy error occurs.

    Attributes:
        - msg (str): The error message.
        - reason (str): A human-readable representation of the error.
        - code (int): The HTTP status code.
    &quot;&quot;&quot;

    def __init__(self, msg, reason, code):
        super().__init__(msg, reason)
        self.code = code

class RequestRetryError(URLError):
    &quot;&quot;&quot;
    Exception raised when a request retry fails.

    Attributes:
        - msg (str): The error message.
        - reason (str): A human-readable representation of the error.
        - code (int): The HTTP status code.
    &quot;&quot;&quot;

    def __init__(self, msg, reason, code):
        super().__init__(msg, reason)
        self.code = code

class ProtocolError(URLError):
    &quot;&quot;&quot;
    Exception raised when a protocol-related error occurs.

    Attributes:
        - msg (str): The error message.
        - reason (str): A human-readable representation of the error.
        - code (int): The HTTP status code.
    &quot;&quot;&quot;

    def __init__(self, msg, reason, code):
        super().__init__(msg, reason)
        self.code = code

class ContentError(URLError):
    &quot;&quot;&quot;
    Exception raised when content-related errors occur.

    Attributes:
        - msg (str): The error message.
        - reason (str): A human-readable representation of the error.
        - code (int): The HTTP status code.
    &quot;&quot;&quot;

    def __init__(self, msg, reason, code):
        super().__init__(msg, reason)
        self.code = code

# Example usage:
try:
    # Attempting to make a request with an invalid URL
    urllib.request.urlopen(&quot;invalid_url&quot;)
except URLError as e:
    print(f&quot;Error: {e.msg} (Reason: {e.reason})&quot;)  # Output: Error: unable_to_parse (Reason: &#x27;Failed parameter&#x27;)

try:
    # Making a GET request to a resource that doesn&#x27;t exist
    response = urllib.request.urlopen(&quot;https://non-existent-resource&quot;)
except HTTPError as e:
    print(f&quot;HTTP Error: {e.msg} (Code: {e.code})&quot;)  # Output: HTTP Error: not found (Code: 404)

try:
    # Making a GET request with an invalid proxy
    response = urllib.request.urlopen(&quot;https://example.com&quot;, proxies={&quot;http&quot;: &quot;invalid_proxy&quot;})
except RequestProxyError as e:
    print(f&quot;Proxy Error: {e.msg} (Reason: {e.reason})&quot;)  # Output: Proxy Error: unable_to_connect

try:
    # Making a GET request with an invalid HTTP method
    response = urllib.request.urlopen(&quot;https://example.com&quot;, data={&quot;key&quot;: &quot;value&quot;}, method=&quot;invalid_method&quot;)
except RequestRetryError as e:
    print(f&quot;Request Retry Error: {e.msg} (Reason: {e.reason})&quot;)  # Output: Request Retry Error: unable_to_connect

try:
    # Making a GET request with an invalid connection
    response = urllib.request.urlopen(&quot;https://example.com&quot;, timeout=0)
except ProtocolError as e:
    print(f&quot;Protocol Error: {e.msg} (Reason: {e.reason})&quot;)  # Output: Protocol Error: unable_to_connect

try:
    # Making a GET request with an invalid encoding
    response = urllib.request.urlopen(&quot;https://example.com&quot;, encoding=&quot;invalid_encoding&quot;)
except ContentError as e:
    print(f&quot;Content Error: {e.msg} (Reason: {e.reason})&quot;)  # Output: Content Error: unable_to_decode
```
This example demonstrates how to use each of the exception classes raised by `urllib.request`. Note that these exceptions are designed to be caught and handled using a try-except block.
</code></pre>

<h3 id='standard_library_documents/Internet Protocols and Support/http.client - HTTP protocol client.md'>http.client - HTTP protocol client.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># http.client — HTTP protocol client

Here&#x27;s an example of how you can use the `http.client` module in Python:
```python
import http.client

# Create an HTTP connection
conn = http.client.HTTPSConnection(&quot;example.com&quot;)

try:
    # Send a GET request to the specified URL
    conn.request(&quot;GET&quot;, &quot;/path/to/resource&quot;, None, {&quot;User-Agent&quot;: &quot;My Client/1.0&quot;})

    # Get the response status code and reason phrase
    response_status = conn.getresponse().status
    response_reason = conn.getresponse().reason

    print(f&quot;Status Code: {response_status}&quot;)
    print(f&quot;Reason Phrase: {response_reason}&quot;)

except http.client.HTTPException as e:
    print(f&quot;Error: {e}&quot;)

finally:
    # Close the HTTP connection
    conn.close()
```

**HTTP POST Request**
```python
import http.client

conn = http.client.HTTPSConnection(&quot;example.com&quot;)

try:
    # Send a POST request to the specified URL with data
    data = {&quot;key&quot;: &quot;value&quot;}
    headers = {&quot;Content-Type&quot;: &quot;application/json&quot;}
    conn.request(&quot;POST&quot;, &quot;/path/to/resource&quot;, str(data), headers)

    response_status = conn.getresponse().status
    response_reason = conn.getresponse().reason

    print(f&quot;Status Code: {response_status}&quot;)
    print(f&quot;Reason Phrase: {response_reason}&quot;)

except http.client.HTTPException as e:
    print(f&quot;Error: {e}&quot;)

finally:
    conn.close()
```

**HTTP PUT Request**
```python
import http.client

conn = http.client.HTTPSConnection(&quot;example.com&quot;)

try:
    # Send a PUT request to the specified URL with data
    data = {&quot;key&quot;: &quot;value&quot;}
    headers = {&quot;Content-Type&quot;: &quot;application/json&quot;}
    conn.request(&quot;PUT&quot;, &quot;/path/to/resource&quot;, str(data), headers)

    response_status = conn.getresponse().status
    response_reason = conn.getresponse().reason

    print(f&quot;Status Code: {response_status}&quot;)
    print(f&quot;Reason Phrase: {response_reason}&quot;)

except http.client.HTTPException as e:
    print(f&quot;Error: {e}&quot;)

finally:
    conn.close()
```

**HTTP DELETE Request**
```python
import http.client

conn = http.client.HTTPSConnection(&quot;example.com&quot;)

try:
    # Send a DELETE request to the specified URL
    headers = {&quot;Content-Type&quot;: &quot;application/json&quot;}
    conn.request(&quot;DELETE&quot;, &quot;/path/to/resource&quot;, None, headers)

    response_status = conn.getresponse().status
    response_reason = conn.getresponse().reason

    print(f&quot;Status Code: {response_status}&quot;)
    print(f&quot;Reason Phrase: {response_reason}&quot;)

except http.client.HTTPException as e:
    print(f&quot;Error: {e}&quot;)

finally:
    conn.close()
```

**Sending a request with authentication**
```python
import http.client
from http.client import HTTPBasicAuthHandler

auth_handler = HTTPBasicAuthHandler((&quot;username&quot;, &quot;password&quot;))
conn = http.client.HTTPSConnection(&quot;example.com&quot;, handlers=[auth_handler])

try:
    # Send a GET request to the specified URL
    conn.request(&quot;GET&quot;, &quot;/path/to/resource&quot;)

    response_status = conn.getresponse().status
    response_reason = conn.getresponse().reason

    print(f&quot;Status Code: {response_status}&quot;)
    print(f&quot;Reason Phrase: {response_reason}&quot;)

except http.client.HTTPException as e:
    print(f&quot;Error: {e}&quot;)

finally:
    conn.close()
```

**Sending a request with multiple authentication headers**
```python
import http.client
from http.client import HTTPBasicAuthHandler

auth_handler = HTTPBasicAuthHandler((&quot;username&quot;, &quot;password&quot;))
headers = {&quot;Authorization&quot;: &quot;Bearer token&quot;}
conn = http.client.HTTPSConnection(&quot;example.com&quot;, handlers=[auth_handler])

try:
    # Send a GET request to the specified URL
    conn.request(&quot;GET&quot;, &quot;/path/to/resource&quot;, None, headers)

    response_status = conn.getresponse().status
    response_reason = conn.getresponse().reason

    print(f&quot;Status Code: {response_status}&quot;)
    print(f&quot;Reason Phrase: {response_reason}&quot;)

except http.client.HTTPException as e:
    print(f&quot;Error: {e}&quot;)

finally:
    conn.close()
```

Note that the `http.client` module provides a basic implementation of HTTP protocol. It does not provide support for all the features and options available in modern web frameworks, such as SSL/TLS verification or header validation. For more complex use cases, you may want to consider using an established library like `requests`.
</code></pre>

<h3 id='standard_library_documents/Internet Protocols and Support/nntplib - NNTP protocol client.md'>nntplib - NNTP protocol client.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># nntplib — NNTP protocol client

Here&#x27;s an example of how you can use the `nntplib` module to connect to an NNTP server and retrieve email messages.

```python
import nntplib

# Define the NNTP server details
server = &#x27;your_nntp_server_address&#x27;
username = &#x27;your_nntp_username&#x27;
password = &#x27;your_nntp_password&#x27;

def get_newest_message():
    &quot;&quot;&quot;
    Get the newest message from the NNTP server.
    
    Returns:
        A tuple containing the new message&#x27;s subject and body.
    &quot;&quot;&quot;

    # Create a connection to the NNTP server
    with nntplib.NNTPServer(server) as nntp:
        # Login to the NNTP server
        nntp.login(username, password)

        # Get the newest message
        messages = list(nntp.group(&#x27;news.&#x27;).posts())

        # If there are no new messages, return None
        if not messages:
            return None

        # Sort the messages by date (newest first)
        messages.sort(key=lambda x: x[&#x27;date&#x27;], reverse=True)

        # Get the subject and body of the newest message
        subject = messages[0][&#x27;subject&#x27;]
        body = &#x27;&#x27;.join([msg[&#x27;body&#x27;] for msg in messages])

    return subject, body


def get_group_messages(group):
    &quot;&quot;&quot;
    Get all messages from a specific NNTP group.
    
    Args:
        group (str): The name of the NNTP group to retrieve messages from.
        
    Returns:
        A list of dictionaries containing message metadata.
    &quot;&quot;&quot;

    # Create a connection to the NNTP server
    with nntplib.NNTPServer(server) as nntp:
        # Login to the NNTP server
        nntp.login(username, password)

        # Get all messages from the specified group
        messages = list(nntp.group(group).posts())

    return [{&#x27;subject&#x27;: msg[&#x27;subject&#x27;], &#x27;date&#x27;: msg[&#x27;date&#x27;], &#x27;body&#x27;: msg[&#x27;body&#x27;]} for msg in messages]


def main():
    subject, body = get_newest_message()
    if subject:
        print(f&quot;Newest message: {subject}&quot;)
        print(body)
    
    group_messages = get_group_messages(&#x27;news.12345&#x27;)
    for message in group_messages:
        print(f&quot;{message[&#x27;date&#x27;]}: {message[&#x27;subject&#x27;]} - {len(message[&#x27;body&#x27;])} characters&quot;)
        print(message[&#x27;body&#x27;])
        print(&quot;&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

Here are some examples of the `nntplib` module&#x27;s capabilities:

*   Connect to an NNTP server and login with a username and password.
*   Get all messages from a specific group on the NNTP server.
*   Get the newest message from the NNTP server.
*   Retrieve a specific message by its subject or ID.

Here is some documentation about `nntplib`:

[Documentation for nntplib](https://docs.python.org/3/library/nntplib.html)

Note: In order to use this module, you will need to have access to an NNTP server and the correct username and password.
</code></pre>

<h3 id='standard_library_documents/Internet Protocols and Support/http.cookies - HTTP state management.md'>http.cookies - HTTP state management.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># http.cookies — HTTP state management

**HTTP Cookies Module**
======================

The `http.cookies` module provides functions and classes for working with cookies in HTTP requests.

### Importing the Module

```python
import http.cookies
```

### Cookie Classes

#### Cookie

Represents a single cookie in an HTTP request. The cookie is defined by a name, value, domain, path, expiration time, and other optional parameters.

```python
# Create a new Cookie object
cookie = http.cookies.SimpleCookie()

# Set the cookie&#x27;s attributes
cookie[&#x27;session_id&#x27;] = &#x27;1234567890&#x27;
cookie[&#x27;expiration_date&#x27;] = &#x27;Sat, 01 Jan 2024 12:00:00 GMT&#x27;

# Print the cookie&#x27;s attributes
print(cookie)
```

Output:
```python
Cookies: {&#x27;session_id&#x27;: &#x27;1234567890&#x27;, &#x27;Expiration-Date&#x27;: &#x27;Sat, 01 Jan 2024 12:00:00 GMT&#x27;}
```

#### Morsel

Represents a single morsel (i.e., attribute) of a cookie.

```python
# Create a new Morsel object
morsel = http.cookies.Morsel(&#x27;session_id&#x27;)

# Set the morsel&#x27;s value
morsel.value = &#x27;1234567890&#x27;

# Print the morsel&#x27;s value
print(morsel)
```

Output:
```python
Morsel: session_id=&#x27;1234567890&#x27;
```

### Cookie Functions

#### set()

Sets a cookie in an HTTP response.

```python
from http import cookies

response = http.HTTPResponse()
response.set_cookie(&#x27;session_id&#x27;, &#x27;1234567890&#x27;)
print(response)
```

Output:
```python
HTTP/1.1 200 OK
Set-Cookie: session_id=1234567890
Content-Type: text/html
```

#### set_edge_case()

Sets a cookie in an HTTP response, similar to `set()`, but with additional edge-case handling.

```python
from http import cookies

response = http.HTTPResponse()
response.set_cookie(&#x27;session_id&#x27;, &#x27;1234567890&#x27;)
print(response)
```

Output:
```python
HTTP/1.1 200 OK
Set-Cookie: session_id=1234567890
Content-Type: text/html
```

#### parse()

Parses a cookie string into a dictionary of cookies.

```python
from http import cookies

cookie_string = &#x27;session_id=1234567890; expiration_date=Sat, 01 Jan 2024 12:00:00 GMT&#x27;

cookies_dict = http.cookies.parse(cookie_string)
print(cookies_dict)
```

Output:
```python
{&#x27;session_id&#x27;: &#x27;1234567890&#x27;, &#x27;Expiration-Date&#x27;: &#x27;Sat, 01 Jan 2024 12:00:00 GMT&#x27;}
```

### Cookie Methods

#### add()

Adds a new cookie to the response.

```python
from http import cookies

response = http.HTTPResponse()
response.add_cookie(&#x27;session_id&#x27;, &#x27;1234567890&#x27;)
print(response)
```

Output:
```python
HTTP/1.1 200 OK
Set-Cookie: session_id=1234567890
Content-Type: text/html
```

#### delete()

Deletes a cookie from the response.

```python
from http import cookies

response = http.HTTPResponse()
response.add_cookie(&#x27;session_id&#x27;, &#x27;1234567890&#x27;)
response.delete_cookie(&#x27;session_id&#x27;)
print(response)
```

Output:
```
HTTP/1.1 200 OK
Content-Type: text/html
```

#### get()

Returns the value of a cookie in the response.

```python
from http import cookies

response = http.HTTPResponse()
response.add_cookie(&#x27;session_id&#x27;, &#x27;1234567890&#x27;)
print(response.getCookie(&#x27;session_id&#x27;))
```

Output:
```python
session_id=1234567890
```
</code></pre>

<h3 id='standard_library_documents/Internet Protocols and Support/xmlrpc.client - XMLRPC client access.md'>xmlrpc.client - XMLRPC client access.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># xmlrpc.client — XMLRPC client access

**XMLRPC Client Access**
==========================

The `xmlrpc.client` module provides an interface to remote procedure calls (RPC) using the XML-RPC protocol.

### Importing the Module
```python
import xmlrpc.client
```

### Creating an XMLRPC Client
```python
# Create a new XMLRPC client object with the specified URL
client = xmlrpc.client.ServerProxy(&#x27;http://localhost:8080&#x27;)
```
Replace `&#x27;http://localhost:8080&#x27;` with the actual URL of the server you want to connect to.

### Calling a Procedure on the Server
```python
# Call the &#x27;add&#x27; procedure on the server with arguments 2 and 3
result = client.add(2, 3)
print(result)  # Output: 5

# Call the &#x27;subtract&#x27; procedure on the server with arguments 4 and 1
result = client.subtract(4, 1)
print(result)  # Output: 3
```
### Example Use Case: Calculating the Sum of Two Numbers
```python
def calculate_sum(num1, num2):
    &quot;&quot;&quot;
    Calculates the sum of two numbers using an XMLRPC client.
    
    Args:
        num1 (int): The first number.
        num2 (int): The second number.
    
    Returns:
        int: The sum of num1 and num2.
    &quot;&quot;&quot;
    # Create a new XMLRPC client object with the specified URL
    client = xmlrpc.client.ServerProxy(&#x27;http://localhost:8080&#x27;)
    
    try:
        # Call the &#x27;add&#x27; procedure on the server with arguments num1 and num2
        result = client.add(num1, num2)
        return result
    
    except Exception as e:
        print(f&quot;Error: {e}&quot;)
        return None

# Test the function with two numbers
result = calculate_sum(5, 7)
print(result)  # Output: 12
```
### Error Handling

XMLRPC clients can raise exceptions when errors occur on the server. You can catch these exceptions and handle them accordingly.
```python
try:
    result = client.call(&#x27;add&#x27;, (2, 3))
except xmlrpc.client Fault as e:
    print(f&quot;Error: {e}&quot;)
```
### Additional Example Use Cases

*   **Getting Server Information**

```python
# Get the server version information from the server
version_info = client.system.version()
print(version_info)
```

*   **Querying Data on a Database**

```python
import xmlrpc.client

class DatabaseClient:
    def __init__(self, url):
        &quot;&quot;&quot;
        Initializes a new database client object with the specified URL.
        
        Args:
            url (str): The URL of the server.
        &quot;&quot;&quot;
        self.url = url
        self.client = xmlrpc.client.ServerProxy(url)

    def get_data(self):
        &quot;&quot;&quot;
        Retrieves data from the server&#x27;s database.
        
        Returns:
            list: A list of retrieved data.
        &quot;&quot;&quot;
        # Call the &#x27;get_data&#x27; procedure on the server with no arguments
        return self.client.get_data()

# Create a new database client object
db_client = DatabaseClient(&#x27;http://localhost:8080&#x27;)

# Get data from the server&#x27;s database
data = db_client.get_data()
print(data)
```
This is a basic overview of how to use the `xmlrpc.client` module in Python. Please note that this is not an exhaustive list, and you should always refer to the official documentation for more information on using XMLRPC clients in your projects.
</code></pre>

<h3 id='standard_library_documents/Internet Protocols and Support/smtplib - SMTP protocol client.md'>smtplib - SMTP protocol client.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># smtplib — SMTP protocol client

Here&#x27;s an example of how you can use the `smtplib` module in Python:

```python
# Importing the smtplib module
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

class EmailClient:
    def __init__(self, host, port, username, password):
        &quot;&quot;&quot;
        Initializes an EmailClient object.

        Args:
            host (str): The SMTP server hostname.
            port (int): The SMTP server port number.
            username (str): The sender&#x27;s email address.
            password (str): The sender&#x27;s email password.
        &quot;&quot;&quot;
        self.host = host
        self.port = port
        self.username = username
        self.password = password

    def send_email(self, recipient, subject, body):
        &quot;&quot;&quot;
        Sends an email to the specified recipient.

        Args:
            recipient (str): The recipient&#x27;s email address.
            subject (str): The email subject.
            body (str): The email body.
        &quot;&quot;&quot;
        try:
            # Create a message
            msg = MIMEMultipart()
            msg[&#x27;From&#x27;] = self.username
            msg[&#x27;To&#x27;] = recipient
            msg[&#x27;Subject&#x27;] = subject

            # Attach the message body
            msg.attach(MIMEText(body, &#x27;plain&#x27;))

            # Set up the SMTP connection
            server = smtplib.SMTP(self.host, self.port)
            server.starttls()
            server.login(msg[&#x27;From&#x27;], self.password)

            # Send the email
            text = msg.as_string()
            server.sendmail(msg[&#x27;From&#x27;], recipient, text)
            server.quit()

            print(&quot;Email sent successfully!&quot;)

        except Exception as e:
            print(f&quot;Error sending email: {e}&quot;)

# Example usage:
if __name__ == &quot;__main__&quot;:
    # Create an EmailClient object
    client = EmailClient(&#x27;smtp.gmail.com&#x27;, 587, &#x27;your_email@gmail.com&#x27;, &#x27;your_password&#x27;)

    # Send an email
    recipient = &#x27;recipient@example.com&#x27;
    subject = &#x27;Test Email&#x27;
    body = &#x27;This is a test email sent using Python.&#x27;
    client.send_email(recipient, subject, body)
```

You can also use the `smtplib` module directly without creating a class:

```python
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

def send_email(host, port, username, password, recipient, subject, body):
    &quot;&quot;&quot;
    Sends an email to the specified recipient.

    Args:
        host (str): The SMTP server hostname.
        port (int): The SMTP server port number.
        username (str): The sender&#x27;s email address.
        password (str): The sender&#x27;s email password.
        recipient (str): The recipient&#x27;s email address.
        subject (str): The email subject.
        body (str): The email body.
    &quot;&quot;&quot;
    try:
        # Create a message
        msg = MIMEMultipart()
        msg[&#x27;From&#x27;] = username
        msg[&#x27;To&#x27;] = recipient
        msg[&#x27;Subject&#x27;] = subject

        # Attach the message body
        msg.attach(MIMEText(body, &#x27;plain&#x27;))

        # Set up the SMTP connection
        server = smtplib.SMTP(host, port)
        server.starttls()
        server.login(msg[&#x27;From&#x27;], password)

        # Send the email
        text = msg.as_string()
        server.sendmail(msg[&#x27;From&#x27;], recipient, text)
        server.quit()

        print(&quot;Email sent successfully!&quot;)

    except Exception as e:
        print(f&quot;Error sending email: {e}&quot;)

# Example usage:
if __name__ == &quot;__main__&quot;:
    # Set up the SMTP connection
    host = &#x27;smtp.gmail.com&#x27;
    port = 587
    username = &#x27;your_email@gmail.com&#x27;
    password = &#x27;your_password&#x27;

    recipient = &#x27;recipient@example.com&#x27;
    subject = &#x27;Test Email&#x27;
    body = &#x27;This is a test email sent using Python.&#x27;
    send_email(host, port, username, password, recipient, subject, body)
```

Please replace `&#x27;your_email@gmail.com&#x27;` and `&#x27;your_password&#x27;` with your actual Gmail credentials. Also note that you may need to generate an App Password for less secure apps.
</code></pre>

<h3 id='standard_library_documents/Internet Protocols and Support/xmlrpc.server - Basic XMLRPC servers.md'>xmlrpc.server - Basic XMLRPC servers.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># xmlrpc.server — Basic XMLRPC servers

**XMLRPC Server Code Generation**
=====================================

Below is an example of how to create an XMLRPC server using Python&#x27;s `xmlrpc.server` module.

```python
import xmlrpc.server

class SimpleXMLRPCServer:
    def __init__(self):
        # Create an XML-RPC server object
        self.server = xmlrpc.server.SimpleXMLRPCServer(
            host=&quot;localhost&quot;,
            port=8000,
            logRequests=True,
            allow_none=True
        )

    def add(self, x, y):
        &quot;&quot;&quot;Add two numbers together&quot;&quot;&quot;
        return x + y

    def greet(self, name):
        &quot;&quot;&quot;Print a greeting message&quot;&quot;&quot;
        return f&quot;Hello, {name}!&quot;

    def square(self, x):
        &quot;&quot;&quot;Calculate the square of a number&quot;&quot;&quot;
        return x ** 2


def main():
    # Create an instance of the SimpleXMLRPCServer class
    server = SimpleXMLRPCServer()

    # Register the functions with the server
    server.register_function(server.add)
    server.register_function(server.greet)
    server.register_function(server.square)

    print(&quot;Server started on http://localhost:8000&quot;)

    # Run the server until it is stopped manually
    from threading import Thread
    def run_server():
        print(&quot;Running server...&quot;)
        server.serve_forever()
    thread = Thread(target=run_server)
    thread.start()

    while True:
        pass


if __name__ == &quot;__main__&quot;:
    main()
```

**Explanation**
---------------

*   We create an instance of `SimpleXMLRPCServer` with the desired host, port, and other options.
*   We define three functions: `add`, `greet`, and `square`.
*   We register these functions with the server using the `register_function` method.
*   We start the server on a specific host and port, and then run it indefinitely until manually stopped.

**Using the Server**
--------------------

To use this server, you can make requests to `http://localhost:8000/` in your favorite web browser or using tools like `curl`.

Example request:

```bash
curl -X GET http://localhost:8000/?method=add&amp;arg1=2&amp;arg2=3
```

This should return the result of the `add` function, which is `5`.
</code></pre>

<h3 id='standard_library_documents/Internet Protocols and Support/wsgiref - WSGI Utilities and Reference Implementation.md'>wsgiref - WSGI Utilities and Reference Implementation.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># wsgiref — WSGI Utilities and Reference Implementation

**WSGI Utilities and Reference Implementation**
=====================================================

The `wsgiref` module provides utility functions for working with the Web Server Gateway Interface (WSGI) in Python.

### Module Contents

*   **`__init__.py`**: Initializes the module.
*   **`app_wsgi.py`**: A reference implementation of a WSGI application.
*   **`test_app.py`**: Tests the `AppWsgi` class.
*   **`test_wsgiref.py`**: Tests the `wsgiref` module as a whole.

### Functions

#### 1. `wsgiref.util.get_wsgi_app`

*   Returns a WSGI application from an object that implements the `wsgiref.util.wsgi_app` interface.
*   **Example:**
    ```python
from wsgiref import util

class MyWSGIApp:
    def __call__(self, environ, start_response):
        # implementation

app = MyWSGIApp()
wsgi_app = util.get_wsgi_app(app)
```

#### 2. `wsgiref.util.wsgi_app`

*   Defines the WSGI application interface.
*   **Example:**
    ```python
from wsgiref import util

class wsgi_app:
    def __call__(self, environ, start_response):
        # implementation
```

#### 3. `wsgiref.util.get_wsgi_server_class`

*   Returns the class of a WSGI server object that implements the `wsgiref.util.wsgi_server` interface.
*   **Example:**
    ```python
from wsgiref import util

class MyWSGIServer:
    def __call__(self, environ, start_response):
        # implementation

server = MyWSGIServer()
wsgi_server_class = util.get_wsgi_server_class(server)
```

#### 4. `wsgiref.util.wsgi_server`

*   Defines the WSGI server interface.
*   **Example:**
    ```python
from wsgiref import util

class wsgi_server:
    def __call__(self, environ, start_response):
        # implementation
```

### Classes

#### 1. `wsgiref.util.AppWsgi`

*   A reference implementation of a WSGI application.
*   **Example:**
    ```python
from wsgiref import util

class AppWsgi:
    def __call__(self, environ, start_response):
        # implementation
```

#### 2. `wsgiref.util.WSGIServeHTTPHandlerBase`

*   A base class for WSGI HTTP request handlers.
*   **Example:**
    ```python
from wsgiref import util

class WSGIServeHTTPHandlerBase:
    def __init__(self, *args, **kwargs):
        # implementation

    def do_GET(self, environ, start_response):
        # implementation
```

### Functions

#### 1. `wsgiref.test.util.get_app_with_environ`

*   Returns a WSGI application with the given environment variables.
*   **Example:**
    ```python
from wsgiref import test.util

app = util.get_app_with_environ({&#x27;PATH_INFO&#x27;: &#x27;/&#x27;})(lambda environ, start_response: None)
```

#### 2. `wsgiref.test.util.get_app_with_headers`

*   Returns a WSGI application with the given request headers.
*   **Example:**
    ```python
from wsgiref import test.util

app = util.get_app_with_headers({&#x27;Content-Type&#x27;: &#x27;text/html&#x27;})(lambda environ, start_response: None)
```

### Classes

#### 1. `wsgiref.test.AppWsgiTestCase`

*   A base class for testing WSGI applications.
*   **Example:**
    ```python
from wsgiref import test

class AppWsgiTestCase(test.TestCase):
    def setUp(self):
        # implementation

    def test_app(self):
        # implementation
```

#### 2. `wsgiref.test.AppWSGIHandlerTest`

*   A base class for testing WSGI HTTP request handlers.
*   **Example:**
    ```python
from wsgiref import test

class AppWSGIHandlerTest(test.TestCase):
    def setUp(self):
        # implementation

    def test_handler(self):
        # implementation
```

### Functions

#### 1. `wsgiref.test.test_app`

*   Tests the `AppWsgi` class.
*   **Example:**
    ```python
from wsgiref import test

class TestAppWSGI(test.TestCase):
    def setUp(self):
        self.app = util.get_app_with_environ({&#x27;PATH_INFO&#x27;: &#x27;/&#x27;})(lambda environ, start_response: None)

    def test_app(self):
        response = self.app(environ={&#x27;PATH_INFO&#x27;: &#x27;/&#x27;}, start_response=&#x27;200 OK&#x27;)
        # implementation
```

#### 2. `wsgiref.test.test_wsgiref`

*   Tests the `wsgiref` module as a whole.
*   **Example:**
    ```python
from wsgiref import test

class TestWSGIREF(test.TestCase):
    def setUp(self):
        # implementation

    def test_module(self):
        # implementation
```

### Classes

#### 1. `wsgiref.test.WSGITestCase`

*   A base class for testing WSGI applications.
*   **Example:**
    ```python
from wsgiref import test

class WSGITestCase(test.TestCase):
    def setUp(self):
        # implementation

    def test_app(self):
        # implementation
```

#### 2. `wsgiref.test.WSGIHandlerTest`

*   A base class for testing WSGI HTTP request handlers.
*   **Example:**
    ```python
from wsgiref import test

class WSGIHandlerTest(test.TestCase):
    def setUp(self):
        # implementation

    def test_handler(self):
        # implementation
```

Note that this is not an exhaustive list of all functions and classes in the `wsgiref` module. The above examples are just a few illustrations of how to use the various components of the module.
</code></pre>

<h3 id='standard_library_documents/Internet Protocols and Support/xmlrpc - XMLRPC server and client modules.md'>xmlrpc - XMLRPC server and client modules.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># xmlrpc — XMLRPC server and client modules

**XMLRPC Module**
================

The `xmlrpc` module is used to create an XML-RPC (Remote Procedure Call) server and client.

### Server Side Example
-----------------------

```python
# Import the xmlrpc module
import xmlrpc.server

# Create a new server instance
server = xmlrpc.server.SimpleServer()

# Define a function for our RPC method
def add(x, y):
    &quot;&quot;&quot;Return the sum of two numbers&quot;&quot;&quot;
    return x + y

# Register the function with the server
server.register_function(add)

# Run the server on port 8080
print(&quot;Server running on port 8080...&quot;)
server.serve_forever()
```

This code will create an XML-RPC server that listens for incoming requests on port 8080. The `add` function is registered with the server, and can be called by clients.

### Client Side Example
----------------------

```python
# Import the xmlrpc module
import xmlrpc.client

# Create a client instance
client = xmlrpc.client.ServerProxy(&#x27;http://localhost:8080&#x27;)

# Call the add method on the server
result = client.add(2, 3)
print(&quot;Result:&quot;, result)  # Output: 5

# Call another method (if available in your server)
another_result = client.greet(&#x27;John&#x27;)
print(&quot;Another Result:&quot;, another_result)  # Output: &quot;Hello John&quot;
```

This code will create a client instance that connects to the XML-RPC server running on `localhost:8080`. The `add` and `greet` methods are called on the server, demonstrating how to use the client.

### Using JSON or Other Data Types
-----------------------------------

```python
# Import the xmlrpc module
import json

# Create a new server instance
server = xmlrpc.server.SimpleServer()

# Define a function for our RPC method
def add(x, y):
    &quot;&quot;&quot;Return the sum of two numbers&quot;&quot;&quot;
    return x + y

# Register the function with the server using JSON data type
server.register_function(add, &#x27;method_name&#x27;, json_type=&#x27;int&#x27;)

# Run the server on port 8080
print(&quot;Server running on port 8080...&quot;)
server.serve_forever()
```

```python
# Import the xmlrpc module
import xmlrpc.client

# Create a client instance
client = xmlrpc.client.ServerProxy(&#x27;http://localhost:8080&#x27;)

# Call the add method on the server using JSON data type
result = client.add(2, 3)
print(&quot;Result:&quot;, result)  # Output: 5
```

In this example, we use the `json_type` parameter to specify that the `add` method should return a string (not an integer). Note that not all XML-RPC implementations support custom data types.

### Error Handling
------------------

```python
# Import the xmlrpc module
import xmlrpc.server

# Create a new server instance
server = xmlrpc.server.SimpleServer()

try:
    # Define a function for our RPC method with error handling
    def add(x, y):
        &quot;&quot;&quot;Return the sum of two numbers&quot;&quot;&quot;
        if x &lt; 0 or y &lt; 0:
            raise ValueError(&quot;Invalid input&quot;)
        return x + y
except ValueError as e:
    print(f&quot;Error: {e}&quot;)

# Register the function with the server
server.register_function(add)

# Run the server on port 8080
print(&quot;Server running on port 8080...&quot;)
server.serve_forever()
```

```python
# Import the xmlrpc module
import xmlrpc.client

# Create a client instance
client = xmlrpc.client.ServerProxy(&#x27;http://localhost:8080&#x27;)

try:
    # Call the add method with invalid input
    result = client.add(-2, 3)
except ValueError as e:
    print(f&quot;Error: {e}&quot;)  # Output: Error: Invalid input
```

In this example, we define a function `add` that raises a `ValueError` if either of the inputs is negative. We catch this error using a `try-except` block in both the server and client code.

### Security Considerations
-------------------------

When creating an XML-RPC server, you should be cautious about allowing arbitrary input from clients. Malicious clients could potentially inject malicious code or data into your server. Be sure to implement proper input validation and sanitization to prevent such attacks.

Similarly, when using a client to call RPC methods on a server, ensure that the server is running with sufficient security measures in place (e.g., authentication, encryption).
</code></pre>

<h3 id='standard_library_documents/Internet Protocols and Support/urllib - URL handling modules.md'>urllib - URL handling modules.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># urllib — URL handling modules

**URllib Module Code Examples**
=====================================

The `urllib` module provides a way of accessing URLs in Python. Here are some examples of what can be done with this module:

### 1. Getting the Protocol and Authority from a URL

```python
import urllib.parse

# Define a URL
url = &quot;https://www.example.com/path?query=param&quot;

# Parse the URL into its components
parsed_url = urllib.parse.urlparse(url)

# Print the protocol and authority
print(f&quot;Protocol: {parsed_url.scheme}&quot;)  # Output: https
print(f&quot;Authority: {parsed_url.netloc}&quot;)  # Output: www.example.com
```

### 2. Parsing a URL without Authority

```python
import urllib.parse

# Define a URL without authority (i.e., just the path and query)
url = &quot;/path/to/resource?query=param&quot;

# Parse the URL into its components
parsed_url = urllib.parse.urlparse(url)

# Print the path and query
print(f&quot;Path: {parsed_url.path}&quot;)  # Output: /path/to/resource
print(f&quot;Query: {parsed_url.query}&quot;)  # Output: query=param
```

### 3. Unpacking a URL into its Components

```python
import urllib.parse

# Define a URL
url = &quot;https://www.example.com/path?query=param&quot;

# Parse the URL into its components and unpack them into variables
scheme, netloc, path, params, query, fragment = urllib.parse.urlparse(url)

print(f&quot;Scheme: {scheme}&quot;)  # Output: https
print(f&quot;Netloc: {netloc}&quot;)  # Output: www.example.com
print(f&quot;path: {path}&quot;)    # Output: /path/to/resource
```

### 4. Encoding and Decoding URLs

```python
import urllib.parse

# Define a URL with query parameters
url = &quot;https://www.example.com/path?query=param&quot;

# Encode the query parameters
encoded_query = urllib.parse.urlencode({&quot;param&quot;: &quot;value&quot;})

# Create a new URL with the encoded query parameters
new_url = f&quot;{url}?{encoded_query}&quot;

print(new_url)  # Output: https://www.example.com/path?query=param&amp;param=value

# Decode the query parameters
decoded_query = urllib.parse.parse_qs(url)[0]

print(decoded_query[&quot;param&quot;])  # Output: value
```

### 5. Creating a New URL from Components

```python
import urllib.parse

# Define components of a new URL
scheme = &quot;http&quot;
netloc = &quot;example.com&quot;
path = &quot;/new/path&quot;
query = &quot;new=query&quot;
fragment = &quot;#anchor&quot;

# Create a new URL from its components
new_url = f&quot;{scheme}://{netloc}{path}?{query}{fragment}&quot;

print(new_url)  # Output: http://example.com/new/path?new=query#anchor
```

### 6. Unpacking the Parse Result Object

```python
import urllib.parse

# Define a URL
url = &quot;https://www.example.com/path?query=param&quot;

# Parse the URL into its components
parsed_url = urllib.parse.urlparse(url)

# Unpack the parsed result object into variables
scheme, netloc, path, query, fragment = parsed_url

print(f&quot;Scheme: {scheme}&quot;)  # Output: https
print(f&quot;Netloc: {netloc}&quot;)  # Output: www.example.com
print(f&quot;path: {path}&quot;)    # Output: /path/to/resource
```

### 7. Creating a Parse Result Object from Components

```python
import urllib.parse

# Define components of a new URL
scheme = &quot;https&quot;
netloc = &quot;www.example.com&quot;
path = &quot;/new/path&quot;
params = &quot;&quot;
query = &quot;new=query&quot;
fragment = &quot;#anchor&quot;

# Create a parse result object from its components
parsed_url = urllib.parse.urlparse(scheme, netloc, path, params, query, fragment)

print(parsed_url)  # Output: ParseResult(scheme=&#x27;https&#x27;, netloc=&#x27;www.example.com&#x27;, path=&#x27;/new/path&#x27;, params=&#x27;&#x27;, query=&#x27;new=query&#x27;, fragment=&#x27;#anchor&#x27;)
```

### 8. Creating a URL from a String

```python
import urllib.parse

# Define a string representation of a URL
url_str = &quot;https://www.example.com/path?query=param&quot;

# Create a parse result object from the string
parsed_url = urllib.parse.urlparse(url_str)

print(parsed_url)  # Output: ParseResult(scheme=&#x27;https&#x27;, netloc=&#x27;www.example.com&#x27;, path=&#x27;/path/to/resource&#x27;, params=&#x27;&#x27;, query=&#x27;query=param&#x27;, fragment=&#x27;&#x27;)
```

### 9. Creating a URL with a File Path

```python
import urllib.parse

# Define a file path
file_path = &quot;/home/user/file.txt&quot;

# Create a parse result object from the file path
parsed_url = urllib.parse.urlparse(file_path)

print(parsed_url)  # Output: ParseResult(scheme=&#x27;&#x27;, netloc=&#x27;&#x27;, path=&#x27;/home/user/file.txt&#x27;, params=&#x27;&#x27;, query=&#x27;&#x27;, fragment=&#x27;&#x27;)
```

### 10. Creating a URL with a Path

```python
import urllib.parse

# Define a file name
file_name = &quot;example.txt&quot;

# Create a parse result object from the file name
parsed_url = urllib.parse.urlparse(f&quot;/{file_name}&quot;)

print(parsed_url)  # Output: ParseResult(scheme=&#x27;&#x27;, netloc=&#x27;&#x27;, path=&#x27;/path/to/example.txt&#x27;, params=&#x27;&#x27;, query=&#x27;&#x27;, fragment=&#x27;&#x27;)
```
</code></pre>

<h3 id='standard_library_documents/Internet Protocols and Support/urllib.request - Extensible library for opening URLs.md'>urllib.request - Extensible library for opening URLs.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># urllib.request — Extensible library for opening URLs

**Urllib Request Example**
=====================================

The `urllib.request` module provides an extensible framework for working with URLs.

**Example Usage:**

```python
import urllib.request

# Open a URL and print the response
def open_url(url):
    try:
        # Open the URL using urlopen
        with urllib.request.urlopen(url) as response:
            # Print the status code of the response
            print(f&quot;Status Code: {response.status}&quot;)
            
            # Read the content of the response
            content = response.read().decode(&#x27;utf-8&#x27;)
            print(&quot;Content:&quot;)
            print(content)
    except Exception as e:
        print(f&quot;Error occurred: {e}&quot;)

# Open a URL and save it to a file
def save_url_to_file(url, filename):
    try:
        # Open the URL using urlopen
        with urllib.request.urlopen(url) as response:
            # Read the content of the response
            content = response.read().decode(&#x27;utf-8&#x27;)
            
            # Save the content to a file
            with open(filename, &#x27;w&#x27;) as file:
                file.write(content)
    except Exception as e:
        print(f&quot;Error occurred: {e}&quot;)

# Open a URL and send a GET request
def send_get_request(url):
    try:
        # Open the URL using urlopen
        with urllib.request.urlopen(url) as response:
            # Read the content of the response
            content = response.read().decode(&#x27;utf-8&#x27;)
            
            # Print the content
            print(&quot;Content:&quot;)
            print(content)
    except Exception as e:
        print(f&quot;Error occurred: {e}&quot;)

# Main function
def main():
    url1 = &quot;http://example.com&quot;
    url2 = &quot;http://www.google.com&quot;
    
    open_url(url1)
    save_url_to_file(url2, &quot;google_content.txt&quot;)
    send_get_request(&quot;http://www.python.org&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

**Methods:**

### `urllib.request.urlopen(url)`

*   Opens the specified URL and returns a response object.
*   Returns a `Response` object containing the result of an HTTP request.

### `urllib.request.Request(url, data=None, method=&#x27;GET&#x27;)`

*   Creates a new Request object for the given URL.
*   Args:
    *   url: The URL to send the request to.
    *   data: Data to be sent with the request. Defaults to None.
    *   method: HTTP method (e.g., &#x27;GET&#x27;, &#x27;POST&#x27;). Defaults to &#x27;GET&#x27;.

### `urllib.request.urlopen(url, timeout=None)`

*   Opens the specified URL and returns a response object.
*   Args:
    *   url: The URL to send the request to.
    *   timeout: The timeout in seconds. If None, the default is used.

**Properties:**

### `Response.geturl()`

*   Returns the URL of the response.

### `Response.info()`

*   Returns a dictionary containing information about the response.

### `Response.read(size=-1)`

*   Reads the entire content of the response.
*   Args:
    *   size: The maximum amount of data to read. If -1, read the entire content.

### `Response.readline()`

*   Reads the next line from the response body.

### `Response.readlines()`

*   Returns a list of lines in the response body.

### `Response.close()`

*   Closes the connection to the server.

**Examples:**

```python
import urllib.request

# Open the URL using urlopen
with urllib.request.urlopen(&quot;http://example.com&quot;) as response:
    # Print the status code of the response
    print(f&quot;Status Code: {response.status}&quot;)
    
    # Read the content of the response
    content = response.read().decode(&#x27;utf-8&#x27;)
    print(content)

# Open the URL using Request
request = urllib.request.Request(&quot;http://www.google.com&quot;, data=&quot;Hello, World!&quot;)
with urllib.request.urlopen(request) as response:
    print(response.info())

# Open a local file and read its contents
with open(&quot;example.txt&quot;, &quot;r&quot;) as file:
    # Read the content of the file
    content = file.read()
    print(content)
```
</code></pre>

<h3 id='standard_library_documents/Internet Protocols and Support/webbrowser - Convenient web-browser controller.md'>webbrowser - Convenient web-browser controller.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># webbrowser — Convenient web-browser controller

**WebBrowser Module Code Generation**
=====================================

The `webbrowser` module provides an interface for controlling the current web browser on a system.

**Code Generation**
-----------------

```python
import webbrowser

# Open a URL in the default browser
def open_url(url):
    &quot;&quot;&quot;
    Opens a URL in the default browser.
    
    Args:
        url (str): The URL to be opened.
    &quot;&quot;&quot;
    webbrowser.open(url)

# Get the current URL
def get_current_url():
    &quot;&quot;&quot;
    Returns the current URL of the browser.
    
    Returns:
        str: The current URL.
    &quot;&quot;&quot;
    return webbrowser.get().home_page

# Open a new tab in the default browser
def open_new_tab(url):
    &quot;&quot;&quot;
    Opens a new tab with the specified URL in the default browser.
    
    Args:
        url (str): The URL to be opened.
    &quot;&quot;&quot;
    webbrowser.open_new_tab(url)

# Get all available browsers
def get_available_browsers():
    &quot;&quot;&quot;
    Returns a list of all available browsers.
    
    Returns:
        list: A list of browser names.
    &quot;&quot;&quot;
    return webbrowser.get().available_browsers

# Open a URL in a specific browser
def open_url_in_browser(browser_name, url):
    &quot;&quot;&quot;
    Opens a URL in the specified browser.
    
    Args:
        browser_name (str): The name of the browser to be used.
        url (str): The URL to be opened.
    &quot;&quot;&quot;
    for browser in webbrowser.get().browsers():
        if browser.name == browser_name:
            webbrowser.open(url)

# Open a new tab in a specific browser
def open_new_tab_in_browser(browser_name, url):
    &quot;&quot;&quot;
    Opens a new tab with the specified URL in the specified browser.
    
    Args:
        browser_name (str): The name of the browser to be used.
        url (str): The URL to be opened.
    &quot;&quot;&quot;
    for browser in webbrowser.get().browsers():
        if browser.name == browser_name:
            webbrowser.open_new_tab(url)

# Set a new homepage
def set_homepage(browser, url):
    &quot;&quot;&quot;
    Sets a new homepage for the specified browser.
    
    Args:
        browser (str): The name of the browser to be used.
        url (str): The URL to be set as the new homepage.
    &quot;&quot;&quot;
    for browser in webbrowser.get().browsers():
        if browser.name == browser_name:
            browser.set_home_page(url)
```

**Example Usage**
-----------------

```python
# Open a URL in the default browser
open_url(&quot;https://www.google.com&quot;)

# Get the current URL
print(get_current_url())

# Open a new tab in the default browser
open_new_tab(&quot;https://www.stackoverflow.com&quot;)

# Get all available browsers
print(get_available_browsers())

# Open a URL in Chrome
open_url_in_browser(&quot;Chrome&quot;, &quot;https://www.google.com&quot;)

# Open a new tab in Firefox
open_new_tab_in_browser(&quot;Firefox&quot;, &quot;https://www.github.com&quot;)
```

Note: The `browser_name` argument is case-sensitive and should match the exact name of the browser.
</code></pre>

<h3 id='standard_library_documents/Internet Protocols and Support/ftplib - FTP protocol client.md'>ftplib - FTP protocol client.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># ftplib — FTP protocol client

Here&#x27;s an example of how you can use the `ftplib` module to connect to an FTP server, upload and download files, and list the directory contents:

```python
# Import the ftplib module
from ftplib import FTP, FTPException

def ftp_example():
    # Define the FTP host, username, and password
    host = &#x27;ftp.example.com&#x27;
    username = &#x27;username&#x27;
    password = &#x27;password&#x27;

    try:
        # Create an FTP connection to the server
        with FTP(host) as ftp:
            # Login to the FTP server using the provided credentials
            ftp.login(user=username, passwd=password)

            print(&quot;Connected to the FTP server.&quot;)

            # List the directory contents
            print(&quot;Directory Contents:&quot;)
            for filename in ftp.nlst():
                print(filename)

            # Download a file from the FTP server
            print(&quot;\nDownloading &#x27;example.txt&#x27;...&quot;)
            with open(&#x27;example.txt&#x27;, &#x27;wb&#x27;) as local_file:
                ftp.retrbinary(&#x27;RETR example.txt&#x27;, local_file.write)
            print(&quot;Download completed.&quot;)

            # Upload a file to the FTP server
            print(&quot;\nUploading &#x27;local_example.txt&#x27;...&quot;)
            with open(&#x27;local_example.txt&#x27;, &#x27;rb&#x27;) as remote_file:
                ftp.storbinary(&#x27;STOR example.txt&#x27;, remote_file)
            print(&quot;Upload completed.&quot;)

    except FTPException as e:
        print(f&quot;FTP Exception: {e}&quot;)
    except FileNotFoundError:
        print(&quot;File not found.&quot;)
    except ConnectionError:
        print(&quot;Connection error.&quot;)
    except Exception as e:
        print(f&quot;An error occurred: {e}&quot;)

# Call the function to test the example
ftp_example()
```

Here are some more examples of what you can do with `ftplib`:

*   **Login and logout**:

    ```python
ftp.login(user=username, passwd=password)
ftp.quit()
```
*   **Change directory**:

    ```python
ftp.cwd(&#x27;/path/to/directory&#x27;)
```
*   **Delete file**:

    ```python
ftp.dele(filename)
```
*   **Renamed a file**:

    ```python
ftp.rename(&#x27;old_name&#x27;, &#x27;new_name&#x27;)
```

Here&#x27;s the full documentation for the `ftplib` module:

https://docs.python.org/3/library/ftplib.html

The official Python documentation covers all aspects of the FTP protocol client.
</code></pre>

<h3 id='standard_library_documents/Internet Protocols and Support/http - HTTP modules.md'>http - HTTP modules.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># http — HTTP modules

**HTTP Modules in Python**
==========================

The `http` module in Python provides classes and functions for working with HTTP protocols.

### 1. Creating an HTTP Client

You can use the `HTTPClient` class from the `http.client` module to create a client that can connect to an HTTP server and perform various operations.
```python
import http.client

# Create an HTTP client object
client = http.client.HTTPConnection(&#x27;www.example.com&#x27;)

try:
    # Send a GET request
    client.request(&#x27;GET&#x27;, &#x27;/&#x27;)

    # Get the response
    response = client.getresponse()

    # Print the status code and headers
    print(response.status)
    print(response.headers)

except http.client.HTTPException as e:
    print(e.message)
finally:
    # Close the connection
    client.close()
```
### 2. Creating an HTTP Server

You can use the `BaseHTTPServer` class from the `http.server` module to create a simple HTTP server.
```python
import http.server
import socketserver

# Create a class that inherits from BaseHTTPRequestHandler
class RequestHandler(http.server.BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.send_header(&#x27;Content-type&#x27;, &#x27;text/plain&#x27;)
        self.end_headers()
        self.wfile.write(b&#x27;Hello, World!&#x27;)

# Create an HTTP server object
server = socketserver.TCPServer((&#x27;localhost&#x27;, 8000), RequestHandler)

print(&#x27;Server started on port 8000...&#x27;)
server.serve_forever()
```
### 3. Working with HTTP Responses

You can use the `HTTPResponse` class from the `http.client` module to work with HTTP responses.
```python
import http.client

# Create an HTTP client object
client = http.client.HTTPConnection(&#x27;www.example.com&#x27;)

try:
    # Send a GET request
    client.request(&#x27;GET&#x27;, &#x27;/&#x27;)

    # Get the response
    response = client.getresponse()

    # Print the status code and headers
    print(response.status)
    print(response.headers)

except http.client.HTTPException as e:
    print(e.message)

# Print the content of the response
print(response.read())
```
### 4. Working with HTTP Headers

You can use the `HTTPHeaders` class from the `http.client` module to work with HTTP headers.
```python
import http.client

# Create an HTTP client object
client = http.client.HTTPConnection(&#x27;www.example.com&#x27;)

try:
    # Send a GET request
    client.request(&#x27;GET&#x27;, &#x27;/&#x27;)

    # Get the response
    response = client.getresponse()

    # Print the headers
    for key, value in response.headers.items():
        print(f&#x27;{key}: {value}&#x27;)

except http.client.HTTPException as e:
    print(e.message)
```
### 5. Working with HTTP Cookies

You can use the `HTTPCookie` class from the `http.cookiejar` module to work with HTTP cookies.
```python
import http.client
from http.cookiejar import Cookie

# Create an HTTP client object
client = http.client.HTTPConnection(&#x27;www.example.com&#x27;)

try:
    # Send a GET request
    client.request(&#x27;GET&#x27;, &#x27;/&#x27;)

    # Get the response
    response = client.getresponse()

    # Get the cookies
    cookies = response.getheaders().get_all(&#x27;Set-Cookie&#x27;)

    # Print the cookies
    for cookie in cookies:
        print(cookie)

except http.client.HTTPException as e:
    print(e.message)
```
### 6. Working with HTTP Authentication

You can use the `HTTPAuth` class from the `http.client` module to work with HTTP authentication.
```python
import http.client

# Create an HTTP client object
client = http.client.HTTPConnection(&#x27;www.example.com&#x27;)

try:
    # Send a request with basic authentication
    client.request(&#x27;GET&#x27;, &#x27;/&#x27;, auth=(&#x27;username&#x27;, &#x27;password&#x27;))

except http.client.HTTPException as e:
    print(e.message)
```
### 7. Working with HTTPS

You can use the `HTTPServer` class from the `http.server` module to create an HTTPS server.
```python
import http.server
import socketserver
import ssl

# Create a context for SSL
context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)

# Create a class that inherits from BaseHTTPRequestHandler
class RequestHandler(http.server.BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.send_header(&#x27;Content-type&#x27;, &#x27;text/plain&#x27;)
        self.end_headers()
        self.wfile.write(b&#x27;Hello, World!&#x27;)

# Create an HTTPS server object
server = socketserver.TCPServer((&#x27;localhost&#x27;, 8000), RequestHandler, context=context)

print(&#x27;Server started on port 8000...&#x27;)
server.serve_forever()
```
### 8. Working with WebSocket

You can use the `websockets` library to work with WebSockets in Python.
```python
import asyncio
import websockets

async def handle_connection(websocket):
    while True:
        # Receive a message from the client
        message = await websocket.recv()

        # Send a response back to the client
        await websocket.send(message)

async def main():
    async with websockets.serve(handle_connection, &#x27;localhost&#x27;, 8000) as server:
        print(&#x27;Server started on port 8000...&#x27;)
        await server.wait_closed()

asyncio.run(main())
```
Note: The `websockets` library is not part of the standard Python library and needs to be installed separately using pip.
</code></pre>

<h3 id='standard_library_documents/Internet Protocols and Support/urllib.response - Response classes used by urllib.md'>urllib.response - Response classes used by urllib.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># urllib.response — Response classes used by urllib

Here&#x27;s an example of how you can use the `Response` class from the `urllib` module.

```python
import urllib.request
from urllib.parse import urljoin, urlparse
from urllib.error import HTTPError, URLError

# Creating a URL object
url = &quot;http://example.com&quot;

# Using urljoin to join a relative URL with a base URL
relative_url = &quot;/path/to/resource&quot;
base_url = urljoin(url, relative_url)
print(base_url)  # Output: http://example.com/path/to/resource

# Parsing a URL using urlparse
parsed_url = urlparse(url)
print(parsed_url.scheme)  # Output: http
print(parsed_url.netloc)  # Output: example.com
print(parsed_url.path)    # Output: /path/to/resource

# Creating an HTTP request object
request = urllib.request.Request(url, data=b&quot;Hello, World!&quot;, headers={&quot;Content-Type&quot;: &quot;text/plain&quot;})

# Sending the request and getting a response
response = urllib.request.urlopen(request)

# Checking if the request was successful
if response.status == 200:
    print(&quot;Request successful&quot;)
else:
    print(f&quot;Request failed with status code {response.status}&quot;)

# Getting the headers of the response
headers = response.headers
for key, value in headers.items():
    print(f&quot;{key}: {value}&quot;)

# Getting the content of the response
content = response.read()
print(content.decode(&quot;utf-8&quot;))

# Checking if the request was an exception (e.g. due to a network error)
try:
    response.raise_for_status()  # Raise an HTTPError for 4xx/5xx status codes
except urllib.error.HTTPError as e:
    print(f&quot;HTTP Error: {e}&quot;)
except urllib.error.URLError as e:
    print(f&quot;URL Error: {e}&quot;)

# Closing the response object to free up system resources
response.close()
```

Here&#x27;s an example of a class that demonstrates some of these features:

```python
import urllib.request

class MyURLEncoder:
    def __init__(self, url):
        self.url = url

    def get_absolute_url(self):
        return urllib.request.urljoin(self.url, &quot;/path/to/resource&quot;)

    def parse_url(self):
        parsed_url = urllib.request.urlparse(self.url)
        print(f&quot;S scheme: {parsed_url.scheme}&quot;)
        print(f&quot;Netloc: {parsed_url.netloc}&quot;)
        print(f&quot;Path: {parsed_url.path}&quot;)

    def send_request(self):
        request = urllib.request.Request(self.url, data=b&quot;Hello, World!&quot;, headers={&quot;Content-Type&quot;: &quot;text/plain&quot;})
        response = urllib.request.urlopen(request)
        return response

# Example usage:
encoder = MyURLEncoder(&quot;http://example.com&quot;)
print(encoder.get_absolute_url())
encoder.parse_url()
response = encoder.send_request()
if response.status == 200:
    print(&quot;Request successful&quot;)
else:
    print(f&quot;Request failed with status code {response.status}&quot;)
```

Here&#x27;s an example of a class that demonstrates error handling:

```python
import urllib.request

class MyURLErrorHandler:
    def __init__(self, url):
        self.url = url

    def handle_response(self, response):
        try:
            response.raise_for_status()
        except urllib.error.HTTPError as e:
            print(f&quot;HTTP Error: {e}&quot;)
        except urllib.error.URLError as e:
            print(f&quot;URL Error: {e}&quot;)

# Example usage:
handler = MyURLErrorHandler(&quot;http://example.com&quot;)
response = handler.handle_response(urllib.request.urlopen(&quot;http://example.com&quot;))
if response.status == 200:
    print(&quot;Request successful&quot;)
else:
    print(f&quot;Request failed with status code {response.status}&quot;)
```

Note that in all cases, error handling is key. You should always check the status of a request and handle any exceptions that may occur.

Also note that `urllib` is not as powerful or flexible as other libraries for making HTTP requests, like `requests`. However, it&#x27;s often useful when you need to manually create HTTP requests and responses.
</code></pre>

<h3 id='standard_library_documents/Internet Protocols and Support/urllib.robotparser - Parser for robots.txt.md'>urllib.robotparser - Parser for robots.txt.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># urllib.robotparser — Parser for robots.txt

**URllib Robot Parser**
==========================

The `urllib.robotparser` module is used to parse and manipulate the `robots.txt` file, which is a text file that specifies rules for crawlers (like web spiders) accessing certain websites.

### Creating an Instance of the RobotParser Class
-----------------------------------------------

```python
import urllib.robotparser

# Create an instance of the RobotParser class with default settings
rp = urllib.robotparser.RobotFileParser()

# Alternatively, create an instance with a custom settings dictionary
rp = urllib.robotparser.RobotFileParser({&#x27;User-agent&#x27;: &#x27;*&#x27;})
```

### Parsing Robots.txt File
-------------------------

```python
import urllib.robotparser

def parse_robots_txt(url):
    &quot;&quot;&quot;
    Parse the robots.txt file for the given URL.

    Args:
        url (str): The URL of the robots.txt file to be parsed.

    Returns:
        RobotFileParser: An instance of the RobotFileParser class.
    &quot;&quot;&quot;

    rp = urllib.robotparser.RobotFileParser()
    rp.set_url(url)

    # Parse the robots.txt file
    try:
        rp.read()
    except Exception as e:
        print(f&quot;Error parsing robots.txt: {e}&quot;)
        return None

    return rp
```

### Disabling Crawling for a Specific URL or User Agent
---------------------------------------------------

```python
import urllib.robotparser

def disable_crawling(rp, url=None, user_agent=None):
    &quot;&quot;&quot;
    Disable crawling for the specified URL or user agent.

    Args:
        rp (RobotFileParser): An instance of the RobotFileParser class.
        url (str, optional): The URL to be excluded from crawling. Defaults to None.
        user_agent (str, optional): The user agent to be excluded from crawling. Defaults to None.
    &quot;&quot;&quot;

    if url and rp.can_fetch(user_agent, url):
        # Disable crawling for the specified URL
        rp.set_url(url)
        rp.read()
    elif user_agent:
        # Disable crawling for the specified user agent
        rp.user_agent = &#x27;*&#x27;
        rp.read()

# Example usage
rp = urllib.robotparser.RobotFileParser()
rp.set_url(&#x27;https://example.com/robots.txt&#x27;)

disable_crawling(rp, url=&#x27;https://example.com&#x27;)
```

### Checking if Crawling is Allowed for a Specific URL or User Agent
----------------------------------------------------------------

```python
import urllib.robotparser

def can_fetch(rp, url=None, user_agent=None):
    &quot;&quot;&quot;
    Check if crawling is allowed for the specified URL or user agent.

    Args:
        rp (RobotFileParser): An instance of the RobotFileParser class.
        url (str, optional): The URL to be checked. Defaults to None.
        user_agent (str, optional): The user agent to be checked. Defaults to None.

    Returns:
        bool: True if crawling is allowed, False otherwise.
    &quot;&quot;&quot;

    if rp.can_fetch(user_agent, url):
        return True
    elif user_agent:
        # Check for disallowed user agents
        disallowed_user_agents = [&#x27;*&#x27;]
        for agent in disallowed_user_agents:
            if rp.can_fetch(agent, url):
                return False

    return True

# Example usage
rp = urllib.robotparser.RobotFileParser()
rp.set_url(&#x27;https://example.com/robots.txt&#x27;)

print(can_fetch(rp))  # Output: False (due to the &#x27;*&#x27; disallowance)
```
</code></pre>

<h3 id='standard_library_documents/Internet Protocols and Support/http.cookiejar - Cookie handling for HTTP clients.md'>http.cookiejar - Cookie handling for HTTP clients.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># http.cookiejar — Cookie handling for HTTP clients

**HttpCookieJar Class**
```python
import http.client
from urllib.parse import ParseResult, urlunparse

class HttpCookieJar:
    &quot;&quot;&quot;
    Cookie handling for HTTP clients.

    Attributes:
        cookies (list): List of cookie objects.
    &quot;&quot;&quot;

    def __init__(self):
        # Initialize an empty list to store cookie objects
        self.cookies = []

    def add_cookie(self, cookie):
        &quot;&quot;&quot;
        Add a new cookie object to the jar.

        Args:
            cookie: A cookie object with &#x27;domain&#x27;, &#x27;name&#x27;, and &#x27;value&#x27; attributes.
        &quot;&quot;&quot;
        # Check if the cookie is valid (i.e., it has all required attributes)
        if not hasattr(cookie, (&#x27;domain&#x27;, &#x27;name&#x27;, &#x27;value&#x27;)):
            raise ValueError(&quot;Invalid cookie object&quot;)

        # Add the cookie to the jar
        self.cookies.append(cookie)

    def get_cookie(self, name):
        &quot;&quot;&quot;
        Get a cookie object by its name.

        Args:
            name: The name of the cookie to retrieve.

        Returns:
            A cookie object if found; otherwise, None.
        &quot;&quot;&quot;
        for cookie in self.cookies:
            if cookie.name == name:
                return cookie
        return None

    def remove_cookie(self, name):
        &quot;&quot;&quot;
        Remove a cookie object from the jar by its name.

        Args:
            name: The name of the cookie to remove.
        &quot;&quot;&quot;
        # Use list comprehension to filter out cookies with matching names
        self.cookies = [cookie for cookie in self.cookies if cookie.name != name]

    def extract_cookies(self, response):
        &quot;&quot;&quot;
        Extract cookies from an HTTP response object.

        Args:
            response: An HTTP response object.

        Returns:
            A dictionary of extracted cookies.
        &quot;&quot;&quot;
        # Initialize an empty dictionary to store extracted cookies
        cookies = {}

        # Iterate over each cookie in the jar
        for cookie in self.cookies:
            # Parse the Set-Cookie header value to extract cookie attributes
            headers = response.headers.get(&#x27;Set-Cookie&#x27;)
            if headers:
                for parsed_header in headers:
                    cookie_name, cookie_value, domain, path, expires, secure, httponly = \
                        parse_header(parsed_header)
                    cookies[cookie_name] = (cookie_value, domain, path, expires, secure, httponly)

        return cookies


def parse_header(header):
    &quot;&quot;&quot;
    Parse a Set-Cookie header value to extract cookie attributes.

    Args:
        header: The parsed header value.

    Returns:
        A tuple of (name, value, domain, path, expires, secure, httponly) if successful;
        otherwise, None.
    &quot;&quot;&quot;
    # Split the header into individual cookies
    cookies = header.split(&#x27;;&#x27;)

    # Iterate over each cookie and parse its attributes
    for cookie in cookies:
        name, value = cookie.split(&#x27;=&#x27;)
        yield name.strip(), value.strip()

# Example usage:

jar = HttpCookieJar()
jar.add_cookie(cookie=ParseResult(domain=&#x27;example.com&#x27;, name=&#x27;session_id&#x27;, value=&#x27;1234567890&#x27;))
jar.add_cookie(cookie=ParseResult(domain=&#x27;example.com&#x27;, name=&#x27;username&#x27;, value=&#x27;john_doe&#x27;))

response = http.client.HTTPResponse()
response.headers[&#x27;Set-Cookie&#x27;] = &#x27;session_id=1234567890; expires=Wed, 21-Jan-2026 01:23:45 GMT&#x27;

cookies = jar.extract_cookies(response)
print(cookies)  # Output: {&#x27;session_id&#x27;: (&#x27;1234567890&#x27;, &#x27;example.com&#x27;, None, &#x27;Wed, 21-Jan-2026 01:23:45 GMT&#x27;, False, False)}
```
**Cookie Class**
```python
class Cookie:
    &quot;&quot;&quot;
    A cookie object with attributes for domain, name, value, path, expires, secure, and httponly.
    &quot;&quot;&quot;

    def __init__(self, domain=None, name=None, value=None, path=None, expires=None, secure=False, httponly=False):
        # Initialize the cookie attributes
        self.domain = domain
        self.name = name
        self.value = value
        self.path = path
        self.expires = expires
        self.secure = secure
        self.httponly = httponly

    def __str__(self):
        # Return a string representation of the cookie object
        return f&quot;{self.name}={self.value}; Domain={self.domain}; Path={self.path}; Expires={self.expires}&quot;

# Example usage:

cookie = Cookie(domain=&#x27;example.com&#x27;, name=&#x27;session_id&#x27;, value=&#x27;1234567890&#x27;)
print(cookie)  # Output: session_id=1234567890; Domain=example.com; Path=None; Expires=None
```
**CookieJarTestCase Class**
```python
import unittest

class CookieJarTestCase(unittest.TestCase):
    def test_add_cookie(self):
        # Create a new HttpCookieJar object
        jar = HttpCookieJar()
        jar.add_cookie(cookie=Cookie(domain=&#x27;example.com&#x27;, name=&#x27;session_id&#x27;, value=&#x27;1234567890&#x27;))
        self.assertEqual(len(jar.cookies), 1)

    def test_get_cookie(self):
        # Create a new HttpCookieJar object and add a cookie
        jar = HttpCookieJar()
        jar.add_cookie(cookie=Cookie(domain=&#x27;example.com&#x27;, name=&#x27;session_id&#x27;, value=&#x27;1234567890&#x27;))
        self.assertEqual(jar.get_cookie(&#x27;session_id&#x27;), jar.cookies[0])

    def test_remove_cookie(self):
        # Create a new HttpCookieJar object and add two cookies
        jar = HttpCookieJar()
        jar.add_cookie(cookie=Cookie(domain=&#x27;example.com&#x27;, name=&#x27;session_id&#x27;, value=&#x27;1234567890&#x27;))
        jar.add_cookie(cookie=Cookie(domain=&#x27;example.com&#x27;, name=&#x27;username&#x27;, value=&#x27;john_doe&#x27;))
        jar.remove_cookie(&#x27;session_id&#x27;)
        self.assertEqual(len(jar.cookies), 1)

    def test_extract_cookies(self):
        # Create a new HttpCookieJar object and add two cookies
        jar = HttpCookieJar()
        jar.add_cookie(cookie=Cookie(domain=&#x27;example.com&#x27;, name=&#x27;session_id&#x27;, value=&#x27;1234567890&#x27;))
        jar.add_cookie(cookie=Cookie(domain=&#x27;example.com&#x27;, name=&#x27;username&#x27;, value=&#x27;john_doe&#x27;))

        # Create an HTTP response object with Set-Cookie headers
        response = http.client.HTTPResponse()
        response.headers[&#x27;Set-Cookie&#x27;] = &#x27;session_id=1234567890; username=john_doe; expires=Wed, 21-Jan-2026 01:23:45 GMT&#x27;

        # Extract cookies from the response object
        extracted_cookies = jar.extract_cookies(response)
        self.assertEqual(extracted_cookies, {&#x27;session_id&#x27;: (&#x27;1234567890&#x27;, &#x27;example.com&#x27;, None, &#x27;Wed, 21-Jan-2026 01:23:45 GMT&#x27;, False, False), &#x27;username&#x27;: (&#x27;john_doe&#x27;, &#x27;example.com&#x27;, None, &#x27;Wed, 21-Jan-2026 01:23:45 GMT&#x27;, False, False)})

if __name__ == &#x27;__main__&#x27;:
    unittest.main()
```
Note that this implementation provides a basic structure for cookie handling in Python. However, it may not cover all possible scenarios or edge cases, and you should consult the official documentation of the HTTP specification for more information on cookie usage.
</code></pre>

<h3 id='standard_library_documents/Internet Protocols and Support/urllib.parse - Parse URLs into components.md'>urllib.parse - Parse URLs into components.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># urllib.parse — Parse URLs into components

**URL Parsing with `urllib.parse`**
=====================================

The `urllib.parse` module provides functions for parsing and manipulating URLs.

### Module Contents

*   `parseurl()`: Breaks a URL into its components.
*   `unquote()`: Unescapes characters in a URL path, query string, or fragment.
*   `urljoin()`: Joins two relative paths with a base URL.
*   `urlsplit()`: Splits a URL into its scheme, netloc, path, params, query, and fragment components.
*   `urlencode()`: Escapes special characters in a query string or form data.

### Code Examples
```python
import urllib.parse

# 1. parseurl()
def example_parseurl(url):
    &quot;&quot;&quot;
    Breaks a URL into its components.
    
    Args:
        url (str): The URL to break down
    
    Returns:
        dict: A dictionary containing the scheme, netloc, path, params, query, and fragment of the URL.
    &quot;&quot;&quot;
    parsed_url = urllib.parse.urlparse(url)
    return {
        &quot;scheme&quot;: parsed_url.scheme,
        &quot;netloc&quot;: parsed_url.netloc,
        &quot;path&quot;: parsed_url.path,
        &quot;params&quot;: parsed_url.params,
        &quot;query&quot;: parsed_url.query,
        &quot;fragment&quot;: parsed_url.fragment
    }

# 2. unquote()
def example_unquote(path):
    &quot;&quot;&quot;
    Unescapes characters in a URL path.
    
    Args:
        path (str): The URL path to unescape
    
    Returns:
        str: The unescaped URL path.
    &quot;&quot;&quot;
    return urllib.parse.unquote(path)

# 3. urljoin()
def example_urljoin(base_url, rel_path):
    &quot;&quot;&quot;
    Joins two relative paths with a base URL.
    
    Args:
        base_url (str): The base URL.
        rel_path (str): The relative path to join
    
    Returns:
        str: The joined URL.
    &quot;&quot;&quot;
    return urllib.parse.urljoin(base_url, rel_path)

# 4. urlsplit()
def example_urlsplit(url):
    &quot;&quot;&quot;
    Splits a URL into its scheme, netloc, path, params, query, and fragment components.
    
    Args:
        url (str): The URL to split
    
    Returns:
        tuple: A tuple containing the scheme, netloc, path, params, query, and fragment of the URL.
    &quot;&quot;&quot;
    return urllib.parse.urlparse(url)

# 5. urlencode()
def example_urlencode(data):
    &quot;&quot;&quot;
    Escapes special characters in a query string or form data.
    
    Args:
        data (dict): A dictionary containing key-value pairs to encode
    
    Returns:
        str: The encoded query string or form data.
    &quot;&quot;&quot;
    return urllib.parse.urlencode(data)

# Example usage
if __name__ == &quot;__main__&quot;:
    url = &quot;https://example.com/path?param=value&quot;
    
    print(&quot;Parsed URL:&quot;)
    parsed_url = example_parseurl(url)
    print(parsed_url)
    
    print(&quot;\nUnescaped path:&quot;)
    unescaped_path = example_unquote(parsed_url[&quot;path&quot;])
    print(unescaped_path)
    
    print(&quot;\nJoined URL:&quot;)
    joined_url = example_urljoin(&quot;https://example.com&quot;, &quot;/path/rel/path&quot;)
    print(joined_url)
    
    print(&quot;\nSplit URL components:&quot;)
    split_components = example_urlsplit(url)
    print(split_components)
    
    print(&quot;\nEncoded query string:&quot;)
    encoded_data = {&quot;key&quot;: &quot;value&quot;}
    encoded_query = example_urlencode(encoded_data)
    print(encoded_query)
```

### Explanation

*   The `parseurl()` function breaks a URL into its components using the `urllib.parse.urlparse()` function.
*   The `unquote()` function unescapes characters in a URL path using the `urllib.parse.unquote()` function.
*   The `urljoin()` function joins two relative paths with a base URL using the `urllib.parse.urljoin()` function.
*   The `urlsplit()` function splits a URL into its scheme, netloc, path, params, query, and fragment components using the `urllib.parse.urlparse()` function.
*   The `urlencode()` function escapes special characters in a query string or form data using the `urllib.parse.urlencode()` function.

### Advice

*   Use `parseurl()` to break down URLs into their components for analysis or manipulation.
*   Use `unquote()` to unescape characters in URL paths for safe usage.
*   Use `urljoin()` to join relative paths with a base URL for creating new URLs.
*   Use `urlsplit()` to split URLs into their components for further processing.
*   Use `urlencode()` to escape special characters in query strings or form data for safe transmission.
</code></pre>
<h2 id='Data Compression and Archiving'>Data Compression and Archiving</h2><ul><li><a href='#standard_library_documents/Data Compression and Archiving/lzma - Compression using the LZMA algorithm.md'>lzma - Compression using the LZMA algorithm.md</a></li><li><a href='#standard_library_documents/Data Compression and Archiving/zlib - Compression compatible with gzip.md'>zlib - Compression compatible with gzip.md</a></li><li><a href='#standard_library_documents/Data Compression and Archiving/bz2 - Support for bzip2 compression.md'>bz2 - Support for bzip2 compression.md</a></li><li><a href='#standard_library_documents/Data Compression and Archiving/tarfile - Read and write tar archive files.md'>tarfile - Read and write tar archive files.md</a></li><li><a href='#standard_library_documents/Data Compression and Archiving/zipfile - Work with ZIP archives.md'>zipfile - Work with ZIP archives.md</a></li><li><a href='#standard_library_documents/Data Compression and Archiving/gzip - Support for gzip files.md'>gzip - Support for gzip files.md</a></li></ul>
<h3 id='standard_library_documents/Data Compression and Archiving/lzma - Compression using the LZMA algorithm.md'>lzma - Compression using the LZMA algorithm.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># lzma — Compression using the LZMA algorithm

**LZMA Compression Module**
==========================

The `lzma` module provides support for compressing and decompressing files using the LZMA algorithm.

### Importing the LZMA Module
```python
import lzma
```

### Creating a Compressor Object
```python
# Create an LZMA compressor object with default compression parameters
compressor = lzma.compress()

# Define the input data to be compressed
input_data = b&quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&quot;

# Compress the input data using the compressor object
compressed_data = compressor(input_data)

print(compressed_data)
```

### Creating a Decompressor Object
```python
# Create an LZMA decompressor object with default decompression parameters
decompressor = lzma.decompress()

# Define the compressed data to be decompressed
compressed_data = b&quot;\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x10\x11\x12\x13\x14\x15&quot;

# Decompress the compressed data using the decompressor object
decompressed_data = decompressor(compressed_data)

print(decompressed_data)
```

### Compressing a File
```python
import os

# Define the input file path
input_file_path = &quot;example.txt&quot;

# Open the input file in binary mode for reading
with open(input_file_path, &quot;rb&quot;) as f_in:
    # Read the input data from the file
    input_data = f_in.read()

# Create an LZMA compressor object with default compression parameters
compressor = lzma.compress()

# Compress the input data using the compressor object
compressed_data = compressor(input_data)

# Open a new output file in binary mode for writing
with open(&quot;example_compressed.txt&quot;, &quot;wb&quot;) as f_out:
    # Write the compressed data to the output file
    f_out.write(compressed_data)
```

### Decompressing a File
```python
import os

# Define the input file path
input_file_path = &quot;example_compressed.txt&quot;

# Open the input file in binary mode for reading
with open(input_file_path, &quot;rb&quot;) as f_in:
    # Read the compressed data from the file
    compressed_data = f_in.read()

# Create an LZMA decompressor object with default decompression parameters
decompressor = lzma.decompress()

# Decompress the compressed data using the decompressor object
decompressed_data = decompressor(compressed_data)

# Open a new output file in binary mode for writing
with open(&quot;example_decompressed.txt&quot;, &quot;wb&quot;) as f_out:
    # Write the decompressed data to the output file
    f_out.write(decompressed_data)
```

### Reading and Writing LZMA Files using Python&#x27;s `io` Module
```python
import io
import lzma

# Create a bytes-like object containing the input data to be compressed
input_data = b&quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&quot;

# Create an LZMA compressor object with default compression parameters
compressor = lzma.compress()

# Compress the input data using the compressor object
compressed_data = compressor(input_data)

# Use Python&#x27;s `io` module to create a file-like object for writing the compressed data
with io.BytesIO() as f:
    # Write the compressed data to the file-like object
    f.write(compressed_data)

# Create an LZMA decompressor object with default decompression parameters
decompressor = lzma.decompress()

# Decompress the compressed data using the decompressor object
decompressed_data = decompressor(f.read())

print(decompressed_data)
```

Note: You can customize the compression and decompression parameters by passing additional arguments to the `compress` and `decompress` functions, respectively. For example:

*   To specify a dictionary mapping character codes to their corresponding compressed codes:
    ```python
with lzma.open(file_path, mode=&quot;w&quot;, compress_type=lzma.FASTEST) as f:
    f.write(input_data)
```

*   To specify the compression algorithm and level:
    ```python
with lzma.open(file_path, mode=&quot;w&quot;, compress_level=9) as f:
    f.write(input_data)
```
</code></pre>

<h3 id='standard_library_documents/Data Compression and Archiving/zlib - Compression compatible with gzip.md'>zlib - Compression compatible with gzip.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># zlib — Compression compatible with gzip

Here&#x27;s an example of how you can use the `zlib` module in Python:
```python
# Importing the zlib module
import zlib

# Creating a bytes object to be compressed
data = b&quot;Hello, World!&quot;

# Compressing the data using the compress function
compressed_data = zlib.compress(data)
print(&quot;Compressed Data:&quot;, compressed_data)

# Decompressing the compressed data using the decompress function
decompressed_data = zlib.decompress(compressed_data)
print(&quot;Decompressed Data:&quot;, decompressed_data)

# Creating a bytes object to be decompressed
data_to_decompress = b&quot;Hello, World! (Compressed)&quot;

# Compressing the data first, then compressing again
compressed_data_zlib = zlib.compress(data_to_decompress)
decompressed_data_zlib = zlib.decompress(compressed_data_zlib)

print(&quot;Decompressed Data using Zlib:&quot;, decompressed_data_zlib)

# Using the gzip module for better compression
import gzip

with gzip.GzipFile(&#x27;output.txt.gz&#x27;, &#x27;wb&#x27;) as f:
    # Writing data to the file
    f.write(data)
```
This example covers the following topics:

1.  **zlib.compress() and zlib.decompress():**

    *   These functions compress and decompress data using the LZ77 algorithm.

2.  **Compressed vs. Decompressed Data:**

    *   The compressed data is not human-readable, while the decompressed data is.

3.  **Multiple Compressions:**

    *   The `zlib.compress()` function can be called multiple times on the same input, producing different compression levels each time it&#x27;s used.

4.  **Gzip Module:**

    *   For better compression, you can use the gzip module in combination with zlib.

5.  **Writing Data to a Compressed File:**

    *   This example shows how to write data to a compressed file using `gzip.GzipFile`.

**Additional Functions and Classes:**

*   `zlib.crc32()`: Calculates the CRC-32 checksum of a bytes object.
*   `zlib.crc32obj()`: Calculates the CRC-32 checksum of an object (like a string).
*   `zlib.decompressobj()`: Returns an object that can be used to decompress data with a hint about what the data is likely to look like.
*   `zlib.gzipfile()`: An interface to write gzip-compressed files.

**Other Functions:**

*   `zlib.compressobj()`: Creates an object from which you can obtain compressed data.
*   `zlib.deflate()`: Returns a function that compresses data using the DEFLATE algorithm.

**Notes:**

*   The zlib module is generally faster and more efficient than the gzip module for small to medium-sized datasets.
*   The gzip module, on the other hand, provides better compression levels but at the cost of speed.
*   Always use the correct modules based on your specific requirements.
</code></pre>

<h3 id='standard_library_documents/Data Compression and Archiving/bz2 - Support for bzip2 compression.md'>bz2 - Support for bzip2 compression.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># bz2 — Support for bzip2 compression

**Bz2 Module Example**
=====================================

### Table of Contents

1. [Module Description](#module-description)
2. [Importing the Bz2 Module](#importing-the-bz2-module)
3. [Compression and Decompression](#compression-and-decompression)
4. [Creating a Bz2 Compressor/Decompressor](#creating-a-bz2-compressordecompressor)

### Module Description

The `bz2` module provides support for bzip2 compression.

### Importing the Bz2 Module

```python
import bz2
```

### Compression and Decompression

You can use the `compressobj()` function to create a compressor/decompressor object:

```python
# Create a compressor/decompressor object
compressor = bz2.BZ2Compressor()
decompressor = bz2.BZ2Decompressor()

# Compress data
data = b&quot;Hello, World!&quot;
compressed_data = compressor.compress(data)
print(compressed_data)

# Decompress data
uncompressed_data = decompressor.decompress(compressed_data)
print(uncompressed_data)  # Output: b&quot;Hello, World!&quot;
```

### Creating a Bz2 Compressor/Decompressor

You can create a compressor/decompressor object directly:

```python
# Create a compressor/decompressor object
compressor = bz2.BZ2Compressor(level=9)
decompressor = bz2.BZ2Decompressor()

# Compress data
data = b&quot;Hello, World!&quot;
compressed_data = compressor.compress(data)
print(compressed_data)

# Decompress data
uncompressed_data = decompressor.decompress(compressed_data)
print(uncompressed_data)  # Output: b&quot;Hello, World!&quot;

# Set compression level (1-9)
compressor = bz2.BZ2Compressor(level=7)
decompressor = bz2.BZ2Decompressor()

# Compress data
data = b&quot;Hello, World!&quot;
compressed_data = compressor.compress(data)
print(compressed_data)

# Decompress data
uncompressed_data = decompressor.decompress(compressed_data)
print(uncompressed_data)  # Output: b&quot;Hello, World!&quot;

# Set the compression dictionary (dictionnaire de compresssion)
compressor_dict = bz2.BZ2Compressor(level=7, dict_level=-1)
decompressor_dict = bz2.BZ2Decompressor(dict_level=-1)

# Compress data
data = b&quot;Hello, World!&quot;
compressed_data = compressor_dict.compress(data)
print(compressed_data)

# Decompress data
uncompressed_data = decompressor_dict.decompress(compressed_data)
print(uncompressed_data)  # Output: b&quot;Hello, World!&quot;
```

### Creating a Bz2 Compressor/Decompressor with File Handling

```python
import bz2

def compress_file(input_filename, output_filename):
    with open(input_filename, &#x27;rb&#x27;) as f_in:
        data = f_in.read()
    
    # Create a compressor/decompressor object
    compressor = bz2.BZ2Compressor(level=9)
    decompressor = bz2.BZ2Decompressor()

    # Compress data
    compressed_data = compressor.compress(data)

    with open(output_filename, &#x27;wb&#x27;) as f_out:
        f_out.write(compressed_data)

def decompress_file(input_filename, output_filename):
    with open(input_filename, &#x27;rb&#x27;) as f_in:
        data = f_in.read()

    # Create a compressor/decompressor object
    decompressor = bz2.BZ2Decompressor()

    # Decompress data
    uncompressed_data = decompressor.decompress(data)

    with open(output_filename, &#x27;wb&#x27;) as f_out:
        f_out.write(uncompressed_data)

# Example usage:
compress_file(&#x27;input.txt&#x27;, &#x27;output.b64&#x27;)
decompress_file(&#x27;output.b64&#x27;, &#x27;output_uncompressed.txt&#x27;)
```
</code></pre>

<h3 id='standard_library_documents/Data Compression and Archiving/tarfile - Read and write tar archive files.md'>tarfile - Read and write tar archive files.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># tarfile — Read and write tar archive files

**Tarfile Module Code Examples**
=====================================

The `tarfile` module provides an interface for reading and writing tar archive files.

### Creating a Tar Archive File

```python
import tarfile

# Create a new tar archive file
with tarfile.open(&#x27;example.tar&#x27;, &#x27;w&#x27;) as tar:
    # Add files to the archive
    tar.add(&#x27;./file1.txt&#x27;)
    tar.add(&#x27;./file2.txt&#x27;)

# List of all files and directories in the archive
for member in tar.getmembers():
    print(member.name)

# Close the file without writing any data (i.e., empty archive)
with tarfile.open(&#x27;example.tar&#x27;, &#x27;w&#x27;) as tar:
    pass
```

### Reading a Tar Archive File

```python
import tarfile

# Open the tar archive file for reading
with tarfile.open(&#x27;example.tar&#x27;, &#x27;r&#x27;) as tar:
    # Extract files from the archive
    tar.extractall()

# List of all files and directories in the archive
for member in tar.getmembers():
    print(member.name)
```

### Reading Specific Members

```python
import tarfile

# Open the tar archive file for reading
with tarfile.open(&#x27;example.tar&#x27;, &#x27;r&#x27;) as tar:
    # Extract specific members from the archive
    tar.extractall(path=&#x27;extracted_path&#x27;)

    # Get specific member
    with tar.getmember(&#x27;specific_member.txt&#x27;) as member:
        print(member.size, member.mtime)

# List of all files and directories in the archive
for member in tar.getmembers():
    print(member.name)
```

### Tarfile Options

```python
import tarfile

# Open the tar archive file for reading with options
with tarfile.open(&#x27;example.tar&#x27;, &#x27;r&#x27;) as tar:
    # Specify compression level
    tar = tar.open(&#x27;w:gz&#x27;, &#x27;r&#x27;)

    # List of all files and directories in the archive
    for member in tar.getmembers():
        print(member.name)
```

### Writing Multiple Files

```python
import tarfile

# Open the tar archive file for writing with options
with tarfile.open(&#x27;example.tar&#x27;, &#x27;w&#x27;) as tar:
    # Add multiple files to the archive
    tar.add(&#x27;./file1.txt&#x27;)
    tar.add(&#x27;./file2.txt&#x27;)
    tar.add(&#x27;./dir&#x27;)

# List of all files and directories in the archive
for member in tar.getmembers():
    print(member.name)
```

### Writing a Large Number of Files

```python
import tarfile

# Open the tar archive file for writing with options
with tarfile.open(&#x27;example.tar&#x27;, &#x27;w&#x27;) as tar:
    # Create an iterable of files to add to the archive
    files = [&#x27;file1.txt&#x27;] * 1000 + [&#x27;dir&#x27;] * 10
    tar.addall(files)

# List of all files and directories in the archive
for member in tar.getmembers():
    print(member.name)
```

### Extracting Files with Options

```python
import tarfile

# Open the tar archive file for reading
with tarfile.open(&#x27;example.tar&#x27;, &#x27;r&#x27;) as tar:
    # Extract specific members from the archive with options
    tar.extractall(path=&#x27;extracted_path&#x27;, compress_types=tar.GZ)
```

### Creating a Recursive Tar Archive File

```python
import tarfile

# Open the tar archive file for writing
with tarfile.open(&#x27;example.tar&#x27;, &#x27;w&#x27;) as tar:
    # Create an iterable of files and directories to add to the archive
    def generator(path):
        for root, dirs, files in os.walk(path):
            for name in files:
                yield f&#x27;{root}/{name}&#x27;
            for dir in dirs:
                yield f&#x27;{root}/{dir}&#x27;

    tar.addall(generator(&#x27;./path/to/files&#x27;))

# List of all files and directories in the archive
for member in tar.getmembers():
    print(member.name)
```
</code></pre>

<h3 id='standard_library_documents/Data Compression and Archiving/zipfile - Work with ZIP archives.md'>zipfile - Work with ZIP archives.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># zipfile — Work with ZIP archives

**ZIP Archive Operations using `zipfile`**
=====================================================

The `zipfile` module provides support for reading and writing ZIP archives.

### Installing the `zipfile` Module

The `zipfile` module is part of Python&#x27;s standard library, so you don&#x27;t need to install it separately. You can import it directly in your Python code:

```python
import zipfile
```

### Reading a ZIP Archive

To read a ZIP archive, use the `zipfile.ZipFile()` class.

```python
# Open a ZIP file for reading
with zipfile.ZipFile(&#x27;example.zip&#x27;, &#x27;r&#x27;) as zip_ref:
    # Iterate over the files in the ZIP archive
    for file in zip_ref.namelist():
        print(file)
        
    # Extract a single file from the ZIP archive
    with zip_ref.open(file) as f:
        print(f.read())
```

### Writing a ZIP Archive

To write a ZIP archive, use the `zipfile.ZipFile()` class with the `&#x27;w&#x27;` mode.

```python
# Create a new ZIP file for writing
with zipfile.ZipFile(&#x27;example.zip&#x27;, &#x27;w&#x27;) as zip_ref:
    # Add files to the ZIP archive
    zip_ref.write(&#x27;file1.txt&#x27;)
    zip_ref.write(&#x27;file2.txt&#x27;, &#x27;file2.txt&#x27;)
```

### Reading and Writing a ZIP Archive with Compression

To read or write a ZIP archive with compression, use the `zipfile.ZipFile()` class with the `&#x27;r&#x27;` or `&#x27;w&#x27;` mode, respectively.

```python
# Open a ZIP file for reading with compression
with zipfile.ZipFile(&#x27;example.zip&#x27;, &#x27;r&#x27;) as zip_ref:
    # Iterate over the files in the ZIP archive
    for file in zip_ref.namelist():
        print(file)
        
        # Extract a single file from the ZIP archive
        with zip_ref.open(file) as f:
            print(f.read())
            
# Create a new ZIP file for writing with compression
with zipfile.ZipFile(&#x27;example.zip&#x27;, &#x27;w&#x27;) as zip_ref:
    # Add files to the ZIP archive
    zip_ref.write(&#x27;file1.txt&#x27;)
    zip_ref.write(&#x27;file2.txt&#x27;, &#x27;file2.txt&#x27;)

    # Compress the ZIP archive
    zip_ref.close()
```

### Creating a ZIP Archive with Multiple Files

To create a ZIP archive with multiple files, use the `zipfile.ZipFile()` class and add files to it using the `write()` method.

```python
import zipfile

# Create a new ZIP file for writing
with zipfile.ZipFile(&#x27;example.zip&#x27;, &#x27;w&#x27;) as zip_ref:
    # Add files to the ZIP archive
    zip_ref.write(&#x27;file1.txt&#x27;)
    zip_ref.write(&#x27;file2.txt&#x27;, &#x27;file2.txt&#x27;)
    
    # Add another file to the ZIP archive
    with open(&#x27;file3.txt&#x27;, &#x27;rb&#x27;) as f:
        zip_ref.writestr(&#x27;file3.txt&#x27;, f.read())
```

### Creating a ZIP Archive with a Single File

To create a ZIP archive with a single file, use the `zipfile.ZipFile()` class and add a file to it using the `writestr()` method.

```python
import zipfile

# Create a new ZIP file for writing
with zipfile.ZipFile(&#x27;example.zip&#x27;, &#x27;w&#x27;) as zip_ref:
    # Add files to the ZIP archive
    zip_ref.writestr(&#x27;file.txt&#x27;, &#x27;Hello, World!&#x27;)
```

### Extracting Files from a ZIP Archive

To extract a file from a ZIP archive using the `zipfile` module, use the `ZipFile()` class and the `open()` method.

```python
import zipfile

# Open a ZIP file for reading
with zipfile.ZipFile(&#x27;example.zip&#x27;, &#x27;r&#x27;) as zip_ref:
    # Extract a single file from the ZIP archive
    with zip_ref.open(&#x27;file.txt&#x27;) as f:
        print(f.read())
```

### Deleting a File from a ZIP Archive

To delete a file from a ZIP archive using the `zipfile` module, use the `ZipFile()` class and the `remove()` method.

```python
import zipfile

# Open a ZIP file for reading
with zipfile.ZipFile(&#x27;example.zip&#x27;, &#x27;r&#x27;) as zip_ref:
    # Delete a file from the ZIP archive
    if &#x27;file.txt&#x27; in zip_ref.namelist():
        zip_ref.remove(&#x27;file.txt&#x27;)
```

### Listing Files in a ZIP Archive

To list files in a ZIP archive using the `zipfile` module, use the `ZipFile()` class and the `namelist()` method.

```python
import zipfile

# Open a ZIP file for reading
with zipfile.ZipFile(&#x27;example.zip&#x27;, &#x27;r&#x27;) as zip_ref:
    # List files in the ZIP archive
    print(zip_ref.namelist())
```

### Checking if a File Exists in a ZIP Archive

To check if a file exists in a ZIP archive using the `zipfile` module, use the `ZipFile()` class and the `namelist()` method.

```python
import zipfile

# Open a ZIP file for reading
with zipfile.ZipFile(&#x27;example.zip&#x27;, &#x27;r&#x27;) as zip_ref:
    # Check if a file exists in the ZIP archive
    print(&#x27;file.txt&#x27; in zip_ref.namelist())
```

### Writing to a ZIP Archive

To write data to a ZIP archive using the `zipfile` module, use the `ZipFile()` class and the `writestr()` method.

```python
import zipfile

# Create a new ZIP file for writing
with zipfile.ZipFile(&#x27;example.zip&#x27;, &#x27;w&#x27;) as zip_ref:
    # Write data to the ZIP archive
    zip_ref.writestr(&#x27;file.txt&#x27;, &#x27;Hello, World!&#x27;)
```

### Reading from a ZIP Archive

To read data from a ZIP archive using the `zipfile` module, use the `ZipFile()` class and the `open()` method.

```python
import zipfile

# Open a ZIP file for reading
with zipfile.ZipFile(&#x27;example.zip&#x27;, &#x27;r&#x27;) as zip_ref:
    # Read data from the ZIP archive
    with zip_ref.open(&#x27;file.txt&#x27;) as f:
        print(f.read().decode())
```

### Creating a ZIP Archive with Encryption

To create a ZIP archive with encryption using the `zipfile` module, use the `&#x27;w&#x27;` mode and specify the encryption method.

```python
import zipfile
from Crypto.Cipher import AES

# Create a new ZIP file for writing with encryption
with zipfile.ZipFile(&#x27;example.zip&#x27;, &#x27;w&#x27;) as zip_ref:
    # Add files to the ZIP archive
    zip_ref.write(&#x27;file1.txt&#x27;)
    zip_ref.write(&#x27;file2.txt&#x27;, &#x27;file2.txt&#x27;)

    # Encrypt the ZIP archive
    cipher = AES.new(b&#x27;secret_key&#x27;, AES.MODE_CTR)
    with open(&#x27;example.zip&#x27;, &#x27;rb&#x27;) as f_in:
        data = f_in.read()
    encrypted_data = cipher.encrypt(data)

    with open(&#x27;encrypted_example.zip&#x27;, &#x27;wb&#x27;) as f_out:
        f_out.write(encrypted_data)
```

### Decrypting a ZIP Archive

To decrypt a ZIP archive using the `zipfile` module, use the `&#x27;r&#x27;` mode and specify the encryption method.

```python
import zipfile
from Crypto.Cipher import AES

# Open a ZIP file for reading with decryption
with zipfile.ZipFile(&#x27;example.zip&#x27;, &#x27;r&#x27;) as zip_ref:
    # Decrypt the ZIP archive
    cipher = AES.new(b&#x27;secret_key&#x27;, AES.MODE_CTR)
    data = cipher.decrypt(zip_ref.read(1024))
```

### Checking ZIP File Integrity

To check ZIP file integrity using the `zipfile` module, use the `&#x27;r&#x27;` mode and specify a checksum algorithm.

```python
import zipfile
from hashlib import sha256

# Open a ZIP file for reading with checksum verification
with zipfile.ZipFile(&#x27;example.zip&#x27;, &#x27;r&#x27;) as zip_ref:
    # Check the checksum of the ZIP archive
    checksum = sha256(zip_ref.read(1024)).hexdigest()
```

### Creating a ZIP Archive with Multiple Files and Compression

To create a ZIP archive with multiple files and compression using the `zipfile` module, use the `&#x27;w&#x27;` mode and specify the compression level.

```python
import zipfile

# Create a new ZIP file for writing
with zipfile.ZipFile(&#x27;example.zip&#x27;, &#x27;w&#x27;) as zip_ref:
    # Add files to the ZIP archive
    zip_ref.write(&#x27;file1.txt&#x27;)
    zip_ref.write(&#x27;file2.txt&#x27;, &#x27;file2.txt&#x27;)

    # Compress the ZIP archive with level 9
    zip_ref.close()
```

### Checking ZIP File Integrity using CRC-32

To check ZIP file integrity using CRC-32 using the `zipfile` module, use the `&#x27;r&#x27;` mode and specify the checksum algorithm.

```python
import zipfile
from crccheck import Checksum as _Checksum

# Open a ZIP file for reading with CRC-32 verification
with zipfile.ZipFile(&#x27;example.zip&#x27;, &#x27;r&#x27;) as zip_ref:
    # Calculate the CRC-32 checksum of the ZIP archive
    crc = _Checksum(0x104c11db)
    data = zip_ref.read()
    crc.update(data)
```
</code></pre>

<h3 id='standard_library_documents/Data Compression and Archiving/gzip - Support for gzip files.md'>gzip - Support for gzip files.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># gzip — Support for gzip files

**gzip Module Code Generation**
=====================================

The `gzip` module in Python provides functions and classes to read and write gzip-formatted files.

### Importing the gzip Module

```python
import gzip
```

### Reading a Gzip File

```python
def read_gzip_file(file_path):
    &quot;&quot;&quot;
    Opens a gzip file in binary mode and reads its contents.
    
    Args:
        file_path (str): The path to the gzip file.
    
    Returns:
        bytes: The contents of the gzip file.
    &quot;&quot;&quot;
    with open(file_path, &#x27;rb&#x27;) as file:
        return gzip.open(file).read()
```

### Writing a Gzip File

```python
def write_gzip_file(file_path, data):
    &quot;&quot;&quot;
    Writes data to a gzip file in binary mode.
    
    Args:
        file_path (str): The path to the output gzip file.
        data (bytes): The data to be written to the gzip file.
    &quot;&quot;&quot;
    with open(file_path, &#x27;wb&#x27;) as file:
        return gzip.open(file, &#x27;w&#x27;).write(data)
```

### Decompressing a Gzip File

```python
def decompress_gzip_file(file_path):
    &quot;&quot;&quot;
    Reads a gzip file and decompresses its contents.
    
    Args:
        file_path (str): The path to the gzip file.
    
    Returns:
        bytes: The decompressed contents of the gzip file.
    &quot;&quot;&quot;
    with open(file_path, &#x27;rb&#x27;) as file:
        return gzip.open(file).read()
```

### Creating a Gzip File

```python
def create_gzip_file(file_path, data):
    &quot;&quot;&quot;
    Creates a new gzip file and writes its contents.
    
    Args:
        file_path (str): The path to the output gzip file.
        data (bytes): The data to be written to the gzip file.
    
    Returns:
        str: The path to the created gzip file.
    &quot;&quot;&quot;
    with open(file_path, &#x27;wb&#x27;) as file:
        return file.write(data)
```

### Example Usage

```python
# Read a gzip file
data = read_gzip_file(&#x27;example.gz&#x27;)
print(data)

# Write data to a gzip file
write_gzip_file(&#x27;example.gz&#x27;, b&#x27;Hello, World!&#x27;)

# Decompress a gzip file
decompressed_data = decompress_gzip_file(&#x27;example.gz&#x27;)
print(decompressed_data)

# Create a new gzip file
create_gzip_file(&#x27;new_example.gz&#x27;, b&#x27;New Example Data!&#x27;)
```

### Notes

* The `gzip` module uses the `zlib` library under the hood.
* The `open` function is used in binary mode (`&#x27;rb&#x27;` or `&#x27;wb&#x27;`) to ensure that the files are read and written correctly.
* The `gzip.open` function is used to open gzip files, which provides a file-like object for reading and writing.
* The `zlib.decompress` function can be used instead of `gzip.open` to decompress gzip files.
</code></pre>
<h2 id='Generic Operating System Services'>Generic Operating System Services</h2><ul><li><a href='#standard_library_documents/Generic Operating System Services/errno - Standard errno system symbols.md'>errno - Standard errno system symbols.md</a></li><li><a href='#standard_library_documents/Generic Operating System Services/curses.textpad - Text input widget for curses programs.md'>curses.textpad - Text input widget for curses programs.md</a></li><li><a href='#standard_library_documents/Generic Operating System Services/logging.config - Logging configuration.md'>logging.config - Logging configuration.md</a></li><li><a href='#standard_library_documents/Generic Operating System Services/io - Core tools for working with streams.md'>io - Core tools for working with streams.md</a></li><li><a href='#standard_library_documents/Generic Operating System Services/curses.panel - A panel stack extension for curses.md'>curses.panel - A panel stack extension for curses.md</a></li><li><a href='#standard_library_documents/Generic Operating System Services/argparse - Parser for command-line options, arguments and subcommands.md'>argparse - Parser for command-line options, arguments and subcommands.md</a></li><li><a href='#standard_library_documents/Generic Operating System Services/getpass - Portable password input.md'>getpass - Portable password input.md</a></li><li><a href='#standard_library_documents/Generic Operating System Services/logging - Logging facility for Python.md'>logging - Logging facility for Python.md</a></li><li><a href='#standard_library_documents/Generic Operating System Services/curses - Terminal handling for character-cell displays.md'>curses - Terminal handling for character-cell displays.md</a></li><li><a href='#standard_library_documents/Generic Operating System Services/platform - Access to underlying platform s identifying data.md'>platform - Access to underlying platform s identifying data.md</a></li><li><a href='#standard_library_documents/Generic Operating System Services/curses.ascii - Utilities for ASCII characters.md'>curses.ascii - Utilities for ASCII characters.md</a></li><li><a href='#standard_library_documents/Generic Operating System Services/ctypes - A foreign function library for Python.md'>ctypes - A foreign function library for Python.md</a></li><li><a href='#standard_library_documents/Generic Operating System Services/time - Time access and conversions.md'>time - Time access and conversions.md</a></li><li><a href='#standard_library_documents/Generic Operating System Services/logging.handlers - Logging handlers.md'>logging.handlers - Logging handlers.md</a></li><li><a href='#standard_library_documents/Generic Operating System Services/platform - Access to underlying platform’s identifying data.md'>platform - Access to underlying platform’s identifying data.md</a></li><li><a href='#standard_library_documents/Generic Operating System Services/os - Miscellaneous operating system interfaces.md'>os - Miscellaneous operating system interfaces.md</a></li></ul>
<h3 id='standard_library_documents/Generic Operating System Services/errno - Standard errno system symbols.md'>errno - Standard errno system symbols.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># errno — Standard errno system symbols

**Error Number Definitions**
=====================================

The `errno` module provides constants representing standard error numbers used by the Unix operating system.

```python
# Import the errno module
importerrno = errno  # Use import instead of aliasing for compatibility with Python 3.x

# Define a function to raise an OSError with a given error number
def errno_error(number, message):
    &quot;&quot;&quot;
    Raise an OSError with a given error number and message.
    
    Args:
        number (int): The error number.
        message (str): The error message.
    &quot;&quot;&quot;
    # Use the raise statement to raise an OSError
    raise OSError(f&quot;{message} ({number})&quot;)

# Example usage:
try:
    # Simulate an error with a specific error number and message
    errno_error(2, &quot;No such file or directory&quot;)
except OSError as e:
    print(f&quot;Error: {e}&quot;)
```

**Example Use Cases**
--------------------

1.  **Checking for errors**: You can use the `errno` constants to check if an operation failed with a specific error.
    ```python
import errno

# Example usage:
try:
    # Simulate an operation that may fail
    open(&quot;/nonexistent/file&quot;, &quot;r&quot;)
except OSError as e:
    print(f&quot;Error: {e}&quot;)
    # Check the error number
    if e.errno == errno.ENOENT:
        print(&quot;The file does not exist.&quot;)
```

2.  **Raising custom errors**: You can define a function to raise an `OSError` with a specific error number and message.
    ```python
def my_error(message):
    # Use the errno.error function to raise an OSError
    importerrno
    errno.error(errno.EINVAL, f&quot;Invalid argument: {message}&quot;)

# Example usage:
my_error(&quot;The input is invalid.&quot;)
```

**Constants**
--------------

*   `ENOENT`: The file does not exist.
*   `EIO`: I/O error occurred while trying to access a file descriptor.
*   `ENOTDIR`: The specified path name is not a directory.
*   `ETIMEDOUT`: A connection timed out after the timeout period.
*   `EACCES`: Permission denied for a specific operation.
*   `EBADFILE`: The specified path name is not a valid file.
*   `ECHILD`: A child process was terminated without being waited on by the parent process.
*   `ECLDFOUND`: A signal was caught but not delivered to the process.
*   `ECANCELED`: Operation canceled after completion.
*   `EDEADLK`: Deadlock detected while trying to lock a resource.
*   `EDOM`: The domain of an error number is not defined for this operation.
*   `ENAMETOOLONG`: The length of the specified path name exceeds the maximum allowed value.
*   `ENOTEMPTY`: Directory is not empty.
*   `EPERM`: Operation not permitted.
*   `EROFS`: Operation not permitted because of file system restrictions.
*   `ESRCH`: No process with the specified ID exists.

**See Also**
--------------

The `os` and `sys` modules provide functions to interact with the operating system, including error handling.
</code></pre>

<h3 id='standard_library_documents/Generic Operating System Services/curses.textpad - Text input widget for curses programs.md'>curses.textpad - Text input widget for curses programs.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># curses.textpad — Text input widget for curses programs

**Curses Textpad Module**
=========================

The `curses.textpad` module provides a widget that can be used to create a text input area in a curses program.

**Example Usage**
-----------------

```python
import curses
from curses import textpad

def main(stdscr):
    # Create a new textpad object
    tp = textpad.TextioWidget(stdscr, 10, 30)

    # Use the cursor position to scroll and edit the input
    while True:
        stdscr.clear()
        tp.draw()
        stdscr.addstr(15, 0, &quot;Enter your message:&quot;)
        stdscr.refresh()

        # Get user input
        c = stdscr.getch()
        if c == ord(&#x27;\n&#x27;):
            break
        elif c != -1:  # Check for key press
            tp.move(0, 0)
            tp.delete(0, curses.CURSOR)
            tp.addstr(c)

    # Output the final input
    print(tp.get_value())

curses.wrapper(main)
```

**API Documentation**
--------------------

### `textpad.TextioWidget(stdscr, height, width)`

Creates a new text input widget.

*   `stdscr`: The curses standard screen object.
*   `height`: The initial height of the text input area in lines.
*   `width`: The initial width of the text input area in columns.

### `tp.move(row, col)`

Moves the cursor to the specified row and column.

*   `row`: The new y-coordinate (0-`height - 1`) of the cursor.
*   `col`: The new x-coordinate (0-`width - 1`) of the cursor.

### `tp.delete(pos, len)`

Deletes text from the widget starting at the specified position.

*   `pos`: The first character to delete (0-`len - 1`).
*   `len`: The number of characters to delete.

### `tp.addstr(strng)`

Adds a string to the end of the current value in the widget.

*   `strng`: The string to add.

### `tp.get_value()`

Returns the final input value as a string.

**Explanation**
---------------

This example demonstrates how to create a text input area using the `curses.textpad` module. We first import the necessary modules and define the main function, which takes the curses standard screen object as an argument.

Inside the main function, we create a new text input widget with a height of 10 lines and a width of 30 columns. Then, we enter an infinite loop where we clear the screen, draw the current value in the textpad widget, refresh the screen, and get user input using `stdscr.getch()`. If the user presses Enter (`c == ord(&#x27;\n&#x27;)`), we break out of the loop.

After breaking out of the loop, we output the final input value by calling `tp.get_value()`.

Finally, we call `curses.wrapper(main)` to initialize and run the curses library.
</code></pre>

<h3 id='standard_library_documents/Generic Operating System Services/logging.config - Logging configuration.md'>logging.config - Logging configuration.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># logging.config — Logging configuration

**Logging Configuration Module**
=====================================

The `logging.config` module provides functions and classes for configuring logging, including loading configurations from files and setting up loggers.

**Example Code**
---------------

```python
import logging.config

# Define a simple logger configuration
logger_config = {
    &#x27;version&#x27;: 1,
    &#x27;formatters&#x27;: {
        &#x27;simple&#x27;: {&#x27;format&#x27;: &#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;},
    },
    &#x27;handlers&#x27;: {
        &#x27;console&#x27;: {
            &#x27;class&#x27;: &#x27;logging.StreamHandler&#x27;,
            &#x27;formatter&#x27;: &#x27;simple&#x27;
        }
    },
    &#x27;root&#x27;: {
        &#x27;level&#x27;: &#x27;INFO&#x27;,
        &#x27;handlers&#x27;: [&#x27;console&#x27;]
    }
}

# Load the configuration
logging.config.dictConfig(logger_config)

# Create a logger with the loaded configuration
logger = logging.getLogger(&#x27;example&#x27;)

# Set the log level
logger.setLevel(logging.INFO)

# Log some messages
logger.info(&#x27;This is an info message.&#x27;)
logger.warning(&#x27;This is a warning message.&#x27;)
logger.error(&#x27;This is an error message.&#x27;)
```

**Functions and Classes**
---------------------------

### `logging.config.dictConfig()`

*   Loads a logging configuration from a dictionary.
*   The dictionary should contain the following keys:
    *   `version`: The version of the logger configuration (required).
    *   `formatters`, `handlers`, and `root`: Dictionaries containing log formatter and handler configurations.

### `logging.config.fileConfig()`

*   Loads a logging configuration from a file.
*   Supports three formats: `.ini`, `.yaml`, and `.json`.
*   The file should contain a valid logger configuration dictionary.

### `logging.config.dictDefaults()`

*   Returns a default logger configuration dictionary.
*   This dictionary can be used as a starting point for creating custom log configurations.

### `logging.config.yamlConfig()` and `logging.config.jsonConfig()`

*   Loads a logging configuration from a YAML or JSON file, respectively.
*   Supports the same formats as `fileConfig`.

**Example Use Cases**
--------------------

*   **Configure Logging with a File**: Load a logging configuration from an `.ini` file using `dictConfig`.
```python
import logging.config

logger_config = logging.config.fileConfig(&#x27;logging.ini&#x27;)
```
*   **Create a Custom Logger**: Create a logger with the loaded configuration and set its log level.
```python
import logging.config

# Load the configuration
logging.config.dictConfig(logger_config)

# Create a logger with the loaded configuration
logger = logging.getLogger(&#x27;example&#x27;)
logger.setLevel(logging.INFO)
```
*   **Configure Logging in an App**: Configure logging at application startup using `dictConfig`.
```python
import logging.config

def main():
    # Load the configuration
    logging.config.dictConfig(logger_config)

    # Create loggers and set their levels
    logger1 = logging.getLogger(&#x27;logger1&#x27;)
    logger1.setLevel(logging.INFO)

    logger2 = logging.getLogger(&#x27;logger2&#x27;)
    logger2.setLevel(logging.WARNING)

if __name__ == &#x27;__main__&#x27;:
    main()
```
</code></pre>

<h3 id='standard_library_documents/Generic Operating System Services/io - Core tools for working with streams.md'>io - Core tools for working with streams.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># io — Core tools for working with streams

**io Module**
===============

The `io` module provides a way of using operating system features from within Python programs.

### 1. Reading and Writing Streams

#### Creating a Text Stream
```python
import io

# Create a text stream
text_stream = io.TextIOWrapper(io.StringIO(&#x27;Hello, World!&#x27;))

# Print the contents of the stream
print(text_stream.read())
```
Output: `Hello, World!`

#### Creating a Binary Stream
```python
import io

# Create a binary stream
binary_stream = io.BytesIO(b&#x27;Hello, World!&#x27;)

# Read and print the contents of the stream
print(binary_stream.getvalue())
```
Output: `b&#x27;Hello, World!&#x27;`

#### Reading from a File-like Object
```python
import io

# Create a file-like object (simulating a text file)
file_like_object = io.StringIO(&#x27;Hello, World!&#x27;)

# Read and print the contents of the file-like object
print(file_like_object.read())
```
Output: `Hello, World!`

#### Writing to a File-like Object
```python
import io

# Create a file-like object (simulating a text file)
file_like_object = io.StringIO()

# Write to the file-like object and print its contents
file_like_object.write(&#x27;Hello, World!&#x27;)
print(file_like_object.getvalue())
```
Output: `Hello, World!`

### 2. Seeking in Streams

#### Creating a Text Stream with Seekable Buffer
```python
import io

# Create a text stream with seekable buffer
text_stream = io.TextIOWrapper(io.BytesIO(b&#x27;Hello, World!&#x27;))

# Print the first 10 characters of the stream
print(text_stream.read(10))

# Move the cursor to the beginning of the stream and read again
text_stream.seek(0)
print(text_stream.read())
```
Output:
```
Helo
Hello, World!
```
### 3. Closing Streams

#### Creating a Text Stream with Seekable Buffer
```python
import io

# Create a text stream with seekable buffer
with io.TextIOWrapper(io.BytesIO(b&#x27;Hello, World!&#x27;)) as text_stream:
    # Write to the stream and print its contents
    text_stream.write(&#x27;New content!&#x27;)
    print(text_stream.read())
```
Output: `New content!Hello, World!`

### 4. Reading and Writing with Buffers

#### Creating a Text Stream with Seekable Buffer
```python
import io

# Create a binary stream with seekable buffer
binary_stream = io.BytesIO(b&#x27;Hello, World!&#x27;)

# Read from the stream using a buffer of size 10
buffered_binary_stream = io.BufferedWriter(binary_stream)
print(buffered_binary_stream.read(10))

# Write to the stream using a buffer of size 5
buffered_binary_stream.write(&#x27;New content!&#x27;[:5])
```
Output:
```
b&#x27;Hello&#x27;
New content!
```
</code></pre>

<h3 id='standard_library_documents/Generic Operating System Services/curses.panel - A panel stack extension for curses.md'>curses.panel - A panel stack extension for curses.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># curses.panel — A panel stack extension for curses

**Curses Panel Module**
======================

The `curses.panel` module provides an interface to create and manage panels, which are regions of a window that can be displayed independently.

### Creating Panels
-------------------

A panel is created using the `panel` function, which takes two arguments: the current window and the panel type. The panel type can be either `PALL`, which stands for &quot;all&quot;, or a specific attribute (e.g., `PAD`, which stands for &quot;absolute double buffering&quot;).

```python
# Import the curses module and the panel class
import curses

# Initialize the curses window
stdscr = curses.initscr()
curses.noecho()
curses.curs_set(0)  # Hide the cursor

# Create a new panel on top of the standard window
pall = curses.newwin(10, 20, 0, 0, &#x27;PALL&#x27;)

# Set the title of the panel
pall.addstr(1, 1, &quot;Panel Title&quot;)
pall.refresh()

# Wait for user input and then clean up
curses.napms(1000)
curses.endwin()
```

### Panel Stack
----------------

A panel stack is a sequence of panels that can be stacked on top of each other. Each panel in the stack can have its own title, and the stack can be manipulated using various methods.

```python
# Create another panel on top of the original one
pall2 = curses.newwin(10, 20, 0, 0, &#x27;PALL&#x27;)

# Add a new string to the second panel
pall2.addstr(1, 1, &quot;New String&quot;)

# Set the title of the second panel
pall2.set_title(&quot;Panel Title 2&quot;)

# Stack the two panels on top of each other
stack = curses.newstack()
stack.push(pall)
stack.push(pall2)

# Refresh the stacked panels
stack.refresh()

# Wait for user input and then clean up
curses.napms(1000)
curses.endwin()
```

### Panel Methods
-----------------

The `curses.panel` class provides several methods that can be used to manipulate panels. These include:

*   `set_title`: sets the title of a panel
*   `addstr`: adds a new string to a panel
*   `refresh`: refreshes the contents of a panel
*   `push`: pushes a panel onto a stack
*   `pop`: pops the top panel from a stack

```python
# Create a new panel and add some text to it
p = curses.newwin(10, 20, 0, 0)
p.addstr(1, 1, &quot;Hello World&quot;)

# Set the title of the panel
p.set_title(&quot;My Panel&quot;)
```

### Example Use Cases
----------------------

*   Creating a GUI application with multiple panels that can be displayed independently.
*   Implementing a text editor with multiple views for different parts of the document.
*   Building a graphical user interface (GUI) with separate panels for menus, buttons, and other controls.

Note: The above code examples are just a starting point, and you may need to modify them to suit your specific requirements. Additionally, this is not an exhaustive list of all methods provided by the `curses.panel` module.
</code></pre>

<h3 id='standard_library_documents/Generic Operating System Services/argparse - Parser for command-line options, arguments and subcommands.md'>argparse - Parser for command-line options, arguments and subcommands.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># argparse — Parser for command-line options, arguments and subcommands

**Argparse Module Code Generation**
=====================================

### Overview

The `argparse` module provides support for parsing command-line options and arguments in Python.

### Importing Argparse

```python
import argparse
```

### Creating an Argument Parser

To create an argument parser, you can use the `argparse.ArgumentParser()` function:

```python
# Create a new argument parser
parser = argparse.ArgumentParser(description=&#x27;My Script&#x27;)
```

### Adding Arguments

You can add arguments to your parser using the `add_argument()` method:

```python
# Add a string argument
parser.add_argument(&#x27;-n&#x27;, &#x27;--name&#x27;, help=&#x27;Your name&#x27;)

# Add an integer argument
parser.add_argument(&#x27;-a&#x27;, &#x27;--age&#x27;, type=int, help=&#x27;Your age&#x27;)
```

### Adding Subcommands

You can add subcommands to your parser using the `add_subparsers()` method:

```python
# Create a new subparser for &#x27;hello&#x27; command
subparser = parser.add_subparsers(dest=&#x27;command&#x27;)

# Add an action for &#x27;hello&#x27; command
action_hello = subparser.add_parser(&#x27;hello&#x27;)
action_hello.set_defaults(func=lambda args: print(f&quot;Hello, {args.name}!&quot;))

# Add an action for &#x27;world&#x27; command
action_world = subparser.add_parser(&#x27;world&#x27;)
action_world.set_defaults(func=lambda args: print(f&quot;How are you, {args.age}?&quot;))
```

### Parsing Arguments

To parse the arguments and execute the subcommand, you can use the `parse_args()` method:

```python
# Parse the arguments
args = parser.parse_args()

if args.command == &#x27;hello&#x27;:
    # Call the function associated with &#x27;hello&#x27; command
    args.func(args)
elif args.command == &#x27;world&#x27;:
    # Call the function associated with &#x27;world&#x27; command
    args.func(args)
else:
    # Print an error message if the subcommand is not found
    parser.print_help()
```

### Full Example

Here&#x27;s a full example that demonstrates how to use `argparse`:

```python
import argparse

def hello(args):
    &quot;&quot;&quot;Prints out a greeting message&quot;&quot;&quot;
    print(f&quot;Hello, {args.name}!&quot;)

def world(args):
    &quot;&quot;&quot;Prints out a question message&quot;&quot;&quot;
    print(f&quot;How are you, {args.age}?&quot;)

if __name__ == &#x27;__main__&#x27;:
    # Create a new argument parser
    parser = argparse.ArgumentParser(description=&#x27;My Script&#x27;)

    # Add string argument
    parser.add_argument(&#x27;-n&#x27;, &#x27;--name&#x27;, help=&#x27;Your name&#x27;)

    # Add integer argument
    parser.add_argument(&#x27;-a&#x27;, &#x27;--age&#x27;, type=int, help=&#x27;Your age&#x27;)

    # Create subparser for &#x27;hello&#x27; command
    subparser = parser.add_subparsers(dest=&#x27;command&#x27;)

    # Add action for &#x27;hello&#x27; command
    action_hello = subparser.add_parser(&#x27;hello&#x27;)
    action_hello.set_defaults(func=hello)

    # Add action for &#x27;world&#x27; command
    action_world = subparser.add_parser(&#x27;world&#x27;)
    action_world.set_defaults(func=world)

    # Parse the arguments
    args = parser.parse_args()

    if args.command == &#x27;hello&#x27;:
        # Call the function associated with &#x27;hello&#x27; command
        args.func(args)
    elif args.command == &#x27;world&#x27;:
        # Call the function associated with &#x27;world&#x27; command
        args.func(args)
    else:
        # Print an error message if the subcommand is not found
        parser.print_help()
```

### Running the Script

To run the script, save it to a file named `script.py` and execute it using Python:

```bash
python script.py -n John -a 30
```

This will print out a greeting message: &quot;Hello, John!&quot;.
</code></pre>

<h3 id='standard_library_documents/Generic Operating System Services/getpass - Portable password input.md'>getpass - Portable password input.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># getpass — Portable password input

**getpass Module**
=================

The `getpass` module provides a way to get sensitive information like passwords from the user without echoing it on the terminal.

### Functions

#### `getpass([prompt])`

*   **Description:** Prompts the user to enter a password.
*   **Parameters:**

    *   `prompt`: Optional. A string that appears above the input prompt.
*   **Returns:** The password entered by the user as a string.

```python
import getpass

def main():
    # Get the password from the user without echoing it on the terminal
    password = getpass.getpass(&quot;Enter your password: &quot;)
    
    # Print the entered password
    print(&quot;You entered:&quot;, password)

if __name__ == &quot;__main__&quot;:
    main()
```

#### `getpass(getprompt=None)`

*   **Description:** Prompts the user to enter a password and returns the result.
*   **Parameters:**

    *   `getprompt`: Optional. A function that generates a prompt string. If None, uses a default prompt.

```python
import getpass

def custom_prompt():
    &quot;&quot;&quot;Generate a custom prompt&quot;&quot;&quot;
    return &quot;Enter your password: &quot;

def main():
    # Get the password from the user using a custom prompt
    password = getpass.getpass(custom_prompt)
    
    # Print the entered password
    print(&quot;You entered:&quot;, password)

if __name__ == &quot;__main__&quot;:
    main()
```

#### `getuser()`

*   **Description:** Returns the username of the current user.
*   **Returns:** The username as a string.

```python
import getpass

def main():
    # Get the username of the current user
    username = getpass.getuser()
    
    # Print the entered username
    print(&quot;Your username is:&quot;, username)

if __name__ == &quot;__main__&quot;:
    main()
```

### Example Use Cases:

*   Getting a password from a user without echoing it on the terminal.
*   Generating a custom prompt for password input.
*   Getting the username of the current user.

### API Documentation

```python
getpass([prompt=None])

    Prompt the user to enter a password and return the result.

    Args:
        prompt (str, optional): A string that appears above the input prompt. Defaults to None.

    Returns:
        str: The password entered by the user.
```

```python
getuser()

    Return the username of the current user.

Returns:
    str: The username as a string.
```
</code></pre>

<h3 id='standard_library_documents/Generic Operating System Services/logging - Logging facility for Python.md'>logging - Logging facility for Python.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># logging — Logging facility for Python

**Logging Facility**
=====================

The `logging` module provides a flexible logging mechanism that allows you to log events at different levels of severity.

**Installation**
---------------

To use the `logging` module, import it in your Python script and enable logging:
```python
import logging
```
You can also set the logging level using the following constants:

*   `logging.DEBUG`: Debug messages (usually turned off)
*   `logging.INFO`: Informational messages
*   `logging.WARNING`: Warning messages
*   `logging.ERROR`: Error messages
*   `logging.CRITICAL`: Critical error messages

**Basic Usage**
-----------------

### Enable Logging

To enable logging, create a logger object:
```python
logger = logging.getLogger(__name__)
```
`__name__` is the name of the current module.

### Set the Logging Level

Set the logging level for the logger:
```python
logging.basicConfig(level=logging.INFO)
```
This will set the logging level to `INFO`, which means that only messages with a severity of `INFO` or higher will be logged.

### Log Messages

Use the `logger` object to log messages at different levels:
```python
import time

def main():
    logger.debug(&quot;Debug message&quot;)
    logger.info(&quot;Informational message&quot;)
    logger.warning(&quot;Warning message&quot;)
    logger.error(&quot;Error message&quot;)
    logger.critical(&quot;Critical error message&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```
This will log the messages to the console.

### Formatting Log Messages

You can customize the format of log messages using the `basicConfig` method:
```python
logging.basicConfig(
    format=&quot;%(asctime)s - %(levelname)s - %(message)s&quot;,
    level=logging.INFO,
)
```
This will add a timestamp, logging level, and message to each logged message.

### Logging to a File

To log messages to a file instead of the console, you can use the `FileHandler` class:
```python
import logging

logger = logging.getLogger(__name__)

# Create a file handler
file_handler = logging.FileHandler(&quot;log_file.log&quot;)

# Set the logging level for the file handler
file_handler.setLevel(logging.INFO)

# Create a formatter and attach it to the file handler
formatter = logging.Formatter(&quot;%(asctime)s - %(levelname)s - %(message)s&quot;)
file_handler.setFormatter(formatter)

# Add the file handler to the logger
logger.addHandler(file_handler)
```
This will log messages to `log_file.log` instead of the console.

**Advanced Topics**
--------------------

### Log Levels

The following are the predefined log levels:

*   `logging.DEBUG`: Debug messages
*   `logging.INFO`: Informational messages
*   `logging.WARNING`: Warning messages
*   `logging.ERROR`: Error messages
*   `logging.CRITICAL`: Critical error messages

You can use these constants to set the logging level.

### Log Messages in Different Formats

You can customize the format of log messages using a `Formatter` object. The formatter can be created with different attributes, such as:

*   `%s`: Timestamp
*   `%d`: Date and time in UTC
*   `%r`: Message (default formatting)
*   `%p`: Process ID
*   `%h`: Hostname
*   `%e`: Exception type and value

You can use these attributes to format log messages.

### Logging Multiple Loggers

You can create multiple logger objects and add them to the `logging.root` logger. This allows you to control the logging behavior for each logger individually.

```python
import logging

logger1 = logging.getLogger(&quot;logger1&quot;)
logger2 = logging.getLogger(&quot;logger2&quot;)

# Set the logging level for each logger
logger1.setLevel(logging.INFO)
logger2.setLevel(logging.ERROR)

# Add a handler to each logger
handler1 = logging.StreamHandler()
handler2 = logging.FileHandler(&quot;log_file2.log&quot;)

formatter = logging.Formatter(&quot;%(asctime)s - %(levelname)s - %(message)s&quot;)
handler1.setFormatter(formatter)
handler2.setFormatter(formatter)

logger1.addHandler(handler1)
logger2.addHandler(handler2)
```
This will create two separate loggers, `logger1` and `logger2`, each with its own logging level and handler.
</code></pre>

<h3 id='standard_library_documents/Generic Operating System Services/curses - Terminal handling for character-cell displays.md'>curses - Terminal handling for character-cell displays.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># curses — Terminal handling for character-cell displays

Here&#x27;s an example of using the `curses` module in Python:

**installing curses**
```bash
pip install py-curses
```
or 
```bash
sudo apt-get install libncurses5-dev
```

**Example Code:**

```python
import curses

def main(stdscr):
    # Clear the screen and move to the top-left corner
    stdscr.clear()
    stdscr.move(0, 0)

    # Print a message to the screen
    stdscr.addstr(&quot;Welcome to the Curses tutorial!&quot;)

    # Refresh the screen to show the new text
    stdscr.refresh()

    # Wait for the user to press a key
    c = stdscr.getch()
    if c != -1:
        print(f&quot;You pressed {c}&quot;)
    else:
        print(&quot;Press &#x27;q&#x27; to quit&quot;)

# Call the main function when the program starts
if __name__ == &quot;__main__&quot;:
    curses.wrapper(main)
```

**Explanation:**

*   We import the `curses` module.
*   The `curses.wrapper` function is used to initialize and clean up after the `main` function. It takes our `main` function as an argument, which will be executed with a fresh curses screen.
*   Inside the `main` function:
    *   We clear the screen by calling `stdscr.clear()` and move the cursor to the top-left corner using `stdscr.move(0, 0)`.
    *   We print a message to the screen using `stdscr.addstr()`. The string is printed at the current cursor position.
    *   After printing the message, we refresh the screen with `stdscr.refresh()` so that the new text becomes visible.
    *   Finally, we wait for the user to press a key using `stdscr.getch()`. If the user presses a key, it&#x27;s stored in the variable `c`, and its value is printed. If the user presses &#x27;q&#x27;, the program exits.

**Example Use Cases:**

*   Creating menus or navigation systems
*   Building text-based games or adventures
*   Developing command-line interfaces (CLI)
*   Creating interactive terminal applications

**Additional Functions:**

Some additional functions you can use in `curses` include:

*   `stdscr.addstr(y, x, str)`: Add a string to the screen at position (y,x).
*   `stdscr.move(y, x)`: Move the cursor to position (y,x).
*   `stdscr.clear()`: Clear the entire screen.
*   `stdscr.refresh()`: Refresh the entire screen with the new text.
*   `stdscr.getch()`: Wait for the user to press a key and return its value.
</code></pre>

<h3 id='standard_library_documents/Generic Operating System Services/platform - Access to underlying platform s identifying data.md'>platform - Access to underlying platform s identifying data.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># platform - Access to underlying platform’s identifying data

**Platform Module**
====================

The `platform` module provides access to underlying platform’s identifying data.

**Module Contents:**

*   `sysconf_names`: Returns a dictionary mapping named configuration options to their corresponding values.
*   `sysconf_value`: Returns the value of a specific system configuration option.
*   `machine`: Returns a string representing the machine type.
*   `node`: Returns a string representing the node name.
*   `release`: Returns a string representing the release version.
*   `version`: Returns a tuple containing three values: major, minor, and patch versions.
*   `processor`: Returns a string representing the processor type.

**Code Examples:**
-------------------

### 1. Accessing System Configuration Options

```python
import platform

# Get all available configuration options
config_options = platform.sysconf_names()
print(config_options)

# Get the value of a specific configuration option
cpu_freq = platform.sysconf_value(&#x27;HZ&#x27;)
print(cpu_freq)
```

### 2. Identifying Machine Type and Node Name

```python
import platform

machine_type = platform.machine()
node_name = platform.node()

print(f&quot;Machine Type: {machine_type}&quot;)
print(f&quot;Node Name: {node_name}&quot;)
```

### 3. Obtaining Release Version and Processor Information

```python
import platform

release_version = platform.release()
processor_info = platform.processor()

print(f&quot;Release Version: {release_version}&quot;)
print(f&quot;Processor Info: {processor_info}&quot;)
```

### 4. Accessing Major, Minor, and Patch Versions

```python
import platform

major_version, minor_version, patch_version = platform.version()

print(f&quot;Major Version: {major_version}&quot;)
print(f&quot;Minor Version: {minor_version}&quot;)
print(f&quot;Patch Version: {patch_version}&quot;)
```

**API Documentation:**

### `platform.sysconf_names()`

Returns a dictionary mapping named configuration options to their corresponding values.

```python
def sysconf_names():
    # Returns a dictionary of available system configuration options
    pass
```

### `platform.sysconf_value(name)`

Returns the value of a specific system configuration option.

```python
def sysconf_value(name):
    &quot;&quot;&quot;
    Returns the value of a specific system configuration option.

    Args:
        name (str): The name of the configuration option

    Returns:
        str: The value of the configuration option
    &quot;&quot;&quot;
    pass
```

### `platform.machine()`

Returns a string representing the machine type.

```python
def machine():
    # Returns a string representing the machine type
    pass
```

### `platform.node()`

Returns a string representing the node name.

```python
def node():
    # Returns a string representing the node name
    pass
```

### `platform.release()`

Returns a string representing the release version.

```python
def release():
    # Returns a string representing the release version
    pass
```

### `platform.version()`

Returns a tuple containing three values: major, minor, and patch versions.

```python
def version():
    &quot;&quot;&quot;
    Returns a tuple of three integers representing the major, minor, and patch versions.

    Returns:
        tuple: A tuple of three integers (major_version, minor_version, patch_version)
    &quot;&quot;&quot;
    pass
```

### `platform.processor()`

Returns a string representing the processor type.

```python
def processor():
    # Returns a string representing the processor type
    pass
```
</code></pre>

<h3 id='standard_library_documents/Generic Operating System Services/curses.ascii - Utilities for ASCII characters.md'>curses.ascii - Utilities for ASCII characters.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># curses.ascii — Utilities for ASCII characters

**curses.ascii Module**
=======================

The `curses.ascii` module provides functions and classes related to the use of ASCII characters in curses.

### Importing the Module
```python
import curses.ascii as ascii
```

### Functions

#### `ascii.isalnum()`
Checks if a character is alphanumeric (either letter or number).

*   Returns: True if the character is alphanumeric, False otherwise.
*   Example:
    ```python
# Check if a character is alphanumeric
if ascii.isalnum(&#x27;a&#x27;):
    print(&quot;Character &#x27;a&#x27; is alphanumeric&quot;)
else:
    print(&quot;Character &#x27;a&#x27; is not alphanumeric&quot;)
```

#### `ascii.isalpha()`
Checks if a character is an alphabetic character.

*   Returns: True if the character is alphabetic, False otherwise.
*   Example:
    ```python
# Check if a character is alphabetic
if ascii.isalpha(&#x27;A&#x27;):
    print(&quot;Character &#x27;A&#x27; is alphabetic&quot;)
else:
    print(&quot;Character &#x27;A&#x27; is not alphabetic&quot;)
```

#### `ascii.isascii()`
Checks if a character is an ASCII character.

*   Returns: True if the character is ASCII, False otherwise.
*   Example:
    ```python
# Check if a character is ASCII
if ascii.isascii(&#x27;\u4F60&#x27;):
    print(&quot;Character &#x27;\u4F60&#x27; is ASCII&quot;)
else:
    print(&quot;Character &#x27;\u4F60&#x27; is not ASCII&quot;)
```

#### `ascii.isdigit()`
Checks if a character is a digit.

*   Returns: True if the character is a digit, False otherwise.
*   Example:
    ```python
# Check if a character is a digit
if ascii.isdigit(&#x27;5&#x27;):
    print(&quot;Character &#x27;5&#x27; is a digit&quot;)
else:
    print(&quot;Character &#x27;5&#x27; is not a digit&quot;)
```

#### `ascii.islower()`
Checks if a character is in the lowercase letter set.

*   Returns: True if the character is lowercase, False otherwise.
*   Example:
    ```python
# Check if a character is lowercase
if ascii.islower(&#x27;a&#x27;):
    print(&quot;Character &#x27;a&#x27; is lowercase&quot;)
else:
    print(&quot;Character &#x27;a&#x27; is not lowercase&quot;)
```

#### `ascii.isprintable()`
Checks if a character can be printed.

*   Returns: True if the character can be printed, False otherwise.
*   Example:
    ```python
# Check if a character can be printed
if ascii.isprintable(&#x27;\n&#x27;):
    print(&quot;Character &#x27;\n&#x27; can be printed&quot;)
else:
    print(&quot;Character &#x27;\n&#x27; cannot be printed&quot;)
```

#### `ascii.isascii()`
Checks if a character is an ASCII character.

*   Returns: True if the character is ASCII, False otherwise.
*   Example:
    ```python
# Check if a character is ASCII
if ascii.isascii(&#x27;\u4F60&#x27;):
    print(&quot;Character &#x27;\u4F60&#x27; is ASCII&quot;)
else:
    print(&quot;Character &#x27;\u4F60&#x27; is not ASCII&quot;)
```

#### `ascii.isupper()`
Checks if a character is in the uppercase letter set.

*   Returns: True if the character is uppercase, False otherwise.
*   Example:
    ```python
# Check if a character is uppercase
if ascii.isupper(&#x27;A&#x27;):
    print(&quot;Character &#x27;A&#x27; is uppercase&quot;)
else:
    print(&quot;Character &#x27;A&#x27; is not uppercase&quot;)
```

#### `ascii.isspace()`
Checks if a character is a whitespace character.

*   Returns: True if the character is whitespace, False otherwise.
*   Example:
    ```python
# Check if a character is whitespace
if ascii.isspace(&#x27; &#x27;):
    print(&quot;Character &#x27; &#x27; is whitespace&quot;)
else:
    print(&quot;Character &#x27; &#x27; is not whitespace&quot;)
```

#### `ascii.isidentifier()`
Checks if a string is an ASCII identifier.

*   Returns: True if the string is an ASCII identifier, False otherwise.
*   Example:
    ```python
# Check if a string is an ASCII identifier
if ascii.isidentifier(&#x27;abc&#x27;):
    print(&quot;String &#x27;abc&#x27; is an ASCII identifier&quot;)
else:
    print(&quot;String &#x27;abc&#x27; is not an ASCII identifier&quot;)
```

#### `ascii.isdecimal()`
Checks if a character is a decimal digit.

*   Returns: True if the character is a decimal digit, False otherwise.
*   Example:
    ```python
# Check if a character is a decimal digit
if ascii.isdecimal(&#x27;0&#x27;):
    print(&quot;Character &#x27;0&#x27; is a decimal digit&quot;)
else:
    print(&quot;Character &#x27;0&#x27; is not a decimal digit&quot;)
```

#### `ascii.islowercase()`
Checks if all characters in the string are lowercase.

*   Returns: True if all characters are lowercase, False otherwise.
*   Example:
    ```python
# Check if all characters in a string are lowercase
if ascii.islowercase(&#x27;abcdef&#x27;):
    print(&quot;All characters in &#x27;abcdef&#x27; are lowercase&quot;)
else:
    print(&quot;Not all characters in &#x27;abcdef&#x27; are lowercase&quot;)
```

#### `ascii.isuppercase()`
Checks if all characters in the string are uppercase.

*   Returns: True if all characters are uppercase, False otherwise.
*   Example:
    ```python
# Check if all characters in a string are uppercase
if ascii.isuppercase(&#x27;ABCDEF&#x27;):
    print(&quot;All characters in &#x27;ABCDEF&#x27; are uppercase&quot;)
else:
    print(&quot;Not all characters in &#x27;ABCDEF&#x27; are uppercase&quot;)
```

#### `ascii.isspace()`
Checks if all characters in the string are whitespace.

*   Returns: True if all characters are whitespace, False otherwise.
*   Example:
    ```python
# Check if all characters in a string are whitespace
if ascii.isspace(&#x27;   &#x27;):
    print(&quot;All characters in &#x27;   &#x27; are whitespace&quot;)
else:
    print(&quot;Not all characters in &#x27;   &#x27; are whitespace&quot;)
```

#### `ascii.isprintable()`
Checks if all characters in the string can be printed.

*   Returns: True if all characters can be printed, False otherwise.
*   Example:
    ```python
# Check if all characters in a string can be printed
if ascii.isprintable(&#x27;\nabc&#x27;):
    print(&quot;All characters in &#x27;\nabc&#x27; can be printed&quot;)
else:
    print(&quot;Not all characters in &#x27;\nabc&#x27; can be printed&quot;)
```

#### `ascii.digits`
Returns a string of ASCII digit characters.

*   Returns: A string containing only the ASCII digits.
*   Example:
    ```python
# Get a string of ASCII digit characters
digits = ascii.digits
print(digits)  # prints &#x27;0123456789&#x27;
```

#### `ascii.ascii_letters`
Returns a string of ASCII letter characters.

*   Returns: A string containing only the ASCII letters.
*   Example:
    ```python
# Get a string of ASCII letter characters
letters = ascii.ascii_letters
print(letters)  # prints &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;
```
</code></pre>

<h3 id='standard_library_documents/Generic Operating System Services/ctypes - A foreign function library for Python.md'>ctypes - A foreign function library for Python.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># ctypes — A foreign function library for Python

**ctypes Module Documentation**
=====================================

The `ctypes` module provides C compatible data types and allows calling functions in dynamic link libraries/shared libraries.

### Installing `ctypes`

The `ctypes` module is included with Python standard library, so no additional installation is required.

### Importing `ctypes`

```python
import ctypes
```

### Creating a C-Type Object

You can create a C-type object using the `ctypes.c_type()` function or `ctypes.c_int`, etc. functions.

```python
# Create an integer type
int_type = ctypes.c_int

# Create a float type
float_type = ctypes.c_float

# Create a pointer to an integer type
ptr_int = int_type * 10

print(ptr_int)  # Output: &lt;class &#x27;ctypes._StructType&#x27;&gt;
```

### Converting Python Objects to C-Types

You can convert Python objects to C-types using the `ctypes.cast()` function.

```python
import ctypes

# Create a c_int object
int_obj = ctypes.c_int(10)

# Convert it to an integer type
c_int_type = int_type()

print(ctypes.cast(int_obj, c_int_type))  # Output: (10, &#x27;int&#x27;)
```

### Calling Functions from Dynamic Link Libraries/Shared Libraries

To call functions from a DLL or shared library, you need to know the address of the function.

```python
import ctypes

# Load the dll file
lib = ctypes.CDLL(&#x27;./mylib.so&#x27;)

# Get the address of the add function
add_func_addr = lib.add

# Call the add function with two arguments (a and b)
result = add_func_addr(2, 3)

print(result)  # Output: 5
```

### Creating a Dynamic Link Library/Shared Library

To create a DLL or shared library using `ctypes`, you need to know the address of the function.

```python
import ctypes

# Define a function in C (not Python)
def add(a, b):
    return a + b

# Get the address of the add function
add_func_addr = ctypes.CDLL(&#x27;./mylib.so&#x27;).add

# Call the add function with two arguments (a and b)
result = add_func_addr(2, 3)

print(result)  # Output: 5
```

### Working with Structs

Structs are custom data types that can be used to represent binary data.

```python
import ctypes

# Create a struct definition
class Point(ctypes.Structure):
    _fields_ = [(&quot;x&quot;, ctypes.c_int), (&quot;y&quot;, ctypes.c_int)]

# Create an instance of the struct
point_obj = Point(1, 2)

print(point_obj.x)  # Output: 1
print(point_obj.y)  # Output: 2
```

### Working with Arrays

Arrays are a collection of elements of the same type.

```python
import ctypes

# Create an array definition
class MyArray(ctypes.Structure):
    _fields_ = [(&quot;data&quot;, (ctypes.c_int * 10, ctypes.byref(ctypes.c_uint))))

# Create an instance of the struct
array_obj = MyArray(data=[1, 2, 3, 4, 5])

print(array_obj.data[0])  # Output: 1
```

### Error Handling

When working with `ctypes`, you need to handle errors using try-except blocks.

```python
import ctypes

try:
    lib = ctypes.CDLL(&#x27;./mylib.so&#x27;)
except OSError as e:
    print(f&quot;Failed to load library: {e}&quot;)

try:
    result = lib.add(2, 3)
except AttributeError as e:
    print(f&quot;Error in add function call: {e}&quot;)
```
</code></pre>

<h3 id='standard_library_documents/Generic Operating System Services/time - Time access and conversions.md'>time - Time access and conversions.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># time — Time access and conversions

**Time Module Code Generation**
=====================================

The `time` module provides various time-related functions.

### 1. Time Functions

```python
import time

# Get current time in seconds since the epoch (January 1, 1970)
current_time = time.time()
print(f&quot;Current time: {current_time}&quot;)

# Get current time as a float in fractional seconds
current_time_float = time.time()
print(f&quot;Current time (float): {current_time_float}&quot;)

# Get the number of microseconds since the epoch
microseconds = int(time.time() * 1e6)
print(f&quot;Microseconds: {microseconds}&quot;)

# Sleep for 5 seconds
time.sleep(5)

# Get the current date and time
now = time.localtime()
print(&quot;Current Date and Time:&quot;)
print(f&quot;Year: {now.tm_year}&quot;)
print(f&quot;Month: {now.tm_mon}&quot;)
print(f&quot;Day: {now.tm_mday}&quot;)
print(f&quot;Hour: {now.tm_hour}&quot;)
print(f&quot;Minute: {now.tm_min}&quot;)
print(f&quot;Second: {now.tm_sec}&quot;)

# Convert time to UTC
utc_now = time.gmtime()
print(&quot;UTC Current Date and Time:&quot;)
print(f&quot;Year: {utc_now.tm_year}&quot;)
print(f&quot;Month: {utc_now.tm_mon}&quot;)
print(f&quot;Day: {utc_now.tm_mday}&quot;)
print(f&quot;Hour: {utc_now.tm_hour}&quot;)
print(f&quot;Minute: {utc_now.tm_min}&quot;)
print(f&quot;Second: {utc_now.tm_sec}&quot;)

# Convert time to local
local_now = time.localtime()
print(&quot;Local Current Date and Time:&quot;)
print(f&quot;Year: {local_now.tm_year}&quot;)
print(f&quot;Month: {local_now.tm_mon}&quot;)
print(f&quot;Day: {local_now.tm_mday}&quot;)
print(f&quot;Hour: {local_now.tm_hour}&quot;)
print(f&quot;Minute: {local_now.tm_min}&quot;)
print(f&quot;Second: {local_now.tm_sec}&quot;)

# Get the time zone offset in seconds
offset = time.tzname()
print(&quot;Time Zone Offset:&quot;)
print(offset)

# Convert time to string format (HH:MM)
time_str = time.strftime(&quot;%H:%M&quot;)
print(f&quot;Time String: {time_str}&quot;)
```

### 2. Timezone Functions

```python
import time
import pytz

# Set the timezone to UTC
utc_now = time.tzlocal()
utc_tz = pytz.UTC
utc_now_tz = utc_tz.localize(time.time())
print(&quot;UTC Current Date and Time:&quot;)
print(f&quot;Year: {utc_now_tz.tm_year}&quot;)
print(f&quot;Month: {utc_now_tz.tm_mon}&quot;)
print(f&quot;Day: {utc_now_tz.tm_mday}&quot;)
print(f&quot;Hour: {utc_now_tz.tm_hour}&quot;)
print(f&quot;Minute: {utc_now_tz.tm_min}&quot;)
print(f&quot;Second: {utc_now_tz.tm_sec}&quot;)

# Set the timezone to local
local_tz = pytz.timezone(&quot;US/Pacific&quot;)
local_time = time.localtime()
local_time_tz = local_tz.localize(local_time)
print(&quot;Local Current Date and Time:&quot;)
print(f&quot;Year: {local_time_tz.tm_year}&quot;)
print(f&quot;Month: {local_time_tz.tm_mon}&quot;)
print(f&quot;Day: {local_time_tz.tm_mday}&quot;)
print(f&quot;Hour: {local_time_tz.tm_hour}&quot;)
print(f&quot;Minute: {local_time_tz.tm_min}&quot;)
print(f&quot;Second: {local_time_tz.tm_sec}&quot;)

# Get the timezone offset in seconds
offset = local_time_tz.utcoffset(time.time()).total_seconds()
print(&quot;Time Zone Offset:&quot;)
print(offset)
```

### 3. Date and Time Functions

```python
import time
from datetime import datetime

# Create a date and time object from the current time
now = datetime.now()
print(f&quot;Current Date and Time: {now}&quot;)

# Get the year, month, day, hour, minute, second values from the current date and time
year = now.year
month = now.month
day = now.day
hour = now.hour
minute = now.minute
second = now.second
print(f&quot;Year: {year}&quot;)
print(f&quot;Month: {month}&quot;)
print(f&quot;Day: {day}&quot;)
print(f&quot;Hour: {hour}&quot;)
print(f&quot;Minute: {minute}&quot;)
print(f&quot;Second: {second}&quot;)

# Create a date and time object from the string format (YYYY-MM-DD HH:MM:SS)
date_time_str = &quot;2022-01-01 12:30:00&quot;
date_time_obj = datetime.strptime(date_time_str, &quot;%Y-%m-%d %H:%M:%S&quot;)
print(f&quot;Date and Time Object: {date_time_obj}&quot;)
```

### 4. Calendar Functions

```python
import time
from calendar import monthrange

# Get the number of days in a month
month = 12
days_in_month = monthrange(2022, month)[1]
print(f&quot;Days in {month} 2022: {days_in_month}&quot;)

# Get the weekday (0-6) and day (1-31) for a specific date
year = 2022
month = 1
day = 1
weekday = time.strptime(f&quot;{year}-{month}-{day}&quot;, &quot;%Y-%m-%d&quot;).tm_wday
print(f&quot;Weekday: {weekday}&quot;)
day = monthrange(year, month)[1]
print(f&quot;Day: {day}&quot;)

# Get the day of the week (Monday=0, Sunday=6) for a specific date
year = 2022
month = 1
day = 1
week_day = time.strptime(f&quot;{year}-{month}-{day}&quot;, &quot;%Y-%m-%d&quot;).tm_wday
print(f&quot;Day of Week: {week_day}&quot;)
```
</code></pre>

<h3 id='standard_library_documents/Generic Operating System Services/logging.handlers - Logging handlers.md'>logging.handlers - Logging handlers.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># logging.handlers — Logging handlers

Here&#x27;s an example of all possible code snippets using the `logging.handlers` module.

```python
# Importing necessary modules from the logging.handlers module
import logging
from logging.handlers import TimedRotatingFileHandler, MemoryHandler, RotatingFileHandler, QueueHandler, SocketHandler, SysLogHandler, WindowHandler

# 1. Creating a timed rotating file handler
def create_timed_rotating_file_handler(filename, when=&#x27;midnight&#x27;, interval=1, backupCount=0):
    &quot;&quot;&quot;
    Creates a timed rotating file handler.

    Args:
        filename (str): The name of the log file.
        when (&#x27;midnight&#x27;): When to rotate logs. Options include &#x27;midnight&#x27; or any time interval.
        interval (int): Number of days for rotation. 0 means no interval.
        backupCount (int): The number of backups to keep.

    Returns:
        logging.handlers.TimedRotatingFileHandler: A timed rotating file handler.
    &quot;&quot;&quot;
    return TimedRotatingFileHandler(filename, when=when, interval=interval, backupCount=backupCount)

# 2. Creating a memory handler
def create_memory_handler(buffer_size=-1):
    &quot;&quot;&quot;
    Creates a memory handler.

    Args:
        buffer_size (int): The size of the buffer in kilobytes.

    Returns:
        logging.handlers.MemoryHandler: A memory handler.
    &quot;&quot;&quot;
    return MemoryHandler(buffer_size=buffer_size)

# 3. Creating a rotating file handler
def create_rotating_file_handler(filename, when=&#x27;midnight&#x27;, interval=1, backupCount=0):
    &quot;&quot;&quot;
    Creates a rotating file handler.

    Args:
        filename (str): The name of the log file.
        when (&#x27;midnight&#x27;): When to rotate logs. Options include &#x27;midnight&#x27; or any time interval.
        interval (int): Number of days for rotation. 0 means no interval.
        backupCount (int): The number of backups to keep.

    Returns:
        logging.handlers.RotatingFileHandler: A rotating file handler.
    &quot;&quot;&quot;
    return RotatingFileHandler(filename, when=when, interval=interval, backupCount=backupCount)

# 4. Creating a queue handler
def create_queue_handler(queue_name):
    &quot;&quot;&quot;
    Creates a queue handler.

    Args:
        queue_name (str): The name of the queue.

    Returns:
        logging.handlers.QueueHandler: A queue handler.
    &quot;&quot;&quot;
    return QueueHandler(queue_name)

# 5. Creating a socket handler
def create_socket_handler(host, port=0):
    &quot;&quot;&quot;
    Creates a socket handler.

    Args:
        host (str): The hostname or IP address to bind to.
        port (int): The port number to bind to.

    Returns:
        logging.handlers.SocketHandler: A socket handler.
    &quot;&quot;&quot;
    return SocketHandler((host, port))

# 6. Creating a syslog handler
def create_syslog_handler(address, level=logging.INFO):
    &quot;&quot;&quot;
    Creates a syslog handler.

    Args:
        address (str): The address to bind to for syslog handlers.
        level (int): The logging level.

    Returns:
        logging.handlers.SysLogHandler: A syslog handler.
    &quot;&quot;&quot;
    return SysLogHandler(address=address, level=level)

# 7. Creating a window handler
def create_window_handler(mode=logging.DEBUG):
    &quot;&quot;&quot;
    Creates a window handler.

    Args:
        mode (int): The logging level.

    Returns:
        logging.handlers.WindowHandler: A window handler.
    &quot;&quot;&quot;
    return WindowHandler(mode=mode)

# Example usage of handlers

if __name__ == &quot;__main__&quot;:
    # Create a logger
    logger = logging.getLogger()

    # Set the logging level to debug
    logger.setLevel(logging.DEBUG)

    # Create and add the handlers to the logger
    timed_rotating_file_handler = create_timed_rotating_file_handler(&#x27;app.log&#x27;, when=&#x27;midnight&#x27;, interval=1, backupCount=30)
    logger.addHandler(timed_rotating_file_handler)

    memory_handler = create_memory_handler(buffer_size=-1)
    logger.addHandler(memory_handler)

    rotating_file_handler = create_rotating_file_handler(&#x27;rotated_app.log&#x27;, when=&#x27;midnight&#x27;, interval=2, backupCount=5)
    logger.addHandler(rotating_file_handler)

    queue_handler = create_queue_handler(&#x27;/tmp/myqueue&#x27;)
    logger.addHandler(queue_handler)

    socket_handler = create_socket_handler(&#x27;localhost:12345&#x27;)
    logger.addHandler(socket_handler)

    syslog_handler = create_syslog_handler(address=&#x27;/dev/log&#x27;, level=logging.INFO)
    logger.addHandler(syslog_handler)

    window_handler = create_window_handler(mode=logging.DEBUG)
    logger.addHandler(window_handler)
```

This example creates various handlers from the `logging.handlers` module and demonstrates how to use them with a logger.
</code></pre>

<h3 id='standard_library_documents/Generic Operating System Services/platform - Access to underlying platform’s identifying data.md'>platform - Access to underlying platform’s identifying data.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># platform — Access to underlying platform’s identifying data

**Platform Module**
=================
```python
import platform

# Get the system&#x27;s platform (e.g., Linux, Windows, Darwin)
print(platform.system())

# Get the system&#x27;s release version (e.g., Python 3.9.0)
print(platform.release())

# Get the system&#x27;s version (e.g., 3.9.0)
print(platform.version())

# Get a string representing the machine type (e.g., x86_64, i386)
print(platform.machine())

# Get a string representing the processor type (e.g., x86_64, i686)
print(platform.processor())

# Get a dictionary containing information about the system
info = platform.unix_system()
print(info)

# Get a list of all available platforms
print(platform.platforms())
```
This will output something like:
```
Linux
3.9.0
3.9.0
x86_64
amd64
{&#x27;system&#x27;: &#x27;Linux&#x27;, &#x27;release&#x27;: &#x27;3.9.0&#x27;, &#x27;version&#x27;: &#x27;#1~40~0.9.2-Ubuntu 20.04 LTS&#x27;, &#x27;machine&#x27;: &#x27;x86_64&#x27;, &#x27;processor&#x27;: &#x27;amd64&#x27;}
[&#x27;linux&#x27;, &#x27;darwin&#x27;, &#x27;win32&#x27;]
```
Note that the output of `platform.unix_system()` and `platform.platforms()` may vary depending on the system.

**Example Use Cases:**

* Checking if the system is a 64-bit platform
```python
if platform.machine() == &#x27;x86_64&#x27;:
    print(&quot;This is a 64-bit system&quot;)
```
* Verifying the Python version
```python
import platform
print(f&quot;Python {platform.version()} is running&quot;)
```
* Checking if the system is running on Linux or macOS
```python
if platform.system() in [&#x27;Linux&#x27;, &#x27;Darwin&#x27;]:
    print(&quot;This system is a Unix-like system&quot;)
```
</code></pre>

<h3 id='standard_library_documents/Generic Operating System Services/os - Miscellaneous operating system interfaces.md'>os - Miscellaneous operating system interfaces.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># os — Miscellaneous operating system interfaces

**os Module Examples**
=====================

The `os` module provides a way of using operating system dependent functionality.

### 1. Checking if a file exists
```python
import os

# Check if a file exists
def check_file_exists(file_path):
    &quot;&quot;&quot;
    Checks if a file exists at the specified path.
    
    Args:
        file_path (str): The path to the file to check.
    
    Returns:
        bool: True if the file exists, False otherwise.
    &quot;&quot;&quot;
    return os.path.exists(file_path)

# Example usage
file_path = &quot;/path/to/your/file.txt&quot;
if check_file_exists(file_path):
    print(f&quot;The file {file_path} exists.&quot;)
else:
    print(f&quot;The file {file_path} does not exist.&quot;)
```

### 2. Getting the current working directory
```python
import os

# Get the current working directory
def get_current_directory():
    &quot;&quot;&quot;
    Gets the path of the current working directory.
    
    Returns:
        str: The path of the current working directory.
    &quot;&quot;&quot;
    return os.getcwd()

# Example usage
print(get_current_directory())
```

### 3. Changing the current working directory
```python
import os

# Change the current working directory
def change_directory(directory_path):
    &quot;&quot;&quot;
    Changes the current working directory to the specified path.
    
    Args:
        directory_path (str): The path of the new working directory.
    &quot;&quot;&quot;
    os.chdir(directory_path)

# Example usage
new_dir = &quot;/path/to/new/directory&quot;
change_directory(new_dir)
print(os.getcwd())  # prints the new directory
```

### 4. Listing files and directories in a given directory
```python
import os

# List files and directories in a given directory
def list_files_and_directories(directory_path):
    &quot;&quot;&quot;
    Lists all files and directories in the specified path.
    
    Args:
        directory_path (str): The path of the directory to list.
    
    Returns:
        list: A list of files and directories in the specified path.
    &quot;&quot;&quot;
    return os.listdir(directory_path)

# Example usage
dir_path = &quot;/path/to/your/directory&quot;
files_and_dirs = list_files_and_directories(dir_path)
print(files_and_dirs)  # prints a list of files and directories
```

### 5. Creating a new directory
```python
import os

# Create a new directory
def create_directory(directory_name):
    &quot;&quot;&quot;
    Creates a new directory with the specified name.
    
    Args:
        directory_name (str): The name of the new directory.
    
    Returns:
        bool: True if the directory was created, False otherwise.
    &quot;&quot;&quot;
    try:
        os.mkdir(directory_name)
        return True
    except FileExistsError:
        print(f&quot;The directory {directory_name} already exists.&quot;)
        return False

# Example usage
dir_name = &quot;new_directory&quot;
if create_directory(dir_name):
    print(f&quot;Directory {dir_name} created successfully.&quot;)
else:
    print(f&quot;Failed to create directory {dir_name}.&quot;)
```

### 6. Deleting a file or directory
```python
import os

# Delete a file or directory
def delete_file_or_directory(file_or_dir_path):
    &quot;&quot;&quot;
    Deletes the specified file or directory.
    
    Args:
        file_or_dir_path (str): The path of the file or directory to delete.
    
    Returns:
        bool: True if the file or directory was deleted, False otherwise.
    &quot;&quot;&quot;
    try:
        os.remove(file_or_dir_path)
        return True
    except FileNotFoundError:
        print(f&quot;The file {file_or_dir_path} does not exist.&quot;)
        return False

# Example usage
file_path = &quot;/path/to/your/file.txt&quot;
if delete_file_or_directory(file_path):
    print(f&quot;File {file_path} deleted successfully.&quot;)
else:
    print(f&quot;Failed to delete file {file_path}.&quot;)
```

### 7. Getting the absolute path of a given path
```python
import os

# Get the absolute path of a given path
def get_absolute_path(path):
    &quot;&quot;&quot;
    Gets the absolute path of the specified path.
    
    Args:
        path (str): The path to get the absolute path for.
    
    Returns:
        str: The absolute path of the specified path.
    &quot;&quot;&quot;
    return os.path.abspath(path)

# Example usage
file_path = &quot;/path/to/your/file.txt&quot;
absolute_path = get_absolute_path(file_path)
print(absolute_path)  # prints the absolute path
```

### 8. Getting the relative path of a given path
```python
import os

# Get the relative path of a given path
def get_relative_path(path, base_dir):
    &quot;&quot;&quot;
    Gets the relative path of the specified path from the given base directory.
    
    Args:
        path (str): The path to get the relative path for.
        base_dir (str): The base directory to compare with.
    
    Returns:
        str: The relative path of the specified path from the given base directory.
    &quot;&quot;&quot;
    return os.path.relpath(path, base_dir)

# Example usage
base_dir = &quot;/path/to/base/directory&quot;
file_path = &quot;/path/to/your/file.txt&quot;
relative_path = get_relative_path(file_path, base_dir)
print(relative_path)  # prints the relative path
```

### 9. Getting the directory name of a given path
```python
import os

# Get the directory name of a given path
def get_directory_name(path):
    &quot;&quot;&quot;
    Gets the directory name of the specified path.
    
    Args:
        path (str): The path to get the directory name for.
    
    Returns:
        str: The directory name of the specified path.
    &quot;&quot;&quot;
    return os.path.dirname(path)

# Example usage
file_path = &quot;/path/to/your/file.txt&quot;
dir_name = get_directory_name(file_path)
print(dir_name)  # prints the directory name
```

### 10. Getting the file name of a given path
```python
import os

# Get the file name of a given path
def get_file_name(path):
    &quot;&quot;&quot;
    Gets the file name of the specified path.
    
    Args:
        path (str): The path to get the file name for.
    
    Returns:
        str: The file name of the specified path.
    &quot;&quot;&quot;
    return os.path.basename(path)

# Example usage
file_path = &quot;/path/to/your/file.txt&quot;
file_name = get_file_name(file_path)
print(file_name)  # prints the file name
```
</code></pre>
<h2 id='File and Directory Access'>File and Directory Access</h2><ul><li><a href='#standard_library_documents/File and Directory Access/stat - Interpreting stat() results.md'>stat - Interpreting stat() results.md</a></li><li><a href='#standard_library_documents/File and Directory Access/linecache - Random access to text lines.md'>linecache - Random access to text lines.md</a></li><li><a href='#standard_library_documents/File and Directory Access/pathlib - Object-oriented filesystem paths.md'>pathlib - Object-oriented filesystem paths.md</a></li><li><a href='#standard_library_documents/File and Directory Access/shutil - High-level file operations.md'>shutil - High-level file operations.md</a></li><li><a href='#standard_library_documents/File and Directory Access/filecmp - File and Directory Comparisons.md'>filecmp - File and Directory Comparisons.md</a></li><li><a href='#standard_library_documents/File and Directory Access/os.path - Common pathname manipulations.md'>os.path - Common pathname manipulations.md</a></li><li><a href='#standard_library_documents/File and Directory Access/glob - Unix style pathname pattern expansion.md'>glob - Unix style pathname pattern expansion.md</a></li><li><a href='#standard_library_documents/File and Directory Access/tempfile - Generate temporary files and directories.md'>tempfile - Generate temporary files and directories.md</a></li><li><a href='#standard_library_documents/File and Directory Access/fnmatch - Unix filename pattern matching.md'>fnmatch - Unix filename pattern matching.md</a></li><li><a href='#standard_library_documents/File and Directory Access/fileinput - Iterate over lines from multiple input streams.md'>fileinput - Iterate over lines from multiple input streams.md</a></li></ul>
<h3 id='standard_library_documents/File and Directory Access/stat - Interpreting stat() results.md'>stat - Interpreting stat() results.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># stat — Interpreting stat() results

**Stat Module Example**
=====================================

The `stat` module provides functions to retrieve information about files and other special files.

### Code Generation

```python
import stat

# Define variables for file status
mode = 0o755  # File type: regular file, owned by user, group, and others have read, write, and execute permissions
st_dev = 10   # Device number (file is on the first disk)
inode = 12345  # Inode number (file&#x27;s internal identifier)

# Get file status as a struct stat_result
stat_result = stat.stat(mode, st_dev, inode)

# Print file status information
print(f&quot;Mode: {stat_result.st_mode}&quot;)
print(f&quot;Inode Number: {stat_result.st_ino}&quot;)
print(f&quot;Device Number: {stat_result.st_dev}&quot;)
print(f&quot;Number of Hard Links: {stat_result.st_nlink}&quot;)
print(f&quot;File Type: {stat_result.st_mode &amp; 0x01} (D) - Directory, 0x02 (L) - Symbolic link&quot;)
```

### Explanation

*   We start by importing the `stat` module.
*   Define variables to simulate a file&#x27;s status: mode (`mode`), device number (`st_dev`), and inode number (`inode`).
*   Use the `stat.stat()` function to retrieve the file status information, passing in the simulated values for each field.
*   Print out the retrieved file status information.

### Functions

#### stat()

Retrieves information about files and other special files. The result is a struct stat_result containing the following fields:

| Field  | Description              |
|--------|--------------------------|
| st_mode | File type, permissions    |
| st_ino | Inode number (file&#x27;s ID) |
| st_dev | Device number (file is on) |
| st_nlink | Number of hard links      |

**Example Usage**

```python
import stat

# Example usage: Create a new directory and retrieve its status
new_dir_mode = 0o777
stat_result = stat.stat(new_dir_mode, 0, 12345)

print(f&quot;New Directory Status:&quot;)
print(stat_result.st_mode)
```

### File Operations

The `stat` module provides functions for performing file operations. These functions are:

*   `fchmod()`: Changes the mode of an existing file.
*   `fchown()`: Changes the owner and group of a file.

**Example Usage**

```python
import stat

# Example usage: Change the permissions of a file
file_mode = 0o666
stat_result = stat.fchmod(12345, file_mode)

print(f&quot;File Status After Permission Change:&quot;)
print(stat.stat(file_mode, 0, 12345))
```

### Notes

*   This example demonstrates how to retrieve information about files using the `stat` module and perform basic file operations.
*   The `mode`, `st_dev`, and `inode` variables in this example are simulated to demonstrate the usage of the `stat.stat()` function.
</code></pre>

<h3 id='standard_library_documents/File and Directory Access/linecache - Random access to text lines.md'>linecache - Random access to text lines.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># linecache — Random access to text lines

**LineCache Module**
=====================

The `linecache` module provides an interface to access text files line by line, allowing for random access and efficient memory usage.

**Installation**
---------------

You can install the `linecache` module using pip:
```bash
pip install linecache
```
**Code Examples**
-----------------

### 1. Reading a Text File Line by Line

```python
import linecache

# Read the first 10 lines from the file &#x27;example.txt&#x27;
lines = linecache.getlines(&#x27;example.txt&#x27;, count=10)

for line in lines:
    print(line)
```

### 2. Accessing a Specific Line by Number

```python
import linecache

# Get the 5th line from the file &#x27;example.txt&#x27;
line = linecache.getline(&#x27;example.txt&#x27;, 5)

print(line)
```

### 3. Checking if a File Exists and Returns an Empty List on Failure

```python
import linecache

try:
    lines = linecache.getlines(&#x27;non_existent_file.txt&#x27;)
except FileNotFoundError:
    print(&quot;File does not exist&quot;)
else:
    # File exists, process the contents
    for line in lines:
        print(line)
```

### 4. Reading a Text File and Returning Only Unique Lines

```python
import linecache

def get_unique_lines(file_name):
    unique_lines = set()
    with open(file_name, &#x27;r&#x27;) as f:
        for line in f:
            if line.strip() not in unique_lines:
                unique_lines.add(line.strip())
    return list(unique_lines)

unique_lines = get_unique_lines(&#x27;example.txt&#x27;)
for line in unique_lines:
    print(line)
```

### 5. Reading a Text File and Returning Only Lines Containing a Specific Word

```python
import linecache

def get_lines_with_word(file_name, word):
    matching_lines = []
    with open(file_name, &#x27;r&#x27;) as f:
        for line in f:
            if word.lower() in line.lower():
                matching_lines.append(line.strip())
    return matching_lines

matching_lines = get_lines_with_word(&#x27;example.txt&#x27;, &#x27;hello&#x27;)
for line in matching_lines:
    print(line)
```

### 6. Using `getlines` with a Custom Line Separator

```python
import linecache

# Specify a custom line separator (e.g., newline followed by tab)
custom_separator = &quot;\n\t&quot;

lines = linecache.getlines(&#x27;example.txt&#x27;, sep=custom_separator)

for i, line in enumerate(lines):
    print(f&quot;Line {i+1}: {line}&quot;)
```

Note: The `getlines` function returns an iterator yielding lines from the file. If you need to use a different separator or have more complex requirements, consider using `open` and `split` methods instead.

**Error Handling**
-----------------

When working with files that may not exist or have issues reading them, it&#x27;s essential to handle potential errors. The `linecache` module provides no explicit error handling; you must implement it yourself based on your specific needs and requirements.
</code></pre>

<h3 id='standard_library_documents/File and Directory Access/pathlib - Object-oriented filesystem paths.md'>pathlib - Object-oriented filesystem paths.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># pathlib — Object-oriented filesystem paths

**Pathlib Module**
================

The `pathlib` module provides an object-oriented interface to the filesystem.

### Installation

You don&#x27;t need to install any additional packages to use the `pathlib` module. It is part of the Python Standard Library.

### Basic Usage

```python
import pathlib

# Create a new Path object from a string
path = pathlib.Path(&quot;example.txt&quot;)

print(path)  # Output: Path(&#x27;example.txt&#x27;)

# Get the file name and extension
print(path.name)  # Output: example.txt
print(path.suffix)  # Output: .txt

# Get the parent directory
print(path.parent)  # Output: Path(&#x27;/&#x27;)

# Check if a file or directory exists
path.exists()  # Returns True if the path exists, False otherwise
```

### Creating Paths from Raw Strings

```python
import pathlib

path = pathlib.Path(&quot;/home/user/example.txt&quot;)

print(path)  # Output: Path(&#x27;/home/user/example.txt&#x27;)
```

### Working with Directories

```python
import pathlib

# Create a new Path object for the current working directory
cwd = pathlib.Path.cwd()

print(cwd)  # Output: Path(&#x27;...&#x27;)

# Create a new directory
new_dir = cwd.joinpath(&quot;my_new_directory&quot;)
new_dir.mkdir()

print(new_dir)  # Output: Path(&#x27;/.../my_new_directory&#x27;)
```

### Resolving Paths

```python
import pathlib

path = pathlib.Path(&quot;/home/user/example.txt&quot;)

resolved_path = path.resolve()
resolved_path  # Output: Path(&#x27;/home/user/example.txt&#x27;)

# Join two paths together
join_path = cwd.joinpath(&quot;subdir&quot;).joinpath(&quot;example.txt&quot;)
print(join_path)  # Output: Path(&#x27;/.../subdir/example.txt&#x27;)
```

### File Operations

```python
import pathlib

# Create a new Path object for the file
file_path = pathlib.Path(&quot;example.txt&quot;)

# Get the file size in bytes
print(file_path.stat().st_size)  # Output: int

# Read the contents of the file
with open(file_path, &quot;r&quot;) as f:
    print(f.read())  # Output: str

# Write to the file
with open(file_path, &quot;w&quot;) as f:
    f.write(&quot;New contents&quot;)

# Delete the file
file_path.unlink()
```

### Directory Operations

```python
import pathlib

# Create a new directory
new_dir = pathlib.Path(&quot;/home/user/my_new_directory&quot;)
new_dir.mkdir()

# Get the list of files and directories in the directory
print(list(new_dir.iterdir()))  # Output: [Path(&#x27;...&#x27;)]

# Delete the directory and all its contents
new_dir.rmdir()
```

### Path Manipulation

```python
import pathlib

path = pathlib.Path(&quot;example.txt&quot;)

# Split the path into components
components = path.split()
print(components)  # Output: [&#x27;..&#x27;, &#x27;home&#x27;, &#x27;user&#x27;, &#x27;example.txt&#x27;]

# Join two paths together
join_path = pathlib.Path(&quot;/&quot;).joinpath(components[0]).joinpath(*components[1:])
print(join_path)  # Output: Path(&#x27;/&#x27;)
```

### Path Comparison

```python
import pathlib

path1 = pathlib.Path(&quot;example.txt&quot;)
path2 = pathlib.Path(&quot;example.txt&quot;)

# Compare the paths for equality
print(path1 == path2)  # Output: True

# Get the difference between two paths
diff = path1 / path2
print(diff)  # Output: Path(&#x27;..&#x27;)
```

### Path Operations

```python
import pathlib

path = pathlib.Path(&quot;example.txt&quot;)

# Rename the file
new_name = path.with_suffix(&quot;.txt&quot;)
path.rename(new_name)

# Copy the file
copy_path = new_name.copy()
copy_path.copy(path)

# Move the file
move_path = new_name.move(path)
```

Note: This is not an exhaustive list of all possible `pathlib` operations. For a more comprehensive reference, please see the official [Python `pathlib` documentation](https://docs.python.org/3/library/pathlib.html).
</code></pre>

<h3 id='standard_library_documents/File and Directory Access/shutil - High-level file operations.md'>shutil - High-level file operations.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># shutil — High-level file operations

**Shutil Module Documentation**
=====================================

The `shutil` module provides high-level file operations, including copying, removing, and archiving files.

### Importing Modules
```python
import shutil
```

### Copying Files
-------------------

#### Using `shutil.copy()`
```python
# Copy a file from source to destination
source_file = &#x27;source.txt&#x27;
destination_file = &#x27;destination.txt&#x27;

try:
    # Attempt to copy the file
    shutil.copy(source_file, destination_file)
    print(f&quot;File &#x27;{source_file}&#x27; copied to &#x27;{destination_file}&#x27;&quot;)
except FileNotFoundError as e:
    print(e)
```

#### Using `shutil.copy2()`
```python
# Copy a file from source to destination, preserving metadata
source_file = &#x27;source.txt&#x27;
destination_file = &#x27;destination.txt&#x27;

try:
    # Attempt to copy the file with metadata preservation
    shutil.copy2(source_file, destination_file)
    print(f&quot;File &#x27;{source_file}&#x27; copied to &#x27;{destination_file}&#x27;&quot;)
except FileNotFoundError as e:
    print(e)
```

#### Using `shutil.copyfile()`
```python
# Copy a file from source to destination, preserving content and metadata
source_file = &#x27;source.txt&#x27;
destination_file = &#x27;destination.txt&#x27;

try:
    # Attempt to copy the file with preservation of content and metadata
    shutil.copyfile(source_file, destination_file)
    print(f&quot;File &#x27;{source_file}&#x27; copied to &#x27;{destination_file}&#x27;&quot;)
except FileNotFoundError as e:
    print(e)
```

### Removing Files
-----------------

#### Using `shutil.rmtree()`
```python
# Remove a directory and all its contents
directory_path = &#x27;/path/to/directory&#x27;

try:
    # Attempt to remove the directory
    shutil.rmtree(directory_path)
    print(f&quot;Directory &#x27;{directory_path}&#x27; removed&quot;)
except FileNotFoundError as e:
    print(e)
```

#### Using `shutil.remove()`
```python
# Remove a file
file_path = &#x27;file.txt&#x27;

try:
    # Attempt to remove the file
    shutil.remove(file_path)
    print(f&quot;File &#x27;{file_path}&#x27; removed&quot;)
except FileNotFoundError as e:
    print(e)
```

### Archiving Files
-----------------

#### Using `shutil.make_archive()`
```python
# Create an archive of a directory
directory_path = &#x27;/path/to/directory&#x27;
archive_name = &#x27;archive.zip&#x27;

try:
    # Attempt to create the archive
    shutil.make_archive(archive_name, &#x27;zip&#x27;, directory_path)
    print(f&quot;Archive &#x27;{archive_name}&#x27; created&quot;)
except FileNotFoundError as e:
    print(e)
```

#### Using `shutil.unpack_archive()`
```python
# Unpack an archive file
archive_file = &#x27;/path/to/archive.zip&#x27;
unpack_directory = &#x27;/path/to/unpack/directory&#x27;

try:
    # Attempt to unpack the archive
    shutil.unpack_archive(archive_file, unpack_directory)
    print(f&quot;Archive &#x27;{archive_file}&#x27; unpacked in &#x27;{unpack_directory}&#x27;&quot;)
except FileNotFoundError as e:
    print(e)
```

### Miscellaneous Functions
---------------------------

#### Using `shutil.which()`
```python
# Get the path of an executable file or command
executable_name = &#x27;python&#x27;

try:
    # Attempt to get the path of the executable
    executable_path = shutil.which(executable_name)
    if executable_path:
        print(f&quot;Executable &#x27;{executable_name}&#x27; found at &#x27;{executable_path}&#x27;&quot;)
    else:
        print(f&quot;Executable &#x27;{executable_name}&#x27; not found&quot;)
except FileNotFoundError as e:
    print(e)
```

#### Using `shutil.get_terminal_size()`
```python
# Get the terminal size
try:
    # Attempt to get the terminal size
    terminal_width, terminal_height = shutil.get_terminal_size()
    print(f&quot;Terminal width: {terminal_width}, Terminal height: {terminal_height}&quot;)
except IOError as e:
    print(e)
```

### Example Usage
```python
if __name__ == &#x27;__main__&#x27;:
    # Copy a file
    shutil.copy(&#x27;source.txt&#x27;, &#x27;destination.txt&#x27;)

    # Remove a file
    shutil.remove(&#x27;file.txt&#x27;)

    # Create an archive of a directory
    shutil.make_archive(&#x27;archive&#x27;, &#x27;zip&#x27;, &#x27;/path/to/directory&#x27;)

    # Unpack an archive file
    shutil.unpack_archive(&#x27;/path/to/archive.zip&#x27;, &#x27;/path/to/unpack/directory&#x27;)
```

Note: The `shutil` module provides a comprehensive set of high-level file operations, making it easier to work with files in Python. This documentation showcases the various functions and methods available in the `shutil` module, along with example usage and code snippets.
</code></pre>

<h3 id='standard_library_documents/File and Directory Access/filecmp - File and Directory Comparisons.md'>filecmp - File and Directory Comparisons.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># filecmp — File and Directory Comparisons

**Filecmp Module**
================

The `filecmp` module provides functions for comparing files and directories.

### Importing the Module

To use the `filecmp` module, you need to import it in your Python program:
```python
import filecmp
```
### Comparison Functions

#### `filecmp.cmp(file1, file2)`

Compare two files. Return `True` if they are identical, `False` otherwise.

```python
# Compare two files
def compare_files():
    # Define the paths to the files to compare
    file1_path = &#x27;path/to/file1.txt&#x27;
    file2_path = &#x27;path/to/file2.txt&#x27;

    # Compare the files
    result = filecmp.cmp(file1_path, file2_path)

    # Print the result
    if result:
        print(f&quot;Files are identical: {file1_path} and {file2_path}&quot;)
    else:
        print(f&quot;Files are different: {file1_path} and {file2_path}&quot;)

compare_files()
```

#### `filecmp.dircmp(dir1, dir2)`

Compare two directories. Return a dictionary containing the differences between the two directories.

```python
# Compare two directories
def compare_directories():
    # Define the paths to the directories to compare
    dir1_path = &#x27;path/to/dir1&#x27;
    dir2_path = &#x27;path/to/dir2&#x27;

    # Compare the directories
    result = filecmp.dircmp(dir1_path, dir2_path)

    # Print the differences
    for item in result:
        if result[item].files != result[item].diff_files:
            print(f&quot;Difference found in {item}: {result[item].files} and {result[item].diff_files}&quot;)
        elif len(result[item].files) &gt; 0:
            print(f&quot;File(s) present in {dir1_path}, missing in {dir2_path}: {&#x27;, &#x27;.join(result[item].files)}&quot;)
        elif len(result[item].diff_files) &gt; 0:
            print(f&quot;File(s) present in {dir2_path}, missing in {dir1_path}: {&#x27;, &#x27;.join(result[item].diff_files)}&quot;)

compare_directories()
```

#### `filecmp.mkdircmp(dir1, dir2)`

Compare two directories and return a file comparison object.

```python
# Compare two directories and return a file comparison object
def compare_directories_with_file_comparison():
    # Define the paths to the directories to compare
    dir1_path = &#x27;path/to/dir1&#x27;
    dir2_path = &#x27;path/to/dir2&#x27;

    # Compare the directories
    result = filecmp.mkdircmp(dir1_path, dir2_path)

    # Print the differences
    for item in result:
        if result[item].files != result[item].diff_files:
            print(f&quot;Difference found in {item}: {result[item].files} and {result[item].diff_files}&quot;)
        elif len(result[item].files) &gt; 0:
            print(f&quot;File(s) present in {dir1_path}, missing in {dir2_path}: {&#x27;, &#x27;.join(result[item].files)}&quot;)
        elif len(result[item].diff_files) &gt; 0:
            print(f&quot;File(s) present in {dir2_path}, missing in {dir1_path}: {&#x27;, &#x27;.join(result[item].diff_files)}&quot;)

compare_directories_with_file_comparison()
```

### Other Functions

The `filecmp` module also provides several other functions for comparing files and directories, including:

*   `filecmp.cmp_base(file1, file2)`: Compare two files based on their contents without considering the file names or timestamps.
*   `filecmp.dircmp_base(dir1, dir2)`: Compare two directories based on their contents without considering the directory names or timestamps.

These functions can be used to compare files and directories in a way that is independent of the file names or timestamps.
</code></pre>

<h3 id='standard_library_documents/File and Directory Access/os.path - Common pathname manipulations.md'>os.path - Common pathname manipulations.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># os.path — Common pathname manipulations

**os.path Module**
====================

The `os.path` module provides a way of using operating system dependent functionality.

### Basic Operations

#### 1. Splitting Path Components

```python
import os

# original path
path = &#x27;/home/user/documents/file.txt&#x27;

# split the path into its components
dir_path, file_name = os.path.split(path)

print(f&quot;Directory Path: {dir_path}&quot;)
print(f&quot;File Name: {file_name}&quot;)

```

#### 2. Joining Path Components

```python
import os

# directory and file names
dir_name = &#x27;my_dir&#x27;
file_name = &#x27;my_file.txt&#x27;

# join the paths together
new_path = os.path.join(dir_name, file_name)

print(f&quot;Joined Path: {new_path}&quot;)

```

#### 3. Removing Trailing Directory Separators

```python
import os

path = &#x27;/home/user//documents/file.txt&#x27;

# remove trailing directory separators
cleaned_path = os.path.normpath(path)

print(f&quot;Cleanned Path: {cleaned_path}&quot;)
```

### File Name Functions

#### 1. Base Name of a File

```python
import os

path = &#x27;/home/user/documents/file.txt&#x27;

# get the base name of the file (file_name)
base_name = os.path.basename(path)

print(f&quot;Base Name: {base_name}&quot;)

```

#### 2. Extension of a File

```python
import os

path = &#x27;/home/user/documents/file.txt&#x27;

# get the extension of the file (.txt)
extension = os.path.splitext(base_name)[1]

print(f&quot;Extension: {extension}&quot;)
```

### Directory Functions

#### 1. Current Working Directory

```python
import os

# print current working directory
print(os.getcwd())

```

#### 2. Checking if a File or Directory Exists

```python
import os

file_path = &#x27;/home/user/documents/file.txt&#x27;

# check if file exists
if os.path.exists(file_path):
    print(f&quot;File {file_path} exists&quot;)

dir_path = &#x27;/home/user/documents&#x27;
if os.path.isdir(dir_path):
    print(f&quot;Directory {dir_path} is a directory&quot;)
```

#### 3. Getting a List of All Files in a Directory

```python
import os

dir_path = &#x27;/home/user/documents&#x27;

# get list of all files and directories in the directory
files_and_dirs = os.listdir(dir_path)

print(files_and_dirs)
```

### Path Functions

#### 1. Normalizing a Path

```python
import os

path = &#x27;/home//user//documents/file.txt&#x27;

# normalize the path (remove redundant separators and up-level references ..)
normalized_path = os.path.normpath(path)

print(f&quot;Normalized Path: {normalized_path}&quot;)
```

#### 2. Relativizing a Path

```python
import os

root_dir = &#x27;/home/user&#x27;
file_path = &#x27;/home//user/documents/file.txt&#x27;

# relativize the path (get relative path from root directory to file)
rel_path = os.path.relpath(file_path, start=root_dir)

print(f&quot;Relatifized Path: {rel_path}&quot;)
```

#### 3. Absolutizing a Path

```python
import os

dir_path = &#x27;/home/user/documents&#x27;
file_name = &#x27;my_file.txt&#x27;

# absolutize the path (get absolute path from current working directory)
abs_path = os.path.abspath(os.path.join(dir_path, file_name))

print(f&quot;Absolute Path: {abs_path}&quot;)
```

#### 4. Getting Absolute and Relative Paths

```python
import os

dir_path = &#x27;/home/user/documents&#x27;
file_name = &#x27;my_file.txt&#x27;

# get both absolute and relative paths
abs_path = os.path.abspath(os.path.join(dir_path, file_name))
rel_path = os.path.relpath(abs_path)

print(f&quot;Absolute Path: {abs_path}&quot;)
print(f&quot;Relative Path: {rel_path}&quot;)

```
</code></pre>

<h3 id='standard_library_documents/File and Directory Access/glob - Unix style pathname pattern expansion.md'>glob - Unix style pathname pattern expansion.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># glob — Unix style pathname pattern expansion

**Glob Module**
===============

The `glob` module provides utilities for expanding Unix shell-style pathname patterns.

**Example Code**
----------------

```python
import glob

# Match all files with a `.txt` extension in the current directory
matched_files = glob.glob(&#x27;*.txt&#x27;)
print(matched_files)  # Output: [&#x27;file1.txt&#x27;, &#x27;file2.txt&#x27;]

# Match all directories with names containing `data`
matched_dirs = glob.glob(&#x27;data*/&#x27;)
print(matched_dirs)  # Output: [&#x27;/path/to/data/dir&#x27;, &#x27;/another/path/data/dir&#x27;]

# Match all files with a `.txt` extension in the current working directory
matched_files_cwd = glob.glob(&#x27;./*.txt&#x27;)
print(matched_files_cwd)  # Output: [&#x27;file1.txt&#x27;, &#x27;file2.txt&#x27;]

# Match all patterns, including the full pattern and relative paths
matched_patterns = glob.glob(&#x27;**/*&#x27;)
print(matched_patterns)  # Output: [&#x27;/path/to/file1.txt&#x27;, &#x27;/another/path/file2.txt&#x27;, ...]

# Use `glob.iglob` for iterator-based expansion (more memory-efficient)
file_iterator = glob.iglob(&#x27;*.txt&#x27;)
for file in file_iterator:
    print(file)

# Use `glob.os_path_matches` to check if a pattern matches the current path
import os
if glob.os_path_matches(os.getcwd(), &#x27;my_directory&#x27;):
    print(&quot;Current directory is &#x27;my_directory&#x27;&quot;)

# Use `glob.os_pathnormpath` to normalize a path for pattern matching
normalized_path = glob.os_pathnormpath(&#x27;/path/to/directory&#x27;)
print(normalized_path)  # Output: &#x27;/path/to/directory&#x27;
```

**Common Functions**
--------------------

*   `glob.glob(pattern[, recursive][, strict])`: Expand the file name pattern `pattern` to a list of pathnames. If `recursive` is `True`, it also searches in parent directories.
*   `glob.iglob(pattern[, strict])`: Return an iterator that yields each match of the pattern. If `strict` is `True`, the function will only return matches if they exactly match the pattern, without any filename or pathname changes (for example, from `/path/to/file.txt` to `/path/to/file.txt`).
*   `glob.os_path_matches(path, pattern)`: Return `True` if `pattern` matches `path`, and `False` otherwise. The argument `path` is a full pathname.
*   `glob.os_pathnormpath(path)`: Normalize the path by removing any redundant separators or parent directory references.

**Best Practices**
------------------

*   Use `glob.glob()` for simple pattern matching, as it&#x27;s more memory-efficient than using `glob.iglob()`.
*   Use `glob.iglob()` when you need to iterate over the matches instead of collecting them all in a list.
*   Be cautious with `recursive=True`, as it can lead to infinite loops if not used carefully.
*   Always check for file existence and permissions before attempting to open or read files using patterns from `glob`.
</code></pre>

<h3 id='standard_library_documents/File and Directory Access/tempfile - Generate temporary files and directories.md'>tempfile - Generate temporary files and directories.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># tempfile — Generate temporary files and directories

**Tempfile Module Example**
================================

The `tempfile` module provides functions to create temporary files, directories, etc.

### Creating Temporary Files

You can use the `TemporaryFile` class to create a new file that is automatically deleted when it is closed.
```python
import tempfile

# Create a temporary file
with tempfile.TemporaryFile() as temp_file:
    # Write data to the file
    temp_file.write(b&#x27;Hello, world!&#x27;)
    
    # Check if there&#x27;s any remaining data in the file
    assert not temp_file.tell()

# The file is now deleted
```

### Creating Temporary Directories

You can use the `TemporaryDirectory` class to create a new directory that is automatically deleted when it is closed.
```python
import tempfile

# Create a temporary directory
with tempfile.TemporaryDirectory() as temp_dir:
    # Write some files in the directory
    with open(f&#x27;{temp_dir}/file1.txt&#x27;, &#x27;w&#x27;) as file1:
        file1.write(&#x27;Hello, world!&#x27;)
    
    with open(f&#x27;{temp_dir}/file2.txt&#x27;, &#x27;w&#x27;) as file2:
        file2.write(&#x27;Goodbye, world!&#x27;)

# The directory is now deleted
```

### Creating Named Temporary Files

You can use the `NamedTemporaryFile` class to create a new file that is automatically deleted when it is closed.
```python
import tempfile

# Create a named temporary file
with tempfile.NamedTemporaryFile() as temp_file:
    # Write data to the file
    temp_file.write(b&#x27;Hello, world!&#x27;)
    
    # Check if there&#x27;s any remaining data in the file
    assert not temp_file.tell()

# The file is now deleted
```

### Creating Named Temporary Files with Prefix and Suffix

You can use the `NamedTemporaryFile` class with a prefix and suffix to create a new file that is automatically deleted when it is closed.
```python
import tempfile

# Create a named temporary file with a prefix and suffix
with tempfile.NamedTemporaryFile(prefix=&#x27;tmp_&#x27;, suffix=&#x27;.txt&#x27;) as temp_file:
    # Write data to the file
    temp_file.write(b&#x27;Hello, world!&#x27;)
    
    # Check if there&#x27;s any remaining data in the file
    assert not temp_file.tell()

# The file is now deleted
```

### Creating Pseudo-Temporary Files

You can use the `PseudoTemporaryFile` class to create a new file that will be deleted when the file descriptor is closed, regardless of whether it is explicitly closed or an exception occurs.
```python
import tempfile

# Create a pseudo-temporary file
with tempfile.PseudoTemporaryFile() as temp_file:
    # Write data to the file
    temp_file.write(b&#x27;Hello, world!&#x27;)
    
    # Check if there&#x27;s any remaining data in the file
    assert not temp_file.tell()

# The file is now deleted
```

### Creating Pseudo-Temporary Directories

You can use the `PseudoTemporaryDirectory` class to create a new directory that will be deleted when the directory descriptor is closed, regardless of whether it is explicitly closed or an exception occurs.
```python
import tempfile

# Create a pseudo-temporary directory
with tempfile.PseudoTemporaryDirectory() as temp_dir:
    # Write some files in the directory
    with open(f&#x27;{temp_dir}/file1.txt&#x27;, &#x27;w&#x27;) as file1:
        file1.write(&#x27;Hello, world!&#x27;)
    
    with open(f&#x27;{temp_dir}/file2.txt&#x27;, &#x27;w&#x27;) as file2:
        file2.write(&#x27;Goodbye, world!&#x27;)

# The directory is now deleted
```

### Getting the Current Temporary File

You can use the `gettempdir()` function to get the current temporary file path.
```python
import tempfile

print(tempfile.gettempdir())
```

### Getting the Name of a Temporary File

You can use the `gettempdir()` function and then join the directory path with a filename to get the name of a temporary file.
```python
import tempfile

print(tempfile.gettempdir() + &#x27;/tmp_file.txt&#x27;)
```

### Creating a Temporary File with Specific Permissions

You can use the `TemporaryFile` class with the `delete=False` argument and then use the `os.chmod()` function to set specific permissions on the file.
```python
import os
import tempfile

# Create a temporary file
with tempfile.TemporaryFile() as temp_file:
    # Write data to the file
    temp_file.write(b&#x27;Hello, world!&#x27;)
    
    # Set specific permissions on the file
    os.chmod(temp_file.name, 0o644)

# The file is now deleted
```

### Creating a Temporary Directory with Specific Permissions

You can use the `TemporaryDirectory` class with the `delete=False` argument and then use the `os.chmod()` function to set specific permissions on the directory.
```python
import os
import tempfile

# Create a temporary directory
with tempfile.TemporaryDirectory() as temp_dir:
    # Set specific permissions on the directory
    os.chmod(temp_dir, 0o755)

# The directory is now deleted
```

### Creating a Named Temporary File with Specific Prefix and Suffix

You can use the `NamedTemporaryFile` class with the `prefix` and `suffix` arguments to create a temporary file that meets specific naming requirements.
```python
import tempfile

# Create a named temporary file with a specific prefix and suffix
with tempfile.NamedTemporaryFile(prefix=&#x27;tmp_&#x27;, suffix=&#x27;.txt&#x27;) as temp_file:
    # Write data to the file
    temp_file.write(b&#x27;Hello, world!&#x27;)
    
    # Check if there&#x27;s any remaining data in the file
    assert not temp_file.tell()

# The file is now deleted
```

### Creating a Named Temporary File with Specific Mode

You can use the `NamedTemporaryFile` class with the `mode` argument to create a temporary file that meets specific permissions.
```python
import tempfile

# Create a named temporary file with specific mode
with tempfile.NamedTemporaryFile(mode=&#x27;w&#x27;) as temp_file:
    # Write data to the file
    temp_file.write(b&#x27;Hello, world!&#x27;)
    
    # Check if there&#x27;s any remaining data in the file
    assert not temp_file.tell()

# The file is now deleted
```

### Creating a Named Temporary Directory with Specific Mode

You can use the `TemporaryDirectory` class with the `mode` argument to create a temporary directory that meets specific permissions.
```python
import tempfile

# Create a named temporary directory with specific mode
with tempfile.TemporaryDirectory(mode=&#x27;w&#x27;) as temp_dir:
    # Write some files in the directory
    with open(f&#x27;{temp_dir}/file1.txt&#x27;, &#x27;w&#x27;) as file1:
        file1.write(&#x27;Hello, world!&#x27;)
    
    with open(f&#x27;{temp_dir}/file2.txt&#x27;, &#x27;w&#x27;) as file2:
        file2.write(&#x27;Goodbye, world!&#x27;)

# The directory is now deleted
```
</code></pre>

<h3 id='standard_library_documents/File and Directory Access/fnmatch - Unix filename pattern matching.md'>fnmatch - Unix filename pattern matching.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># fnmatch — Unix filename pattern matching

**Functionality Overview:**

The `fnmatch` module provides a way to match filenames against Unix shell-style wildcards.

**Example Use Cases:**

*   Matching files with a specific extension
*   Matching files in a directory with a wildcard pattern
*   Checking if a file exists and has a certain attribute (e.g., size, mode)

**Code Generation:**

```python
# Import the fnmatch module
import fnmatch

def match_files_with_extension(directory, extension):
    &quot;&quot;&quot;
    Match all files with the specified extension in the given directory.

    Args:
        directory (str): The path to the directory to search.
        extension (str): The file extension to match.

    Returns:
        list: A list of paths to files matching the specified extension.
    &quot;&quot;&quot;
    # Use fnmatch.fnmatch to find all files with the specified extension
    return [path for path in os.listdir(directory) if fnmatch.fnmatch(path, f&quot;*.{extension}&quot;)]

def get_files_in_directory(directory):
    &quot;&quot;&quot;
    Get a list of all files and directories in the given directory.

    Args:
        directory (str): The path to the directory to search.

    Returns:
        list: A list of paths to files and directories.
    &quot;&quot;&quot;
    # Use os.listdir to get a list of all files and directories
    return [path for path in os.listdir(directory)]

def check_file_attributes(directory, pattern, attr):
    &quot;&quot;&quot;
    Check if any file in the given directory matches the specified wildcard pattern.

    Args:
        directory (str): The path to the directory to search.
        pattern (str): The Unix shell-style wildcard pattern to match.
        attr (str): The attribute to check (e.g., size, mode).

    Returns:
        bool: True if a file matches the pattern and has the specified attribute; False otherwise.
    &quot;&quot;&quot;
    # Use os.path.exists and os.stat to get a list of all files
    files = [path for path in os.listdir(directory) if os.path.exists(os.path.join(directory, path))]

    # Iterate over each file and check if it matches the pattern and has the specified attribute
    for file in files:
        if fnmatch.fnmatch(file, pattern):
            try:
                stat = os.stat(os.path.join(directory, file))
                # Check if the file&#x27;s size or mode match the specified attribute
                if attr == &quot;size&quot; and stat.st_size &gt; 0:
                    return True
                elif attr == &quot;mode&quot; and stat.st_mode != -1:
                    return True
            except OSError:
                pass

    return False

# Example usage:

if __name__ == &quot;__main__&quot;:
    import os

    directory = &quot;.&quot;  # Search for files in the current directory
    extension = &quot;*.txt&quot;  # Match all .txt files
    pattern = &quot;*.txt&quot;  # Match all .txt files
    attr = &quot;size&quot;  # Check if any file has a non-zero size

    print(match_files_with_extension(directory, extension))  # Get all .txt files
    print(get_files_in_directory(directory))  # Get all files and directories
    print(check_file_attributes(directory, pattern, attr))  # Check if any file is a .txt file with a non-zero size
```

This code includes the following functions:

*   `match_files_with_extension`: Returns a list of paths to files matching the specified extension.
*   `get_files_in_directory`: Returns a list of paths to all files and directories in the given directory.
*   `check_file_attributes`: Returns True if any file matches the pattern and has the specified attribute, and False otherwise.

These functions demonstrate how you can use the `fnmatch` module to perform various operations on files in a directory.
</code></pre>

<h3 id='standard_library_documents/File and Directory Access/fileinput - Iterate over lines from multiple input streams.md'>fileinput - Iterate over lines from multiple input streams.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># fileinput — Iterate over lines from multiple input streams

Here&#x27;s an example of using the `fileinput` module in Python:

```python
import fileinput

def main():
    # Print a header message to let users know what we&#x27;re doing
    print(&quot;Processing files:&quot;)

    # Use the `fileinput` function to iterate over lines from multiple input streams
    for line_num, line in enumerate(fileinput.input()):
        # Print the current line number and line contents
        print(f&quot;Line {line_num+1}: {line.strip()}&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

This code will prompt the user to select one or more files to process. It then iterates over each file, printing its line numbers and contents.

Here&#x27;s a breakdown of what this code does:

*   We import the `fileinput` module.
*   In the `main()` function, we print a header message to let users know that we&#x27;re processing files.
*   We use the `fileinput.input()` function to get input from standard input (usually the command line). This function returns an iterator over the lines in each file. The `enumerate` function is used to get both the line number and contents.
*   Inside the loop, we print the current line number (`line_num+1`) and its contents using the `strip()` method to remove leading/trailing whitespace.

When you run this code from the command line:

```bash
python fileinput_example.py &lt; file1.txt file2.txt
```

And select a few files, it will display something like this:

```
Processing files:
Line 1: Hello World!
Line 2: This is a test.
Line 3: Line with leading whitespace

Line 4: Another line with trailing whitespace.
Line 5: Another line.

Line 6: Line with extra spaces     .
```
</code></pre>
<h2 id='Internet Data Handling'>Internet Data Handling</h2><ul><li><a href='#standard_library_documents/Internet Data Handling/json - JSON encoder and decoder.md'>json - JSON encoder and decoder.md</a></li><li><a href='#standard_library_documents/Internet Data Handling/binascii - Convert between binary and ASCII.md'>binascii - Convert between binary and ASCII.md</a></li><li><a href='#standard_library_documents/Internet Data Handling/mailbox - Manipulate mailboxes in various formats.md'>mailbox - Manipulate mailboxes in various formats.md</a></li><li><a href='#standard_library_documents/Internet Data Handling/quopri - Encode and decode MIME quoted-printable data.md'>quopri - Encode and decode MIME quoted-printable data.md</a></li><li><a href='#standard_library_documents/Internet Data Handling/base64 - Base16, Base32, Base64, Base85 Data Encodings.md'>base64 - Base16, Base32, Base64, Base85 Data Encodings.md</a></li><li><a href='#standard_library_documents/Internet Data Handling/mimetypes - Map filenames to MIME types.md'>mimetypes - Map filenames to MIME types.md</a></li><li><a href='#standard_library_documents/Internet Data Handling/email - An email and MIME handling package.md'>email - An email and MIME handling package.md</a></li></ul>
<h3 id='standard_library_documents/Internet Data Handling/json - JSON encoder and decoder.md'>json - JSON encoder and decoder.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># json — JSON encoder and decoder

**JSON Encoder and Decoder**
====================================

The `json` module in Python provides methods for encoding and decoding JSON data.

### Importing the json Module
```python
import json
```

### Encoding JSON Data
-------------------------

To encode Python data structures into a JSON string, you can use the `dumps()` function.
```python
# Define a dictionary to encode
data = {&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 30}

# Encode the dictionary into a JSON string
json_string = json.dumps(data)

print(json_string)  # Output: &#x27;{&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30}&#x27;
```

### Decoding JSON Data
-------------------------

To decode a JSON string into a Python data structure, you can use the `loads()` function.
```python
# Define a JSON string to decode
json_string = &#x27;{&quot;name&quot;: &quot;Jane&quot;, &quot;age&quot;: 25}&#x27;

# Decode the JSON string into a dictionary
data = json.loads(json_string)

print(data)  # Output: {&#x27;name&#x27;: &#x27;Jane&#x27;, &#x27;age&#x27;: 25}
```

### JSON Encoding Options
---------------------------

The `dumps()` function can be customized with various options to control the encoding process. Here are some examples:
```python
# Use default encoding and indent for pretty-printing
json_string = json.dumps(data, indent=4)

print(json_string)  # Output: {
    &quot;name&quot;: &quot;John&quot;,
    &quot;age&quot;: 30
}

# Use strict mode to raise an error on invalid JSON data
try:
    json_string = json.dumps({&#x27;invalid&#x27;: &#x27;data&#x27;}, ensure_ascii=False)
except json.JSONDecodeError as e:
    print(e)  # Output: Expecting value: line 1 column 6 (char 19)

# Use the default string type for non-integer values
json_string = json.dumps(data, default=str)

print(json_string)  # Output: &#x27;{&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30}&#x27;
```

### JSON Decoding Options
---------------------------

The `loads()` function can also be customized with various options to control the decoding process. Here are some examples:
```python
# Use strict mode to raise an error on invalid JSON data
try:
    json_string = &#x27;{&quot;invalid&quot;: &quot;data&quot;}&#x27;
    data = json.loads(json_string, strict=False)
except json.JSONDecodeError as e:
    print(e)  # Output: Expecting value: line 1 column 2 (char 0)

# Use the string type for non-integer values
try:
    json_string = &#x27;{&quot;name&quot;: &quot;Jane&quot;, &quot;age&quot;: 25}&#x27;
    data = json.loads(json_string, object_hook=lambda d: {k: str(v) for k, v in d.items()})
except json.JSONDecodeError as e:
    print(e)  # Output: Expecting value: line 1 column 5 (char 19)
```

### Custom JSON Encoder
-------------------------

You can create a custom JSON encoder by defining a function that takes a Python object and returns its equivalent JSON representation.
```python
def custom_encoder(obj):
    if isinstance(obj, dict):
        return {k: json.dumps(v) for k, v in obj.items()}
    elif isinstance(obj, (int, float)):
        return str(obj)
    else:
        raise ValueError(&quot;Unsupported type&quot;)

# Use the custom encoder to encode data
data = {&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 30}
json_string = json.dumps(data, default=custom_encoder)

print(json_string)  # Output: &#x27;{&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30}&#x27;
```

### Custom JSON Decoder
-------------------------

You can create a custom JSON decoder by defining a function that takes a JSON object and returns its equivalent Python object.
```python
def custom_decoder(obj):
    if isinstance(obj, str):
        return int(obj)
    elif obj == &#x27;null&#x27;:
        return None
    else:
        raise ValueError(&quot;Unsupported type&quot;)

# Use the custom decoder to decode data
json_string = &#x27;{&quot;name&quot;: &quot;Jane&quot;, &quot;age&quot;: 25}&#x27;
data = json.loads(json_string, object_hook=custom_decoder)

print(data)  # Output: {&#x27;name&#x27;: &#x27;Jane&#x27;, &#x27;age&#x27;: 25}
```
</code></pre>

<h3 id='standard_library_documents/Internet Data Handling/binascii - Convert between binary and ASCII.md'>binascii - Convert between binary and ASCII.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># binascii — Convert between binary and ASCII

**Binascii Module**
====================
```python
import binascii

# Functions
------------------

### hexlify()

Converts a bytes-like object into a hexadecimal string.

```python
# Example usage:
bytes_obj = b&#x27;Hello, World!&#x27;
hex_string = binascii.hexlify(bytes_obj)
print(hex_string)  # Output: b&#x27;48656c6c6f2c20576f726c6421&#x27;

# Convert back to bytes
bytes_again = binascii.unhexlify(hex_string)
print(bytes_again == bytes_obj)  # Output: True
```

### unhexlify()

Converts a hexadecimal string into a bytes-like object.

```python
# Example usage:
hex_string = &#x27;48656c6c6f2c20576f726c6421&#x27;
bytes_obj = binascii.unhexlify(hex_string)
print(bytes_obj == b&#x27;Hello, World!&#x27;)  # Output: True
```

### getbase64()

Converts a bytes-like object into a base64-encoded string.

```python
# Example usage:
bytes_obj = b&#x27;Hello, World!&#x27;
base64_string = binascii.getbase64(bytes_obj)
print(base64_string)  # Output: SGVsbG8sIFdvcmxkIQ==

# Convert back to bytes
bytes_again = binascii.getbase64decode(base64_string)
print(bytes_again == bytes_obj)  # Output: True
```

### getbase64decode()

Converts a base64-encoded string into a bytes-like object.

```python
# Example usage:
base64_string = &#x27;SGVsbG8sIFdvcmxkIQ==&#x27;
bytes_obj = binascii.getbase64decode(base64_string)
print(bytes_obj == b&#x27;Hello, World!&#x27;)  # Output: True
```

### ascii()

Converts a bytes-like object into an ASCII string.

```python
# Example usage:
bytes_obj = b&#x27;\xc3\xbctest&#x27;
ascii_str = binascii.ascii(bytes_obj)
print(ascii_str)  # Output: test

# Convert back to bytes
bytes_again = binascii.ascii_to_bytes(ascii_str, &#x27;strict&#x27;)
print(bytes_again == bytes_obj)  # Output: True
```

### ascii_to_bytes()

Converts an ASCII string into a bytes-like object.

```python
# Example usage:
ascii_str = &#x27;test&#x27;
bytes_obj = binascii.ascii_to_bytes(ascii_str, &#x27;strict&#x27;)
print(bytes_obj == b&#x27;\xc3\xbctest&#x27;)  # Output: True
```

### encode(), decode()

Support for encoding and decoding strings to/from bytes using various encodings.

```python
# Example usage:
str_obj = &#x27;Hello, World!&#x27;
bytes_obj = str_obj.encode(&#x27;ascii&#x27;, &#x27;strict&#x27;)
print(bytes_obj)  # Output: b&#x27;Hello, World!&#x27;

# Convert back to string
decoded_str = binascii.decodebytes(bytes_obj).decode(&#x27;utf-8&#x27;)
print(decoded_str == str_obj)  # Output: True

str_obj = b&#x27;\xc3\xbctest&#x27;
str_again = binascii.decodebytes(str_obj).decode(&#x27;utf-8&#x27;)
print(str_again == &#x27;test&#x27;)  # Output: True
```

### errors parameter for encode(), decode()

Specifies how to handle encoding and decoding errors.

```python
# Example usage:
str_obj = b&#x27;\xc3\xbctest&#x27;
encoded_bytes = str_obj.encode(&#x27;ascii&#x27;, &#x27;ignore&#x27;)
print(encoded_bytes)  # Output: b&#x27;test&#x27;

decoded_str = binascii.decodebytes(encoded_bytes).decode(&#x27;utf-8&#x27;)
print(decoded_str == &#x27;test&#x27;)  # Output: True
```

### validate()

Validates whether the input is a valid binary data.

```python
# Example usage:
valid_data = b&#x27;Hello, World!&#x27;
invalid_data = b&#x27;Goodbye, World!&#x27;

try:
    binascii.validate(valid_data)
except ValueError:
    print(&quot;Invalid data&quot;)

try:
    binascii.validate(invalid_data)
except ValueError:
    print(&quot;Invalid data&quot;)
```

### warnings parameter for validate()

Controls whether to issue a warning if the input is invalid.

```python
# Example usage:
valid_data = b&#x27;Hello, World!&#x27;
invalid_data = b&#x27;\x00&#x27;  # null byte

try:
    binascii.validate(valid_data)
except ValueError as e:
    print(&quot;Valid data&quot;)

try:
    binascii.validate(invalid_data, warnings=False)
except ValueError as e:
    print(e)  # Output: Invalid data
```
</code></pre>

<h3 id='standard_library_documents/Internet Data Handling/mailbox - Manipulate mailboxes in various formats.md'>mailbox - Manipulate mailboxes in various formats.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># mailbox — Manipulate mailboxes in various formats

**Mailbox Module Code Generator**

Here&#x27;s an example of how you can use the mailbox module to manipulate mailboxes in various formats:

```python
# Import the mailbox module
import mailbox

def create_imap_mailbox():
    &quot;&quot;&quot;
    Create an IMAP mailbox object.
    
    Returns:
        mailbox.IMAPMailbox: An IMAP mailbox object.
    &quot;&quot;&quot;
    # Create a new IMAP mailbox object
    imap_mailbox = mailbox.IMAPMailbox(&#x27;imap-Mailbox&#x27;)
    return imap_mailbox

def create_pymime_mailbox():
    &quot;&quot;&quot;
    Create a PyMIME mailbox object.
    
    Returns:
        mailbox.PymimeMailbox: A PyMIME mailbox object.
    &quot;&quot;&quot;
    # Create a new PyMIME mailbox object
    pymime_mailbox = mailbox.PymimeMailbox(&#x27;pymime-Mailbox&#x27;)
    return pymime_mailbox

def create_gnus_mailbox():
    &quot;&quot;&quot;
    Create a Gnus mailbox object.
    
    Returns:
        mailbox.GnusMailbox: A Gnus mailbox object.
    &quot;&quot;&quot;
    # Create a new Gnus mailbox object
    gnus_mailbox = mailbox.GnusMailbox(&#x27;gnus-Mailbox&#x27;)
    return gnus_mailbox

def add_message(imap_mailbox):
    &quot;&quot;&quot;
    Add a message to the IMAP mailbox.
    
    Args:
        imap_mailbox (mailbox.IMAPMailbox): The IMAP mailbox object.
    &quot;&quot;&quot;
    # Create a new email message
    msg = imap_mailbox.append(b&#x27;From: sender@example.com\r\nTo: recipient@example.com\r\nSubject: Hello World!\r\n\r\nHello World!&#x27;)
    
    return msg

def add_message_pymime(pymime_mailbox):
    &quot;&quot;&quot;
    Add a message to the PyMIME mailbox.
    
    Args:
        pymime_mailbox (mailbox.PymimeMailbox): The PyMIME mailbox object.
    &quot;&quot;&quot;
    # Create a new email message
    msg = pymime_mailbox.append(b&#x27;From: sender@example.com\r\nTo: recipient@example.com\r\nSubject: Hello World!\r\n\r\nHello World!&#x27;)
    
    return msg

def add_message_gnus(gnus_mailbox):
    &quot;&quot;&quot;
    Add a message to the Gnus mailbox.
    
    Args:
        gnus_mailbox (mailbox.GnusMailbox): The Gnus mailbox object.
    &quot;&quot;&quot;
    # Create a new email message
    msg = gnus_mailbox.append(b&#x27;From: sender@example.com\r\nTo: recipient@example.com\r\nSubject: Hello World!\r\n\r\nHello World!&#x27;)
    
    return msg

def get_messages(imap_mailbox):
    &quot;&quot;&quot;
    Get all messages from the IMAP mailbox.
    
    Args:
        imap_mailbox (mailbox.IMAPMailbox): The IMAP mailbox object.
    
    Returns:
        list: A list of message IDs.
    &quot;&quot;&quot;
    # Get all messages from the IMAP mailbox
    return imap_mailbox.get_all()

def get_messages_pymime(pymime_mailbox):
    &quot;&quot;&quot;
    Get all messages from the PyMIME mailbox.
    
    Args:
        pymime_mailbox (mailbox.PymimeMailbox): The PyMIME mailbox object.
    
    Returns:
        list: A list of message IDs.
    &quot;&quot;&quot;
    # Get all messages from the PyMIME mailbox
    return pymime_mailbox.get_all()

def get_messages_gnus(gnus_mailbox):
    &quot;&quot;&quot;
    Get all messages from the Gnus mailbox.
    
    Args:
        gnus_mailbox (mailbox.GnusMailbox): The Gnus mailbox object.
    
    Returns:
        list: A list of message IDs.
    &quot;&quot;&quot;
    # Get all messages from the Gnus mailbox
    return gnus_mailbox.get_all()

# Example usage
if __name__ == &quot;__main__&quot;:
    imap_mailbox = create_imap_mailbox()
    pymime_mailbox = create_pymime_mailbox()
    gnus_mailbox = create_gnus_mailbox()
    
    # Add a message to the IMAP mailbox
    msg = add_message(imap_mailbox)
    
    # Print all messages from the IMAP mailbox
    print(get_messages(imap_mailbox))
    
    # Create a new PyMIME mailbox
    pymime_mailbox = create_pymime_mailbox()
    
    # Add a message to the PyMIME mailbox
    msg = add_message_pymime(pymime_mailbox)
    
    # Print all messages from the PyMIME mailbox
    print(get_messages_pymime(pymime_mailbox))
    
    # Create a new Gnus mailbox
    gnus_mailbox = create_gnus_mailbox()
    
    # Add a message to the Gnus mailbox
    msg = add_message_gnus(gnus_mailbox)
    
    # Print all messages from the Gnus mailbox
    print(get_messages_gnus(gnus_mailbox))
```

This code generator creates mailbox objects for IMAP, PyMIME, and Gnus mailboxes. It provides methods to add messages to these mailboxes and retrieve all messages in them. The example usage demonstrates how to create a mailbox object, add a message, and retrieve the messages from each type of mailbox.
</code></pre>

<h3 id='standard_library_documents/Internet Data Handling/quopri - Encode and decode MIME quoted-printable data.md'>quopri - Encode and decode MIME quoted-printable data.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># quopri — Encode and decode MIME quoted-printable data

**Quopri Module**
=================

The Quopri module provides functions to encode and decode MIME quoted-printable data.

### Importing the Quopri Module

```python
import quopri
```

### Encoding MIME Data with Quopri

To encode a string using Quopri, you can use the `quopri.encode()` function.

```python
# Define the input string to be encoded
input_string = &quot;Hello, World!&quot;

# Encode the string using Quopri
encoded_string = quopri.encode(input_string)

print(&quot;Encoded String:&quot;, encoded_string)
```

Output:
```
Encoded String: QWxhcm8g
```

### Decoding MIME Data with Quopri

To decode a Quopri-encoded string, you can use the `quopri.decode()` function.

```python
# Define the input string to be decoded (Quopri-encoded)
input_string = b&quot;QWxhcm8=&quot;

# Decode the string using Quopri
decoded_string = quopri.decode(input_string)

print(&quot;Decoded String:&quot;, decoded_string)
```

Output:
```
Decoded String: Hello, World!
```

### Handling Multiple Encoding Tables

The `quopri.encode()` function can handle multiple encoding tables.

```python
# Define the input string to be encoded with multiple tables
input_string = &quot;Hello, World!&quot;

# Encode the string using Quopri with multiple tables (0x80 and 0xFF)
encoded_string = quopri.encode(input_string, table=2)

print(&quot;Encoded String:&quot;, encoded_string)
```

Output:
```
Encoded String: HgVybG9z
```

### Error Handling

If an invalid input string is provided to the `quopri.decode()` function, it raises a `ValueError`.

```python
try:
    # Define an invalid input string for decoding
    input_string = &quot;Invalid Quopri-Encoded String&quot;

    # Attempt to decode the string using Quopri
    decoded_string = quopri.decode(input_string)
except ValueError as e:
    print(&quot;Error:&quot;, e)
```

Output:
```
Error: Invalid input &#x27;Invalid Quopri-Encoded String&#x27; for encoding.
```
</code></pre>

<h3 id='standard_library_documents/Internet Data Handling/base64 - Base16, Base32, Base64, Base85 Data Encodings.md'>base64 - Base16, Base32, Base64, Base85 Data Encodings.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># base64 — Base16, Base32, Base64, Base85 Data Encodings

**Base64 Module**
================

The `base64` module provides functions for encoding and decoding binary data using various base64 encodings.

### Functions

#### encode()

Encodes a string into bytes using the specified encoding.

```python
import base64

def encoded_bytes(s, encoding=&#x27;utf-8&#x27;):
    &quot;&quot;&quot;
    Encode a string into bytes using the specified encoding.
    
    Args:
        s (str): The string to be encoded.
        encoding (str): The encoding scheme. Defaults to &#x27;utf-8&#x27;.
    
    Returns:
        bytes: The encoded bytes.
    &quot;&quot;&quot;
    return base64.b64encode(s.encode(encoding))
```

#### decode()

Decodes a bytes object into a string using the specified encoding.

```python
def decoded_string(b, encoding=&#x27;utf-8&#x27;):
    &quot;&quot;&quot;
    Decode a bytes object into a string using the specified encoding.
    
    Args:
        b (bytes): The bytes to be decoded.
        encoding (str): The decoding scheme. Defaults to &#x27;utf-8&#x27;.
    
    Returns:
        str: The decoded string.
    &quot;&quot;&quot;
    return base64.b64decode(b).decode(encoding)
```

#### urlsafe_b64encode()

Encodes a bytes object into a URL-safe Base64-encoded bytes.

```python
import base64

def url_safe_encoded_bytes(b):
    &quot;&quot;&quot;
    Encode a bytes object into a URL-safe Base64-encoded bytes.
    
    Args:
        b (bytes): The bytes to be encoded.
    
    Returns:
        bytes: The URL-safe Base64-encoded bytes.
    &quot;&quot;&quot;
    return base64.urlsafe_b64encode(b)
```

#### urlsafe_b64decode()

Decodes a URL-safe Base64-encoded bytes into a bytes object.

```python
import base64

def url_safe_decoded_bytes(c):
    &quot;&quot;&quot;
    Decode a URL-safe Base64-encoded bytes into a bytes object.
    
    Args:
        c (bytes): The URL-safe Base64-encoded bytes.
    
    Returns:
        bytes: The decoded bytes.
    &quot;&quot;&quot;
    return base64.urlsafe_b64decode(c)
```

#### gcd()

Computes the greatest common divisor (GCD) of two integers.

```python
import math

def gcd(a, b):
    &quot;&quot;&quot;
    Compute the greatest common divisor (GCD) of two integers.
    
    Args:
        a (int): The first integer.
        b (int): The second integer.
    
    Returns:
        int: The GCD of the two integers.
    &quot;&quot;&quot;
    return math.gcd(a, b)
```

#### getbase()

Returns a string representing the specified base.

```python
import base64

def get_base(n):
    &quot;&quot;&quot;
    Return a string representing the specified base.
    
    Args:
        n (int): The base to be represented as a string.
    
    Returns:
        str: A string representation of the base.
    &quot;&quot;&quot;
    if n == 2:
        return &#x27;binary&#x27;
    elif n == 8:
        return &#x27;octal&#x27;
    else:
        return &#x27;&#x27;
```

#### isbase64()

Checks whether a bytes object represents valid Base64-encoded data.

```python
import base64

def is_base64(b):
    &quot;&quot;&quot;
    Check whether a bytes object represents valid Base64-encoded data.
    
    Args:
        b (bytes): The bytes to be checked.
    
    Returns:
        bool: True if the bytes represent valid Base64-encoded data, False otherwise.
    &quot;&quot;&quot;
    try:
        base64.b64decode(b)
        return True
    except ValueError:
        return False
```

### Example Usage

```python
# Encode a string into bytes using the &#x27;utf-8&#x27; encoding scheme
encoded_bytes = encoded_bytes(&#x27;Hello, World!&#x27;)
print(encoded_bytes)

# Decode a bytes object into a string using the &#x27;utf-8&#x27; decoding scheme
decoded_string = decoded_string(b&#x27;QXV0aGUgbGFzdCBpcyBhIHNpbmdz&#x27;)
print(decoded_string)

# Encode a bytes object into a URL-safe Base64-encoded bytes
url_safe_encoded_bytes = url_safe_encoded_bytes(b&#x27;Hello, World!&#x27;)
print(url_safe_encoded_bytes)

# Decode a URL-safe Base64-encoded bytes into a bytes object
url_safe_decoded_bytes = url_safe_decoded_bytes(c=b&#x27;SGVsbG8gd29ybGQ=&#x27;)
print(url_safe_decoded_bytes)

# Compute the greatest common divisor (GCD) of two integers
gcd_value = gcd(12, 15)
print(gcd_value)

# Return a string representing the specified base
base_string = get_base(2)
print(base_string)

# Check whether a bytes object represents valid Base64-encoded data
is_valid_base64 = is_base64(b&#x27;QXV0aGUgbGFzdCBpcyBhIHNpbmdz&#x27;)
print(is_valid_base64)
```
</code></pre>

<h3 id='standard_library_documents/Internet Data Handling/mimetypes - Map filenames to MIME types.md'>mimetypes - Map filenames to MIME types.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># mimetypes — Map filenames to MIME types

**Mimetypes Module Code Generation**
=====================================

### Overview

The `mimetypes` module provides a way to map filenames to MIME types. This is useful for tasks such as determining the type of a file when opening it or sending it over a network.

### Code Examples
```python
import mimetypes

# Add a new MIME type for .txt files
mimetypes.add_type(&#x27;text/plain&#x27;, &#x27;.txt&#x27;)

# Get the MIME type for a given filename
filename = &#x27;example.txt&#x27;
mime_type = mimetypes.guess_type(filename)
if mime_type:
    print(f&quot;Filename: {filename}, MIME Type: {mime_type[0]}&quot;)
else:
    print(f&quot;No MIME type found for {filename}&quot;)

# Add a new MIME type for .pdf files
mimetypes.add_type(&#x27;application/pdf&#x27;, &#x27;.pdf&#x27;)

# Get the MIME type for a given filename, returning None if not found
filename = &#x27;example.pdf&#x27;
mime_type = mimetypes.guess_type(filename)
if mime_type:
    print(f&quot;Filename: {filename}, MIME Type: {mime_type[0]}&quot;)
else:
    print(f&quot;No MIME type found for {filename}&quot;)

# Map a new file extension to an existing MIME type
mimetypes.add_type(&#x27;text/plain&#x27;, &#x27;.new&#x27;)

# Get the MIME type for a given filename, taking into account the mapped extension
filename = &#x27;example.new&#x27;
mime_type = mimetypes.guess_type(filename)
if mime_type:
    print(f&quot;Filename: {filename}, MIME Type: {mime_type[0]}&quot;)
else:
    print(f&quot;No MIME type found for {filename}&quot;)
```
### Additional Methods

#### `mimetypes.add_type(mime_type, extension)`

*   Adds a new mapping between a MIME type and a file extension.
*   If the extension is already mapped to another MIME type, this will overwrite that mapping.

#### `mimetypes.guess_type(filename)`

*   Attempts to determine the MIME type for a given filename based on its contents.
*   Returns a tuple containing the MIME type string and the encoding character set (if applicable).

#### `mimetypes.guess_all_types()`

*   Returns a dictionary mapping file extensions to their corresponding MIME types.

### Example Use Cases

*   Determine the type of a file when opening it: Use `mimetypes.guess_type()` to determine the MIME type of a file, and then use that type to decide how to open the file.
*   Send files over a network: When sending files over a network, use `mimetypes.guess_type()` to determine the MIME type of each file, and include that type in the content header.

### API Documentation

*   [Mimetypes Module](https://docs.python.org/3/library/mimetypes.html)
*   `[add_type() function](https://docs.python.org/3/library/mimetypes.html#mimetypes.add_type)`

Note: This code generation is based on the `mimetypes` module in Python&#x27;s standard library. The actual implementation may vary depending on the specific requirements and use cases.
</code></pre>

<h3 id='standard_library_documents/Internet Data Handling/email - An email and MIME handling package.md'>email - An email and MIME handling package.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># email — An email and MIME handling package

**Email Module Code Examples**
=====================================

The `email` module provides classes for creating, parsing, and manipulating emails.

### 1. Creating an Email Message

```python
# Import the email module
import email

# Create a message with text and HTML content
msg = email.message_from_string(&#x27;Subject: Hello World\nFrom: test@example.com\nTo: test2@example.com\n\nHello World!\n\nThis is a test email.&#x27;)
print(msg)

# Create a message with attachments
attachment_msg = email.mime.multipart.MIMEMultipart()
attachment_msg[&#x27;From&#x27;] = &#x27;test@example.com&#x27;
attachment_msg[&#x27;To&#x27;] = &#x27;test2@example.com&#x27;
attachment_msg[&#x27;Subject&#x27;] = &#x27;Test Email with Attachment&#x27;

body = email.mime.text.MIMEText(&#x27;Hello World!&#x27;)
attachment_msg.attach(body)

attachment = open(&#x27;example.txt&#x27;, &#x27;rb&#x27;)
part = email.mime.application.MIMEApplication(attachment.read(), _type=&#x27;application/octet-stream&#x27;)
attachment_msg.attach(part)
attachment.close()

# Send the message
server = email.SMTP(&#x27;smtp.example.com&#x27;, 587)  # replace with your SMTP server details
server.sendmail(&#x27;test@example.com&#x27;, &#x27;test2@example.com&#x27;, attachment_msg.as_string())
```

### 2. Parsing an Email Message

```python
import email

# Create a message from a file
msg = email.message_from_file(&#x27;example.eml&#x27;)

print(&quot;Subject: &quot;, msg[&#x27;Subject&#x27;])
for part in msg.walk():
    if part.get_content_type() == &#x27;text/plain&#x27;:
        body = part.get_payload()
        print(body)
```

### 3. Encoding and Decoding Email Content

```python
import email

# Create a message with text content
msg = email.message_from_string(&#x27;Subject: Hello World\nFrom: test@example.com\nTo: test2@example.com\n\nHello World!\n\nThis is a test email.&#x27;)
body = msg.get_payload()
print(&quot;Original Body: &quot;, body)

# Encode the body using base64
encoded_body = body.encode().decode(&#x27;base64&#x27;)
print(&quot;Encoded Body: &quot;, encoded_body)

# Decode the body using base64
decoded_body = encoded_body.encode(&#x27;ascii&#x27;).decode(&#x27;base64&#x27;)
print(&quot;Decoded Body: &quot;, decoded_body)
```

### 4. Creating an Email with Attachments

```python
import email.mime

# Create a message with attachments
attachment_msg = email.mime.multipart.MIMEMultipart()
attachment_msg[&#x27;From&#x27;] = &#x27;test@example.com&#x27;
attachment_msg[&#x27;To&#x27;] = &#x27;test2@example.com&#x27;
attachment_msg[&#x27;Subject&#x27;] = &#x27;Test Email with Attachment&#x27;

body = email.mime.text.MIMEText(&#x27;Hello World!&#x27;)
attachment_msg.attach(body)

# Add an attachment
file_attachment = open(&#x27;example.txt&#x27;, &#x27;rb&#x27;)
part = email.mime.application.MIMEApplication(file_attachment.read(), _type=&#x27;application/octet-stream&#x27;)
attachment_msg.attach(part)
file_attachment.close()

print(attachment_msg.as_string())
```

### 5. Sending an Email using the SMTP Server

```python
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

# Create a message with text content
msg = MIMEMultipart()
msg[&#x27;From&#x27;] = &#x27;test@example.com&#x27;
msg[&#x27;To&#x27;] = &#x27;test2@example.com&#x27;
msg[&#x27;Subject&#x27;] = &#x27;Test Email from SMTP Server&#x27;

body = MIMEText(&#x27;Hello World! This is a test email.&#x27;)
msg.attach(body)

# Create an SMTP server connection
server = smtplib.SMTP(&#x27;smtp.example.com&#x27;, 587)
server.starttls()
server.login(msg[&#x27;From&#x27;], &#x27;password&#x27;)

try:
    server.sendmail(msg[&#x27;From&#x27;], msg[&#x27;To&#x27;], msg.as_string())
except Exception as e:
    print(f&quot;Error: {e}&quot;)
finally:
    server.quit()
```

Note that you should replace the SMTP server details (`smtp.example.com`, port 587, and `test@example.com` password) with your actual email provider&#x27;s settings.
</code></pre>
<h2 id='Importing Modules'>Importing Modules</h2><ul><li><a href='#standard_library_documents/Importing Modules/importlib.metadata - Accessing the import metadata.md'>importlib.metadata - Accessing the import metadata.md</a></li><li><a href='#standard_library_documents/Importing Modules/importlib.resources - Resource reading using importers.md'>importlib.resources - Resource reading using importers.md</a></li><li><a href='#standard_library_documents/Importing Modules/modulefinder - Find modules used by a script.md'>modulefinder - Find modules used by a script.md</a></li><li><a href='#standard_library_documents/Importing Modules/importlib.util - Utility code for importers.md'>importlib.util - Utility code for importers.md</a></li><li><a href='#standard_library_documents/Importing Modules/runpy - Locate and run Python modules without importing them first.md'>runpy - Locate and run Python modules without importing them first.md</a></li><li><a href='#standard_library_documents/Importing Modules/importlib.abc - Abstract base classes related to import.md'>importlib.abc - Abstract base classes related to import.md</a></li><li><a href='#standard_library_documents/Importing Modules/pkgutil - Package extension utility.md'>pkgutil - Package extension utility.md</a></li><li><a href='#standard_library_documents/Importing Modules/zipimport - Import modules from Zip archives.md'>zipimport - Import modules from Zip archives.md</a></li><li><a href='#standard_library_documents/Importing Modules/importlib - The implementation of import.md'>importlib - The implementation of import.md</a></li></ul>
<h3 id='standard_library_documents/Importing Modules/importlib.metadata - Accessing the import metadata.md'>importlib.metadata - Accessing the import metadata.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># importlib.metadata — Accessing the import metadata

Here&#x27;s an example of how you can access the metadata of an imported module using `importlib.metadata`:

```python
# Import the importlib.metadata module
from importlib.metadata import version, name, author, description

def get_module_metadata(module_name):
    &quot;&quot;&quot;
    Returns the metadata of a given module.

    Args:
        module_name (str): The name of the module to retrieve metadata for.

    Returns:
        dict: A dictionary containing the metadata.
    &quot;&quot;&quot;

    # Try to get the module&#x27;s metadata
    try:
        # Get the module&#x27;s version
        module_version = version(module_name)
        
        # Get the module&#x27;s name
        module_name_str = name(module_name)
        
        # Get the author of the module
        module_author = author(module_name)
        
        # Get a brief description of the module
        module_description = description(module_name)
        
        # Return the metadata as a dictionary
        return {
            &quot;version&quot;: module_version,
            &quot;name&quot;: module_name_str,
            &quot;author&quot;: module_author,
            &quot;description&quot;: module_description,
        }
    
    # Handle any exceptions that may occur during metadata retrieval
    except Exception as e:
        print(f&quot;Error retrieving metadata for {module_name}: {e}&quot;)
        return None

# Example usage
if __name__ == &quot;__main__&quot;:
    module_name = &quot;importlib.metadata&quot;
    metadata = get_module_metadata(module_name)
    
    if metadata:
        print(&quot;Module Metadata:&quot;)
        print(f&quot;Version: {metadata[&#x27;version&#x27;]}&quot;)
        print(f&quot;Name: {metadata[&#x27;name&#x27;]}&quot;)
        print(f&quot;Author: {metadata[&#x27;author&#x27;]}&quot;)
        print(f&quot;Description: {metadata[&#x27;description&#x27;]}&quot;)
```

This example uses the `importlib.metadata` module to access metadata for a given module. The `get_module_metadata` function takes a module name as input and returns a dictionary containing the module&#x27;s version, name, author, and description.

Please note that this is just an example and you may want to customize it according to your needs.

Here are some additional methods provided by `importlib.metadata`:

*   `version(module_name)`: Returns the version number of a given module.
*   `name(module_name)`: Returns the full name of a given module.
*   `author(module_name)`: Returns the author of a given module.
*   `description(module_name)`: Returns a brief description of a given module.
*   `home(module_name)`: Returns the URL of the module&#x27;s homepage (available since Python 3.10).
*   `readme(filename)`: Returns the contents of a file at the specified path in the module&#x27;s home directory (available since Python 3.9).

These methods can be used to access metadata for various modules, including built-in modules and packages that are installed using pip or other package managers.
</code></pre>

<h3 id='standard_library_documents/Importing Modules/importlib.resources - Resource reading using importers.md'>importlib.resources - Resource reading using importers.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># importlib.resources — Resource reading using importers

**Importlib Resources Module Code Examples**
=====================================================

The `importlib.resources` module provides a way to access resources within Python packages.

### 1. Accessing Text Files

```python
# Import the resources module
import importlib.resources

# Open a text file from the package&#x27;s resources
with importlib.resources.open_text(&#x27;my_package&#x27;, &#x27;path/to/file.txt&#x27;) as f:
    # Read and print the contents of the file
    contents = f.read()
    print(contents)
```

### 2. Accessing Binary Files

```python
# Import the resources module
import importlib.resources

# Open a binary file from the package&#x27;s resources
with importlib.resources.open_binary(&#x27;my_package&#x27;, &#x27;path/to/file.bin&#x27;) as f:
    # Read and print the contents of the file
    contents = f.read()
    print(contents)
```

### 3. Accessing directories

```python
# Import the resources module
import importlib.resources

# Open a directory from the package&#x27;s resources
with importlib.resources.path(&#x27;my_package&#x27;, &#x27;path/to/directory&#x27;) as dir_path:
    # Print the contents of the directory
    print(dir_path)
```

### 4. Accessing file paths

```python
# Import the resources module
import importlib.resources

# Open a file path from the package&#x27;s resources
with importlib.resources.path(&#x27;my_package&#x27;, &#x27;path/to/file&#x27;) as f_path:
    # Print the contents of the file path
    print(f_path)
```

### 5. Resolving relative paths

```python
# Import the resources module
import importlib.resources

# Resolve a relative path from the package&#x27;s resources
resolved_path = importlib.resources.resolve(&#x27;my_package&#x27;, &#x27;path/to/file&#x27;)
print(resolved_path)
```

### 6. Finding all files in a directory

```python
# Import the resources module
import importlib.resources

# Get all files in a directory from the package&#x27;s resources
files = [f for f in importlib.resources.files(&#x27;my_package&#x27;)]
for file in files:
    print(file)
```

### 7. Searching for files using a path pattern

```python
# Import the resources module
import importlib.resources

# Search for all files matching a pattern from the package&#x27;s resources
files = [f.path for f in importlib.resources.files(&#x27;my_package&#x27;, pattern=&#x27;*.txt&#x27;)]
for file in files:
    print(file)
```

### 8. Reading a resource as a text file

```python
# Import the resources module
import importlib.resources

# Read a resource from the package&#x27;s resources as a text file
with importlib.resources.read_text(&#x27;my_package&#x27;, &#x27;path/to/file.txt&#x27;) as f:
    # Print the contents of the file
    print(f)
```

### 9. Reading a resource as a binary file

```python
# Import the resources module
import importlib.resources

# Read a resource from the package&#x27;s resources as a binary file
with importlib.resources.read_binary(&#x27;my_package&#x27;, &#x27;path/to/file.bin&#x27;) as f:
    # Print the contents of the file
    print(f)
```

### 10. Writing to a resource file

```python
# Import the resources module
import importlib.resources

# Write data to a resource file from the package&#x27;s resources
with importlib.resources.open_text(&#x27;my_package&#x27;, &#x27;path/to/file.txt&#x27;, mode=&#x27;w&#x27;) as f:
    # Write some data to the file
    f.write(&#x27;Hello, World!&#x27;)
```
</code></pre>

<h3 id='standard_library_documents/Importing Modules/modulefinder - Find modules used by a script.md'>modulefinder - Find modules used by a script.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># modulefinder — Find modules used by a script

Here&#x27;s an example of how you can use the `modulefinder` module in Python to find all modules used by a script.

```python
import os
import importlib.util

def get_used_modules():
    &quot;&quot;&quot;
    Returns a list of all modules used by the current script.
    
    The list includes the module names, and their corresponding paths.
    &quot;&quot;&quot;
    # Initialize an empty dictionary to store the modules
    used_modules = {}
    
    # Walk through the directory where the script is located
    for root, dirs, files in os.walk(os.path.dirname(__file__)):
        for file in files:
            if file.endswith(&#x27;.py&#x27;):
                # Get the module name and path
                module_name = file[:-3]  # Remove .py extension
                module_path = os.path.join(root, file)
                
                # Check if the module is already loaded
                spec = importlib.util.find_spec(module_name)
                if spec is not None:
                    used_modules[module_name] = {
                        &#x27;path&#x27;: module_path,
                        &#x27;is_loaded&#x27;: True
                    }
                else:
                    used_modules[module_name] = {
                        &#x27;path&#x27;: module_path,
                        &#x27;is_loaded&#x27;: False
                    }
    
    return used_modules

def main():
    # Get the used modules
    used_modules = get_used_modules()
    
    # Print the result
    for module, info in used_modules.items():
        print(f&quot;Module: {module}&quot;)
        print(f&quot;Path: {info[&#x27;path&#x27;]}&quot;)
        print(f&quot;Loaded: {info[&#x27;is_loaded&#x27;]}\n&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

Example output:

```markdown
# Module: __init__.py
Path: ./script/__init__.py
Loaded: True

# Module: module1.py
Path: ./script/module1.py
Loaded: False

# Module: module2 import
Path: ./script/module2.py
Loaded: True
```

This script uses the `modulefinder` to find all modules used by a Python script. It iterates through the directory where the script is located and checks each `.py` file for loaded modules using `importlib.util.find_spec`. The result is stored in a dictionary where the keys are the module names, and the values are dictionaries containing the module path and whether it&#x27;s loaded or not.

Note that this script only finds Python-specific modules. If you want to find all modules (including C extensions), you can use `sys.modules` instead:

```python
import sys

used_modules = {}
for name in sys.modules:
    spec = importlib.util.find_spec(name)
    if spec is not None:
        used_modules[name] = {
            &#x27;is_loaded&#x27;: True
        }
```

This will give you a list of all loaded modules, including Python-specific and C extensions.
</code></pre>

<h3 id='standard_library_documents/Importing Modules/importlib.util - Utility code for importers.md'>importlib.util - Utility code for importers.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># importlib.util — Utility code for importers

Here are some code examples using `importlib.util` from Python&#x27;s standard library:

### 1. Importing Modules

```python
# Import the util object from the importlib package
from importlib import util

def import_module(module_name):
    &quot;&quot;&quot;
    Import a module by name and return its specification.

    Args:
        module_name (str): The name of the module to import.

    Returns:
        A ModuleSpec object representing the imported module.
    &quot;&quot;&quot;
    try:
        spec = util.find_spec(module_name)
        if spec is not None:
            print(f&quot;Imported {module_name} as {spec.name}&quot;)
            return spec
        else:
            raise ImportError(f&quot;{module_name} not found&quot;)
    except ImportError as e:
        print(e)

# Example usage:
import_module(&quot;math&quot;)
```

### 2. Creating a Module Spec

```python
from importlib.util import ModuleSpec, SourceFileLoader

def create_module_spec(module_name, spec_type):
    &quot;&quot;&quot;
    Create a ModuleSpec object for a given module name and type.

    Args:
        module_name (str): The name of the module to create.
        spec_type (str): The type of specification to create (e.g. &quot;module&quot;, &quot;package&quot;).

    Returns:
        A ModuleSpec object representing the created module.
    &quot;&quot;&quot;
    # Define the loader for the module
    loader = SourceFileLoader(module_name, f&quot;{module_name}.py&quot;)

    # Create a new ModuleSpec object
    spec = ModuleSpec(spec_type, loader)

    return spec

# Example usage:
spec = create_module_spec(&quot;my_module&quot;, &quot;module&quot;)
print(spec.spec_type)  # Output: module
```

### 3. Creating an Executable Specification

```python
from importlib.util import SourceFileLoader

def create_executable_spec(module_name, filename):
    &quot;&quot;&quot;
    Create a spec for an executable module.

    Args:
        module_name (str): The name of the module to create.
        filename (str): The path to the executable file.

    Returns:
        A ModuleSpec object representing the created executable module.
    &quot;&quot;&quot;
    # Define the loader for the module
    loader = SourceFileLoader(module_name, filename)

    # Create a new ModuleSpec object with spec_type &quot;executable&quot;
    spec = util.find_spec(&quot;executable&quot;)

    if spec is None:
        raise ImportError(&quot;Executable specification not found&quot;)
    spec = type(&#x27;ModuleSpec&#x27;, (), {&quot;spec_type&quot;: spec.spec_type})  # Hack to set spec_type
    spec.loader = loader

    return spec

# Example usage:
spec = create_executable_spec(&quot;my_module&quot;, &quot;/usr/bin/my_module&quot;)
print(spec.spec_type)  # Output: executable
```

### 4. Finding an Existing Module Spec

```python
from importlib.util import find_spec

def find_existing_module(module_name):
    &quot;&quot;&quot;
    Find an existing module spec for a given module name.

    Args:
        module_name (str): The name of the module to search for.

    Returns:
        A ModuleSpec object representing the found module, or None if not found.
    &quot;&quot;&quot;
    try:
        return find_spec(module_name)
    except ImportError as e:
        print(e)

# Example usage:
spec = find_existing_module(&quot;math&quot;)
if spec is not None:
    print(f&quot;Found existing module {spec.name}&quot;)
else:
    print(f&quot;{module_name} not found&quot;)
```

### 5. Specifying Module Attributes

```python
from importlib.util import ModuleSpec, SourceFileLoader

def create_module_spec_with_attributes(module_name, attributes):
    &quot;&quot;&quot;
    Create a ModuleSpec object for a given module name and attributes.

    Args:
        module_name (str): The name of the module to create.
        attributes (dict): A dictionary of attributes to specify.

    Returns:
        A ModuleSpec object representing the created module with specified attributes.
    &quot;&quot;&quot;
    # Define the loader for the module
    loader = SourceFileLoader(module_name, f&quot;{module_name}.py&quot;)

    # Create a new ModuleSpec object with specified attributes
    spec = ModuleSpec(&quot;module&quot;, loader)

    if attributes:
        for key, value in attributes.items():
            setattr(spec, key, value)

    return spec

# Example usage:
spec = create_module_spec_with_attributes(
    &quot;my_module&quot;,
    {
        &quot;__version__&quot;: &quot;1.0&quot;,
        &quot;__author__&quot;: &quot;John Doe&quot;
    }
)
print(spec.__version__)  # Output: 1.0
```

### 6. Checking if a Module Exists

```python
from importlib.util import find_spec

def check_module_exists(module_name):
    &quot;&quot;&quot;
    Check if a module exists using the `find_spec` function.

    Args:
        module_name (str): The name of the module to search for.

    Returns:
        bool: True if the module exists, False otherwise.
    &quot;&quot;&quot;
    try:
        find_spec(module_name)
        return True
    except ImportError as e:
        print(e)
        return False

# Example usage:
print(check_module_exists(&quot;math&quot;))  # Output: True
```
</code></pre>

<h3 id='standard_library_documents/Importing Modules/runpy - Locate and run Python modules without importing them first.md'>runpy - Locate and run Python modules without importing them first.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># runpy — Locate and run Python modules without importing them first

**RunPy Module Code Generation**
=====================================

The `runpy` module is used to locate and run Python modules without requiring an import statement.

### Importing RunPy Module

```python
# Import the runpy module from the standard library
import runpy
```

### Locating a Python Module

You can use the `runpy.main()` function to locate and run a Python module. This function takes two arguments: the module path and an optional second argument, which is not supported in this implementation.

```python
# Define a function to locate and run a Python module
def locate_and_run_module(module_path):
    &quot;&quot;&quot;
    Locate and run a Python module without requiring an import statement.
    
    Args:
        module_path (str): The path to the Python module to run.
    &quot;&quot;&quot;
    try:
        # Attempt to run the module using runpy.main()
        runpy.main([module_path])
    except Exception as e:
        # Handle any exceptions that occur during execution
        print(f&quot;Error running module: {e}&quot;)

# Example usage
module_path = &quot;/path/to/your/module.py&quot;
locate_and_run_module(module_path)
```

### Using RunPy&#x27;s Main Function

The `runpy.main()` function can also be used to run a Python script directly from the command line.

```python
import runpy

def main():
    # Define the module path as a string argument
    args = [&quot;./your_script.py&quot;]
    
    # Run the script using runpy.main()
    runpy.main(args)

# Call the main function
if __name__ == &quot;__main__&quot;:
    main()
```

### Running Multiple Modules

You can use the `runpy.run_path()` function to run multiple modules in a single call.

```python
import runpy

def main():
    # Define the module paths as a list of strings
    module_paths = [&quot;/path/to/module1.py&quot;, &quot;/path/to/module2.py&quot;]
    
    # Run all the modules using runpy.run_path()
    for module_path in module_paths:
        runpy.run_path(module_path)

# Call the main function
if __name__ == &quot;__main__&quot;:
    main()
```

### Running Modules with Arguments

You can pass arguments to a Python module when running it using `runpy.main()`.

```python
import runpy

def main():
    # Define the module path and argument as strings
    args = [&quot;./your_module.py&quot;, &quot;arg1=value1,arg2=value2&quot;]
    
    # Run the script using runpy.main()
    runpy.main(args)

# Call the main function
if __name__ == &quot;__main__&quot;:
    main()
```
</code></pre>

<h3 id='standard_library_documents/Importing Modules/importlib.abc - Abstract base classes related to import.md'>importlib.abc - Abstract base classes related to import.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># importlib.abc — Abstract base classes related to import

Here&#x27;s an example of how you can generate code based on the `importlib.abc` module:

```python
from importlib.abc import (AbstractPackage, AbstractLoader, AbstractSourceDistribution,
                           ModuleSpec)

# Abstract Package
class MyAbstractPackage(AbstractPackage):
    &quot;&quot;&quot;An abstract base class for packages.&quot;&quot;&quot;
    
    # Define a __subpackages__ method to return a tuple of subpackage names.
    def __subpackages__(self):
        # In this example, we&#x27;ll just return a static value.
        return (&quot;subpackage1&quot;, &quot;subpackage2&quot;)

# Abstract Loader
class MyAbstractLoader(AbstractLoader):
    &quot;&quot;&quot;An abstract base class for loaders.&quot;&quot;&quot;
    
    # Define a load_module method to load a module from a file.
    def load_module(self, name, loader=None):
        &quot;&quot;&quot;Loads a module from the given file.

        Args:
            name (str): The name of the module to be loaded.
            loader (ModuleSpec): An optional loader to use for loading the module.
        
        Returns:
            ModuleSpec: A ModuleSpec object representing the loaded module.
        &quot;&quot;&quot;
        
        # In this example, we&#x27;ll just return a static value.
        return ModuleSpec(name, &quot;module_file&quot;)

# Abstract Source Distribution
class MyAbstractSourceDistribution(AbstractSourceDistribution):
    &quot;&quot;&quot;An abstract base class for source distributions.&quot;&quot;&quot;
    
    # Define an __files__ method to return a list of files in the distribution.
    def __files__(self):
        # In this example, we&#x27;ll just return a static value.
        return [&quot;file1.txt&quot;, &quot;file2.txt&quot;]

# Example usage:
if __name__ == &quot;__main__&quot;:
    # Create instances of the abstract classes.
    my_package = MyAbstractPackage()
    my_loader = MyAbstractLoader()
    my_distribution = MyAbstractSourceDistribution()

    # Use the methods defined in the abstract classes.
    print(my_package.__subpackages__())
    loaded_module = my_loader.load_module(&quot;my_module&quot;)
    print(loaded_module.spec_name)
```

This code defines three new abstract base classes (`MyAbstractPackage`, `MyAbstractLoader`, and `MyAbstractSourceDistribution`) that implement the methods defined in the corresponding abstract base classes from the `importlib.abc` module.

Note: This is a simplified example, as it doesn&#x27;t include all possible implementation details or edge cases for these classes.
</code></pre>

<h3 id='standard_library_documents/Importing Modules/pkgutil - Package extension utility.md'>pkgutil - Package extension utility.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># pkgutil — Package extension utility

**Package Extension Utility (pkgutil)**
======================================

The `pkgutil` module provides a way to access and manipulate Python packages.

### Module Documentation

```markdown
Module Name: pkgutil

Description:
------------

The pkgutil module provides a way to access and manipulate Python packages.
It allows you to list the contents of a package, get the package&#x27;s metadata,
and check if a package is installed.

Functions
---------
- `find_modules(module_path)`: Find all modules in the given path that are part of an installed package.
- `load_module(module_path)`: Load a module from the given path.
- `list_packages(directory)`: List the packages found in the directory.
- `get_data(filename, directory=None)`: Get the data specified by filename from the package distribution if it exists.
- `get_spec(filename, directory=None)`: Return a specification for the distribution file that matches filename.
```

### Code Examples
-----------------

#### 1. Finding all modules in a package

```python
import pkgutil

# Find all modules in the current package
for module_info in pkgutil.iter_modules():
    print(f&quot;Module Name: {module_info.name}&quot;)
    print(f&quot;Module Path: {module_info.module_name}&quot;)
```

This will output all the modules in the current package.

#### 2. Loading a module

```python
import pkgutil

# Load a module from a file
try:
    module = pkgutil.load_module(&#x27;example&#x27;, &#x27;path/to/example.py&#x27;)
except ImportError as e:
    print(f&quot;Failed to load module: {e}&quot;)
```

This will load the `example` module from the specified file.

#### 3. Listing packages in a directory

```python
import pkgutil

# List all packages in the current directory
for package_info in pkgutil.iter_packages():
    print(f&quot;Package Name: {package_info.name}&quot;)
    print(f&quot;Package Path: {package_info.path}&quot;)
```

This will output all the packages in the current directory.

#### 4. Getting data from a package

```python
import pkgutil

# Get data from a file
data = pkgutil.get_data(&#x27;example&#x27;, &#x27;path/to/data.txt&#x27;)
if data is not None:
    print(f&quot;Data: {data.decode(&#x27;utf-8&#x27;)}&quot;)
else:
    print(&quot;No data found&quot;)
```

This will get the data specified by the `data.txt` file from the package distribution.

#### 5. Checking if a package is installed

```python
import pkgutil

# Check if a package is installed
try:
    pkgutil.get_spec(&#x27;example&#x27;)
except ImportError:
    print(&quot;Package &#x27;example&#x27; not found&quot;)
```

This will check if the `example` package is installed and output whether it&#x27;s found or not.

### Example Use Case
--------------------

Here&#x27;s an example use case where we want to create a script that lists all modules in our current package:

```python
import pkgutil

def list_modules():
    for module_info in pkgutil.iter_modules():
        print(f&quot;Module Name: {module_info.name}&quot;)
        print(f&quot;Module Path: {module_info.module_name}&quot;)

if __name__ == &quot;__main__&quot;:
    list_modules()
```

This script will output all the modules in our current package when run.
</code></pre>

<h3 id='standard_library_documents/Importing Modules/zipimport - Import modules from Zip archives.md'>zipimport - Import modules from Zip archives.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># zipimport — Import modules from Zip archives

**ZipImport Example**
```python
# Importing modules from a zip archive using ZipImport

import importlib.util
from importlib.machinery import SourceFileLoader
from io import BytesIO

def load_module_from_zip(zip_path, module_name):
    &quot;&quot;&quot;
    Load a Python module from a zip archive.

    Args:
        zip_path (str): Path to the zip archive containing the module.
        module_name (str): Name of the module to be loaded.

    Returns:
        Module: The loaded module.
    &quot;&quot;&quot;
    # Create a BytesIO object to simulate a file
    with open(zip_path, &#x27;rb&#x27;) as f:
        zip_data = f.read()

    # Load the zip archive using the BytesIO object
    spec = importlib.util.spec_from_file_location(module_name, BytesIO(zip_data))
    
    if spec is None:
        raise ValueError(f&quot;Failed to load module from zip: {module_path}&quot;)

    # Create a SourceFileLoader object to load the module
    loader = SourceFileLoader(module_name, BytesIO(zip_data))

    # Load the module using the loader
    try:
        module = loader.load_module()
    except Exception as e:
        raise ValueError(f&quot;Failed to load module from zip: {e}&quot;)

    return module

# Example usage
if __name__ == &quot;__main__&quot;:
    # Create a sample zip archive containing a Python module
    import zipfile
    with zipfile.ZipFile(&quot;example.zip&quot;, &quot;w&quot;) as zip_file:
        # Add the module to the zip archive
        zip_file.write(&quot;./module.py&quot;)

    # Load the module from the zip archive
    module_name = &quot;example.module&quot;
    loaded_module = load_module_from_zip(&quot;example.zip&quot;, module_name)

    # Print the loaded module&#x27;s name and attributes
    print(f&quot;Loaded Module: {loaded_module.__name__}&quot;)
    for attr in dir(loaded_module):
        if not attr.startswith(&quot;_&quot;):
            print(f&quot;{attr}: {getattr(loaded_module, attr)}&quot;)
```

**Explanation**

This code defines a function `load_module_from_zip` that loads a Python module from a zip archive. It uses the `importlib.util.spec_from_file_location` function to create a module specification for the zip archive, and then creates a `SourceFileLoader` object to load the module.

The example usage demonstrates how to create a sample zip archive containing a Python module, load the module using the `load_module_from_zip` function, and print the loaded module&#x27;s name and attributes.

**Note**

This code assumes that the zip archive contains a single Python module file. If your use case involves loading multiple modules from different parts of the same zip archive, you will need to modify the code accordingly.

Also note that this is just one way to load a Python module from a zip archive. Depending on your specific requirements, you may need to use other methods or libraries.
</code></pre>

<h3 id='standard_library_documents/Importing Modules/importlib - The implementation of import.md'>importlib - The implementation of import.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># importlib — The implementation of import

**Importlib Module**
======================

The `importlib` module provides functions to manipulate import statements and imports.

### Table of Contents

*   [Loading a Module](#loading-a-module)
*   [Getting Information About an Module](#getting-information-about-an-module)
*   [Resolving the Name of an Module](#resolving-the-name-of-an-module)
*   [Creating a New Module from Code](#creating-a-new-module-from-code)
*   [Executing a Function from an Module](#executing-a-function-from-an-module)

### Loading a Module

```python
import importlib.util

def load_module(module_name):
    &quot;&quot;&quot;
    Load a module by name.

    Args:
        module_name (str): The name of the module to be loaded.

    Returns:
        importlib.util.ModuleSpec: A `ModuleSpec` object representing the loaded module.
    &quot;&quot;&quot;

    # Use the `importlib.util.find_spec()` function to find the module spec.
    try:
        # Attempt to find the module spec.
        module_spec = importlib.util.find_spec(module_name)
        
        # If successful, return the module spec.
        if module_spec is not None and module_spec.loader is not None:
            return module_spec
        else:
            raise ImportError(f&quot;Failed to load module {module_name}&quot;)
    
    except ImportError as e:
        print(e)

# Example usage
module_name = &quot;math&quot;
loaded_module = load_module(module_name)
```

### Getting Information About an Module

```python
import importlib.util

def get_module_info(module_name):
    &quot;&quot;&quot;
    Get information about a module.

    Args:
        module_name (str): The name of the module to be inspected.

    Returns:
        dict: A dictionary containing metadata about the module.
    &quot;&quot;&quot;

    # Use the `importlib.util.find_spec()` function to find the module spec.
    try:
        module_spec = importlib.util.find_spec(module_name)
        
        # If successful, return the module&#x27;s metadata.
        if module_spec is not None and module_spec.loader is not None:
            return {
                &quot;module_name&quot;: module_spec.name,
                &quot;origin&quot;: module_spec.origin,
                &quot;loader&quot;: module_spec.loader,
                &quot;filename&quot;: module_spec.filename
            }
        
    except ImportError as e:
        print(e)
    
    return {}

# Example usage
module_name = &quot;math&quot;
module_info = get_module_info(module_name)
print(module_info)
```

### Resolving the Name of an Module

```python
import importlib.util

def resolve_module_name(name):
    &quot;&quot;&quot;
    Resolve a module name to its actual location.

    Args:
        name (str): The name of the module to be resolved.

    Returns:
        str: The absolute path of the module&#x27;s file.
    &quot;&quot;&quot;

    # Use the `importlib.util.find_spec()` function to find the module spec.
    try:
        # Attempt to find the module spec.
        module_spec = importlib.util.find_spec(name)
        
        # If successful, return the module&#x27;s filename.
        if module_spec is not None and module_spec.loader is not None:
            return module_spec.filename
        
    except ImportError as e:
        print(e)
    
    return None

# Example usage
module_name = &quot;math&quot;
resolved_name = resolve_module_name(module_name)
print(resolved_name)
```

### Creating a New Module from Code

```python
import importlib.util
from io import BytesIO

def create_module_from_code(code):
    &quot;&quot;&quot;
    Create a new module from code.

    Args:
        code (str): The source code of the module to be created.

    Returns:
        importlib.util.ModuleSpec: A `ModuleSpec` object representing the newly created module.
    &quot;&quot;&quot;

    # Use the `importlib.util.find_spec()` function to find the module spec.
    try:
        # Create a bytes buffer from the code.
        buf = BytesIO(code.encode())
        
        # Attempt to create the module spec.
        module_spec = importlib.util.spec_from_file_location(&quot;module_name&quot;, buf.name)
        
        # If successful, return the module spec.
        if module_spec is not None and module_spec.loader is not None:
            return module_spec
        else:
            raise ImportError(f&quot;Failed to create module&quot;)
    
    except ImportError as e:
        print(e)

# Example usage
code = &quot;&quot;&quot;
def add(a, b):
    return a + b

class MyClass:
    pass
&quot;&quot;&quot;

new_module_name = &quot;my_module&quot;
new_module = create_module_from_code(code)
print(new_module.name)
```

### Executing a Function from an Module

```python
import importlib.util
from math import sin, cos

def execute_function(module_name, func_name):
    &quot;&quot;&quot;
    Execute a function from an module.

    Args:
        module_name (str): The name of the module containing the function.
        func_name (str): The name of the function to be executed.

    Returns:
        float: The result of the function execution.
    &quot;&quot;&quot;

    # Use the `importlib.util.find_spec()` function to find the module spec.
    try:
        # Attempt to load the module.
        module = importlib.util.spec_from_module(module_name).loader
        func = getattr(module, func_name)
        
        # If successful, return the result of the function execution.
        if callable(func):
            return func()
        else:
            raise TypeError(f&quot;Function {func_name} does not exist in module&quot;)
    
    except ImportError as e:
        print(e)

# Example usage
module_name = &quot;math&quot;
func_name = &quot;sin&quot;
result = execute_function(module_name, func_name)
print(result)
```

This code provides an implementation of the `importlib` module from Python&#x27;s standard library. It includes functions to load a module by name, get information about a module, resolve a module name, create a new module from code, and execute a function from a module.

**Note:** This is a simplified implementation and may not cover all edge cases. The actual `importlib` module in Python&#x27;s standard library is more comprehensive and includes additional features.
</code></pre>
<h2 id='Internationalization'>Internationalization</h2><ul><li><a href='#standard_library_documents/Internationalization/locale - Internationalization services.md'>locale - Internationalization services.md</a></li><li><a href='#standard_library_documents/Internationalization/gettext - Multilingual internationalization services.md'>gettext - Multilingual internationalization services.md</a></li></ul>
<h3 id='standard_library_documents/Internationalization/locale - Internationalization services.md'>locale - Internationalization services.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># locale — Internationalization services

Here&#x27;s an example of how you can use the `locale` module in Python:
```python
import locale

# Get the current locale
def get_current_locale():
    &quot;&quot;&quot;Return the current locale&quot;&quot;&quot;
    return locale.getlocale()

print(&quot;Current Locale:&quot;, get_current_locale())

# Set a new locale
def set_new_locale(locale_code, language_code):
    &quot;&quot;&quot;
    Set a new locale.

    Args:
        locale_code (str): The full locale code (e.g. &#x27;en_US.UTF-8&#x27;)
        language_code (str): The language code (e.g. &#x27;en&#x27; for English)

    Returns:
        bool: True if the locale was successfully set, False otherwise
    &quot;&quot;&quot;
    try:
        locale.setlocale(locale.LC_ALL, locale_code)
        return True
    except Exception as e:
        print(f&quot;Failed to set locale: {str(e)}&quot;)
        return False

# Test setting a new locale
print(&quot;Setting locale...&quot;)
set_new_locale(&#x27;en_US.UTF-8&#x27;, &#x27;en&#x27;)

# Get the language and country codes from the locale code
def get_language_and_country_code(locale_code):
    &quot;&quot;&quot;
    Extract the language and country codes from the locale code.

    Args:
        locale_code (str): The full locale code

    Returns:
        tuple: A tuple containing the language code and the country code
    &quot;&quot;&quot;
    parts = locale.getdefaultlocale()
    if parts is None:
        return None, None  # No suitable locale found
    language_code = parts[0]
    country_code = parts[1]
    return language_code, country_code

print(&quot;Language Code:&quot;, get_language_and_country_code(&#x27;en_US.UTF-8&#x27;))
print(&quot;Country Code:&quot;, get_language_and_country_code(&#x27;fr_FR.UTF-8&#x27;))

# Get the list of available locales
def get_available_locales():
    &quot;&quot;&quot;Return a list of available locale codes&quot;&quot;&quot;
    return locale.getlocale()[0]

available_locales = get_available_locales()
for locale in available_locales:
    print(locale)

# Use locale for date and number formatting
import datetime

def format_date(date_obj):
    &quot;&quot;&quot;
    Format the given date object as per the current locale.

    Args:
        date_obj (datetime.date): The date object to be formatted

    Returns:
        str: The formatted date string
    &quot;&quot;&quot;
    return locale.format_string(&#x27;%B %d, %Y&#x27;, date_obj)

date_obj = datetime.date(2022, 12, 25)
print(&quot;Formatted Date:&quot;, format_date(date_obj))

def format_number(num):
    &quot;&quot;&quot;
    Format the given number as per the current locale.

    Args:
        num (float): The number to be formatted

    Returns:
        str: The formatted number string
    &quot;&quot;&quot;
    return locale.format_string(&#x27;%d&#x27;, num)

num = 12345.6789
print(&quot;Formatted Number:&quot;, format_number(num))
```
This code demonstrates how you can use the `locale` module to:

*   Get the current locale and set a new one
*   Extract language and country codes from the locale code
*   Get a list of available locales
*   Use locale for date and number formatting

Note that the behavior of some functions in the `locale` module can vary depending on the underlying operating system, so you may need to adjust your expectations or use platform-specific checks when working with these functions.
</code></pre>

<h3 id='standard_library_documents/Internationalization/gettext - Multilingual internationalization services.md'>gettext - Multilingual internationalization services.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># gettext — Multilingual internationalization services

**gettext Module**
================

The `gettext` module provides support for internationalization (i18n) and localization (L10n).

**Installation**
---------------

Not applicable, as this is a standard Python library.

**Example Use Cases**
--------------------

### 1. Translating Messages

Use the `gettext` function to translate messages:
```python
import gettext

# Initialize translation catalog
catalog = gettext.translation(&#x27;myapp&#x27;, &#x27;locale/myapp.mo&#x27;)

# Get translated message
def _(message):
    return catalog.gettext(message)

print(_(&quot;Hello, World!&quot;))  # Output: Hello, World!
```
### 2. Setting Up a Translation Catalog

Create a translation catalog using the `gettext` function:
```python
import gettext

# Initialize translation catalog
catalog = gettext.translation(&#x27;myapp&#x27;, &#x27;locale/myapp.mo&#x27;)

# Get translated message
def _(message):
    return catalog.gettext(message)

print(_(&quot;Hello, World!&quot;))  # Output: Hello, World!
```
### 3. Using Message Catalogs

Use a `MessageCatalog` object to access translated messages:
```python
import gettext

# Initialize translation catalog
catalog = gettext.translation(&#x27;myapp&#x27;, &#x27;locale/myapp.mo&#x27;)

# Create MessageCatalog object
msgcat = catalog.gettextCatalog()

# Get translated message
print(msgcat u&quot;Hello, World!&quot;)  # Output: Hello, World!
```
### 4. Setting up a Domain

Create a domain using the `gettext` function:
```python
import gettext

# Initialize translation catalog
domain = gettext.bindtextdomain(&#x27;myapp&#x27;, &#x27;locale&#x27;)

# Get translated message
def _(message):
    return gettext.gettext(message)

print(_(&quot;Hello, World!&quot;))  # Output: Hello, World!
```
### 5. Using a Locale File

Use a locale file to translate messages:
```python
import gettext

# Initialize translation catalog
domain = gettext.bindtextdomain(&#x27;myapp&#x27;, &#x27;locale&#x27;)
catalog = gettext.translation(&#x27;myapp&#x27;, &#x27;locale/myapp.mo&#x27;)

# Get translated message
def _(message):
    return catalog.gettext(message)

print(_(&quot;Hello, World!&quot;))  # Output: Hello, World!
```
**API Documentation**
--------------------

### `gettext.translation(domain, path, languages)`

Initialize a translation catalog.

*   `domain`: Domain name.
*   `path`: Path to the translation file.
*   `languages`: List of languages supported by the catalog.

### `gettext.bindtextdomain(domain, path)`

Bind a domain to a directory.

*   `domain`: Domain name.
*   `path`: Directory path where translations are stored.

### `gettext.gettext(message)`

Get a translated message from a catalog.

*   `message`: Message to translate.

### `gettext.translationCatalog()`

Return the translation catalog for a given domain.

**Tips and Best Practices**
---------------------------

*   Always initialize the translation catalog before using it.
*   Use the `bindtextdomain` function to bind a domain to a directory.
*   Use the `gettext` function or `gettext.translationCatalog()` method to access translated messages.
*   Use the `u&quot;&quot;` prefix to insert Unicode characters into strings.

By following these examples and tips, you can effectively use the `gettext` module in your Python applications.
</code></pre>
<h2 id='Text Processing Services'>Text Processing Services</h2><ul><li><a href='#standard_library_documents/Text Processing Services/string - Common string operations.md'>string - Common string operations.md</a></li><li><a href='#standard_library_documents/Text Processing Services/re - Regular expression operations.md'>re - Regular expression operations.md</a></li><li><a href='#standard_library_documents/Text Processing Services/stringprep - Internet String Preparation.md'>stringprep - Internet String Preparation.md</a></li><li><a href='#standard_library_documents/Text Processing Services/textwrap - Text wrapping and filling.md'>textwrap - Text wrapping and filling.md</a></li><li><a href='#standard_library_documents/Text Processing Services/unicodedata - Unicode Database.md'>unicodedata - Unicode Database.md</a></li><li><a href='#standard_library_documents/Text Processing Services/rlcompleter - Completion function for GNU readline.md'>rlcompleter - Completion function for GNU readline.md</a></li><li><a href='#standard_library_documents/Text Processing Services/readline - GNU readline interface.md'>readline - GNU readline interface.md</a></li><li><a href='#standard_library_documents/Text Processing Services/difflib - Helpers for computing deltas.md'>difflib - Helpers for computing deltas.md</a></li></ul>
<h3 id='standard_library_documents/Text Processing Services/string - Common string operations.md'>string - Common string operations.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># string — Common string operations

Here&#x27;s an example of how you can use common string operations available in Python&#x27;s `string` module:
```python
import string

# Creating all possible printable ASCII characters
printable_chars = string.printable
for char in printable_chars:
    print(char)

# Creating all punctuation marks
punctuation_marks = string.punctuation
for mark in punctuation_marks:
    print(mark)

# Converting string to lowercase, uppercase and title case
original_string = &quot;Hello World&quot;
lowercase = original_string.lower()
uppercase = original_string.upper()
title_case = original_string.title()
print(&quot;Original String:&quot;, original_string)
print(&quot;Lowercase:&quot;, lowercase)
print(&quot;Uppercase:&quot;, uppercase)
print(&quot;Title Case:&quot;, title_case)

# Removing leading and trailing whitespaces
string_with_spaces = &quot;   Hello World   &quot;
stripped_string = string_with_spaces.strip()
print(&quot;Original String with Spaces:&quot;, string_with_spaces)
print(&quot;String after removing Leading/Trailing Whitespaces:&quot;, stripped_string)

# Splitting a string into substrings
sentence = &quot;Hello, World!&quot;
substrings = sentence.split(&#x27;,&#x27;)
print(&quot;Original Sentence:&quot;, sentence)
print(&quot;Substrings:&quot;, substrings)

# Joining multiple strings into one
multiple_strings = [&quot;Hello&quot;, &quot;, World!&quot;, &quot;!&quot;]
joined_string = &quot;&quot;.join(multiple_strings)
print(&quot;Multiple Strings:&quot;, multiple_strings)
print(&quot;Joined String:&quot;, joined_string)

# Replacing a substring with another string
original_string = &quot;Hello World&quot;
new_string = original_string.replace(&quot;World&quot;, &quot;Python&quot;)
print(&quot;Original String:&quot;, original_string)
print(&quot;String after replacing &#x27;World&#x27; with &#x27;Python&#x27;:&quot;, new_string)

# Counting the occurrences of a character in a string
char_to_count = &quot;a&quot;
string = &quot;banana&quot;
count = string.count(char_to_count)
print(&quot;Count of &#x27;{}&#x27; in &#x27;{}&#x27;:&quot;.format(char_to_count, string), count)

# Finding the index of a substring within a string
substring = &quot;an&quot;
original_string = &quot;banana&quot;
index = original_string.find(substring)
if index != -1:
    print(&quot;Index of &#x27;{}&#x27; in &#x27;{}&#x27;: {}&quot;.format(substring, original_string, index))
else:
    print(&quot;&#x27;{}&#x27; not found in &#x27;{}&#x27;&quot;.format(substring, original_string))

# Creating a string from bytes
bytes_data = b&quot;Hello World&quot;
string_from_bytes = bytes_data.decode(&#x27;utf-8&#x27;)
print(&quot;Bytes Data:&quot;, bytes_data)
print(&quot;String from Bytes:&quot;, string_from_bytes)

# Encoding and decoding strings to/from bytes
original_string = &quot;Hello World&quot;
encoded_bytes = original_string.encode(&#x27;utf-8&#x27;)
decoded_string = encoded_bytes.decode(&#x27;utf-8&#x27;)
print(&quot;Original String:&quot;, original_string)
print(&quot;Encoded Bytes:&quot;, encoded_bytes)
print(&quot;Decoded String:&quot;, decoded_string)
```
Note that this example only covers the common string operations available in Python&#x27;s `string` module. For more advanced string operations, you may need to use other modules like `re` or `datetime`.
</code></pre>

<h3 id='standard_library_documents/Text Processing Services/re - Regular expression operations.md'>re - Regular expression operations.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># re — Regular expression operations

**Regular Expression Operations using re Module**
=====================================================

The `re` module in Python provides support for regular expressions, which are a powerful way to match patterns in strings.

### Importing the `re` Module

To use the `re` module, you need to import it in your Python script or interactive session:
```python
import re
```

### Patterns and Substitutions

Regular expressions can be used to search for patterns in strings and make substitutions. Here are a few examples:

#### Pattern Matching

You can use regular expressions to match patterns in strings using the `search()` function:
```python
import re

# Define a pattern
pattern = r&quot;\d{4}-\d{2}-\d{2}&quot;  # Matches dates in YYYY-MM-DD format

# Search for matches
date_str = &quot;My birthday is February 12, 1990.&quot;
match = re.search(pattern, date_str)

if match:
    print(&quot;Match found:&quot;, match.group())
else:
    print(&quot;No match found.&quot;)
```

#### Substitutions

You can use regular expressions to make substitutions in strings using the `sub()` function:
```python
import re

# Define a pattern and replacement string
pattern = r&quot;\d{4}&quot;
replacement = &quot;XXXX&quot;

# Search for matches and substitute
date_str = &quot;My birthday is February 12, 1990.&quot;
new_date_str = re.sub(pattern, replacement, date_str)

print(&quot;New date:&quot;, new_date_str)
```

#### Searching and Replacing Multiple Occurrences

You can use the `findall()` function to search for all occurrences of a pattern in a string:
```python
import re

# Define a pattern
pattern = r&quot;\d{4}-\d{2}-\d{2}&quot;

# Search for matches
date_strs = [&quot;My birthday is February 12, 1990.&quot;, &quot;My anniversary is June 20, 2001.&quot;]
matches = re.findall(pattern, date_strs)

print(&quot;Matches:&quot;, matches)
```

#### Compiling Regular Expressions

You can use the `compile()` function to compile regular expressions into a pattern object:
```python
import re

# Define a pattern
pattern = r&quot;\d{4}-\d{2}-\d{2}&quot;

# Compile the pattern
compiled_pattern = re.compile(pattern)

# Search for matches using the compiled pattern
date_strs = [&quot;My birthday is February 12, 1990.&quot;, &quot;My anniversary is June 20, 2001.&quot;]
for date_str in date_strs:
    match = compiled_pattern.search(date_str)
    if match:
        print(&quot;Match found:&quot;, match.group())
```

### Common Regular Expression Syntax

Here are some common regular expression syntax elements:

* `.` matches any single character
* `^` matches the start of a string
* `$` matches the end of a string
* `*` matches zero or more occurrences of the preceding element
* `+` matches one or more occurrences of the preceding element
* `?` matches zero or one occurrence of the preceding element
* `{n}` matches exactly n occurrences of the preceding element
* `{n, m}` matches at least n and at most m occurrences of the preceding element
* `[abc]` matches any single character in the set
* `\d` matches a digit
* `\w` matches a word character (alphanumeric plus underscore)
* `\s` matches a whitespace character

### Best Practices

Here are some best practices for using regular expressions:

* Use raw strings (`r&quot;...&quot;`) to avoid backslash escaping issues.
* Use `re.escape()` to escape special characters in your patterns.
* Test your patterns using the `re.test()` function before searching for matches.
* Use the `re.IGNORECASE` flag to make matching case-insensitive.

Note: This is not an exhaustive list of regular expression operations, but it covers many common use cases. For more information, see the Python [official documentation](https://docs.python.org/3/library/re.html) and the [regular expression documentation](https://www.regular-expressions.info/.
</code></pre>

<h3 id='standard_library_documents/Text Processing Services/stringprep - Internet String Preparation.md'>stringprep - Internet String Preparation.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># stringprep — Internet String Preparation

Here&#x27;s an example of how you can use the `stringprep` module in Python:

**stringprep.py**
```python
import stringprep

# Define a function to validate email addresses
def validate_email(email):
    &quot;&quot;&quot;
    Validate an email address using the stringprep module.

    :param email: The email address to validate
    :return: True if the email is valid, False otherwise
    &quot;&quot;&quot;
    # Use the stringprep class to validate the email address
    sp = stringprep.StringPrep()
    return sp.validate(email)

# Define a function to normalize strings
def normalize_string(s):
    &quot;&quot;&quot;
    Normalize a string using the stringprep module.

    :param s: The string to normalize
    :return: The normalized string
    &quot;&quot;&quot;
    # Use the StringPrep class to normalize the string
    sp = stringprep.StringPrep()
    return sp.normalize(s)

# Define a function to check if a string is safe for internationalized text (UTF-8)
def is_safe_for_utf8(s):
    &quot;&quot;&quot;
    Check if a string is safe for use in internationalized text (UTF-8) using the stringprep module.

    :param s: The string to check
    :return: True if the string is safe, False otherwise
    &quot;&quot;&quot;
    # Use the StringPrep class to check if the string is safe for UTF-8
    sp = stringprep.StringPrep()
    return sp.is_safe_for_utf8(s)

# Example usage:
email = &quot;example@example.com&quot;
print(validate_email(email))  # Output: True

s = &quot;Hello, World!&quot;
normalized_s = normalize_string(s)
print(normalized_s)  # Output: Hello, World!

s = &quot;\u00E9l\U000eF0A9&quot;
print(is_safe_for_utf8(s))  # Output: False
```
**Module documentation**

The `stringprep` module provides a class called `StringPrep` that can be used to validate and normalize strings according to the Internet String Preparation rules.

The `validate()` method takes a string as input and returns True if the string is valid, False otherwise. It checks for a variety of issues such as non-ASCII characters, invalid domain names, and so on.

The `normalize()` method takes a string as input and returns the normalized version of the string. This involves converting certain special characters to their equivalent ASCII values.

The `is_safe_for_utf8()` method takes a string as input and returns True if the string is safe for use in internationalized text (UTF-8), False otherwise. It checks for issues such as invalid character encoding, null bytes, and so on.

**Available methods**

* `validate(s)`: Validate a string according to the Internet String Preparation rules
* `normalize(s)`: Normalize a string by converting certain special characters to their equivalent ASCII values
* `is_safe_for_utf8(s)`: Check if a string is safe for use in internationalized text (UTF-8)

**Available classes**

* `StringPrep()`: The main class provided by the `stringprep` module, used for validating and normalizing strings.
</code></pre>

<h3 id='standard_library_documents/Text Processing Services/textwrap - Text wrapping and filling.md'>textwrap - Text wrapping and filling.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># textwrap — Text wrapping and filling

**Text Wrap Module**
=====================

The `textwrap` module provides functions for controlling the width of text output.

### Functions

#### 1. wrap(text, width)

Wraps the input `text` into lines of maximum length `width`.

```python
import textwrap

def wrapped_text_example():
    # Input text to be wrapped
    text = &quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.&quot;
    
    # Maximum line width
    max_width = 50
    
    # Wrap the text into lines of max_width
    wrapped_lines = textwrap.wrap(text, max_width)
    
    # Print the wrapped lines
    for line in wrapped_lines:
        print(line)

wrapped_text_example()
```

Output:

```
Lorem ipsum dolor sit amet,
consectetur adipiscing elit, 
sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.

Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
```

#### 2. fill(text, width)

Fills the input `text` with spaces to a total line length of `width`.

```python
import textwrap

def filled_text_example():
    # Input text to be filled
    text = &quot;Lorem ipsum dolor sit amet.&quot;
    
    # Maximum line length
    max_length = 50
    
    # Fill the text with spaces to fill the max_length
    filled_line = textwrap.fill(text, max_length)
    
    # Print the filled line
    print(filled_line)

filled_text_example()
```

Output:

```
Lorem ipsum dolor sit amet.         . .
                  .                .  .
                  .                .  .
                  .                .  .
                  .                .  .
                  .                .  .
                  .                .  .
                  .                .  .
                  .                .  .
                  .                .  .
                  .                .  .
```

#### 3. indent(text, width, subsequent_indent=0)

Indents the input `text` with leading whitespace of length `width`, followed by subsequent indentations of length `subsequent_indent`.

```python
import textwrap

def indented_text_example():
    # Input text to be indented
    text = &quot;Lorem ipsum dolor sit amet.&quot;
    
    # Initial indentation width
    initial_indentation_width = 5
    
    # Subsequent indentation width
    subsequent_indent_width = 3
    
    # Indent the text with leading whitespace of initial_indentation_width, followed by subsequent indentations of length subsequent_indent_width
    indented_text = textwrap.indent(text, initial_indentation_width, subsequent_indent=subsequent_indent_width * &#x27; &#x27;)
    
    # Print the indented text
    print(indented_text)

indented_text_example()
```

Output:

```
  Lorem ipsum dolor sit amet.
     .
      .
       .
        .
         .
          .
           .
            .
             .
              .
               .
                .
                 .
                  .
                   .
                    .
                     .
                      .
                       .
                        .
                         .
                          .
                           .
                            .
                             .
                              .
                               .
                                .
                                 .
                                  .
                                   .
                                    .
                                     .
                                      .
                                       .
                                        .
                                         .
                                          .
                                           .
                                            .
                                             .
```

### Constants

#### 1. blankwidth (default: 50)

Maximum width of a line in the wrapped text.

```python
import textwrap

def blank_width_example():
    # Set the blankwidth to 30
    textwrap.blankwidth = 30
    
    # Input text to be wrapped
    text = &quot;Lorem ipsum dolor sit amet.&quot;
    
    # Wrap the text into lines of max_blankwidth
    wrapped_lines = textwrap.wrap(text, max_blankwidth)
    
    # Print the wrapped lines
    for line in wrapped_lines:
        print(line)

blank_width_example()
```

Output:

```
Lorem ipsum dolor sit amet.
consectetur adipiscing elit
sed do eiusmod tempor incididunt
ut labore et dolore magna aliqua.
```
</code></pre>

<h3 id='standard_library_documents/Text Processing Services/unicodedata - Unicode Database.md'>unicodedata - Unicode Database.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># unicodedata — Unicode Database

**unicodedata Module**
=======================

The `unicodedata` module provides functions and classes to normalize, decompose, and encode strings in a way that is useful for text processing.

### Functions

#### 1. `unicodedata.category(char)` 

Returns the Unicode category of a given character.

```python
import unicodedata

# Test the function
print(unicodedata.category(&#x27;a&#x27;))  # Output: Lo
```

#### 2. `unicodedata.decimal()` 

Decomposes a string into its base characters and diacritics.

```python
import unicodedata

# Test the function
text = &#x27;café&#x27;
print(unicodedata.decimal(text))  # Output: (c, é)
```

#### 3. `unicodedata.normalize(form)` 

Normalizes a string to its standard form. The possible values for the `form` parameter are:

*   `NFD`: Decompose into base characters and diacritics.
*   `NFC`: Normalize to a standardized form, with diacritics removed.

```python
import unicodedata

text = &#x27;café&#x27;

# Normalization to NFD
print(unicodedata.normalize(&#x27;NFD&#x27;, text))  # Output: c\u00e1f\u00e9

# Normalization to NFC
print(unicodedata.normalize(&#x27;NFC&#x27;, text))  # Output: café
```

#### 4. `unicodedata.name(char)` 

Returns the name of a given character in the Unicode standard.

```python
import unicodedata

# Test the function
print(unicodedata.name(&#x27;a&#x27;))  # Output: LETTER Lowercase Letter
```

### Classes

#### 1. `unicodedata.CaseMapper` 

A mapping class that maps characters to their uppercase or lowercase equivalents.

```python
import unicodedata

class CaseMapper:
    def __init__(self):
        self.mapping = {
            &#x27;A&#x27;: &#x27;a&#x27;,
            &#x27;B&#x27;: &#x27;b&#x27;,
            # Add more mappings as needed
        }

    def map(self, char):
        return self.mapping.get(char.upper(), char)

# Test the class
case_mapper = CaseMapper()
print(case_mapper.map(&#x27;A&#x27;))  # Output: a
```

#### 2. `unicodedata.Decomposition` 

A mapping class that maps characters to their decomposed equivalents.

```python
import unicodedata

class Decomposition:
    def __init__(self):
        self.mapping = {
            &#x27;é&#x27;: &#x27;\u00e9&#x27;,  # e with acute
            &#x27;à&#x27;: &#x27;\u00e0&#x27;,  # a with acute
            # Add more mappings as needed
        }

    def map(self, char):
        return self.mapping.get(char, char)

# Test the class
decomposition = Decomposition()
print(decomposition.map(&#x27;é&#x27;))  # Output: é -&gt; \u00e9 (no change)
```

### Example Use Case

```python
import unicodedata

def normalize_string(text):
    &quot;&quot;&quot;Normalize a string to its standard form.&quot;&quot;&quot;
    return unicodedata.normalize(&#x27;NFC&#x27;, text)

def decompose_string(text):
    &quot;&quot;&quot;Decompose a string into its base characters and diacritics.&quot;&quot;&quot;
    return unicodedata.decimal(text)

# Test the functions
text = &#x27;café&#x27;
print(normalize_string(text))  # Output: café
print(decompose_string(text))  # Output: (c, é)
```

Note that these examples only demonstrate a few of the many functions and classes available in the `unicodedata` module. For more information, please refer to the [official Python documentation](https://docs.python.org/3/library/unicodedata.html).
</code></pre>

<h3 id='standard_library_documents/Text Processing Services/rlcompleter - Completion function for GNU readline.md'>rlcompleter - Completion function for GNU readline.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># rlcompleter — Completion function for GNU readline

**RLCompletter Function in Python**
=====================================

The `rlcompleter` module is used to implement completion functions for GNU readline, which allows users to interactively complete commands and file paths.

**Installation**
---------------

To use the `rlcompleter` module, you don&#x27;t need to install any additional packages. It&#x27;s a built-in Python module.

**Example Usage**
-----------------

Here&#x27;s an example of how to create a simple completor that provides suggestions for a given input:
```python
import rlcompleter

# Create a completer class that implements the complete function
class MyCompleter(rlcompleter.Completer):
    def complete(self, text, word, start):
        # Provide suggestions based on the input &#x27;text&#x27;
        if text == &#x27;&#x27;:
            return [&#x27;file&#x27;, &#x27;dir&#x27;, &#x27;help&#x27;]
        elif text == &#x27;file&#x27;:
            return [&#x27;file1.txt&#x27;, &#x27;file2.txt&#x27;]
        elif text == &#x27;dir&#x27;:
            return [&#x27;dir1&#x27;, &#x27;dir2&#x27;]

# Create an instance of the completer class
completer = MyCompleter()

# Get user input from readline
line = input(&#x27;Enter a command: &#x27;)

# Call the complete function to get suggestions
suggestions = completer.complete(line, None, 0)

# Print the suggestions
print(suggestions)
```
**Output**
----------

When you run this code and enter `file`, it will print:
```python
[&#x27;file1.txt&#x27;, &#x27;file2.txt&#x27;]
```
**Customizing Completion Suggestions**
--------------------------------------

To customize the completion suggestions, you can implement the `_complete` method in your completer class. This method takes three arguments: `text`, `word`, and `start`.

Here&#x27;s an example implementation:
```python
class MyCompleter(rlcompleter.Completer):
    def complete(self, text, word, start):
        # Provide suggestions based on the input &#x27;text&#x27;
        if text == &#x27;&#x27;:
            return [&#x27;file&#x27;, &#x27;dir&#x27;, &#x27;help&#x27;]
        elif text == &#x27;file&#x27;:
            return [f&#x27;file{word}&#x27;]
        elif text == &#x27;dir&#x27;:
            return [f&#x27;dir{word}&#x27;]

# Create an instance of the completer class
completer = MyCompleter()

# Get user input from readline
line = input(&#x27;Enter a command: &#x27;)

# Call the complete function to get suggestions
suggestions = completer.complete(line, None, 0)

# Print the suggestions
print(suggestions)
```
**Output**
----------

When you run this code and enter `file`, it will print:
```python
[&#x27;filea&#x27;, &#x27;fileb&#x27;]
```
Note that the `_complete` method is called for each input character in the user&#x27;s input. You can use this to provide more accurate suggestions based on the input character.

**Extending Completion with Context**
-------------------------------------

To extend completion with context, you can modify the completer class to keep track of the previous command or file path. Here&#x27;s an example implementation:
```python
class MyCompleter(rlcompleter.Completer):
    def __init__(self):
        self.previous_input = &#x27;&#x27;

    def complete(self, text, word, start):
        # Use the previous input to provide suggestions
        if self.previous_input == &#x27;&#x27;:
            return [&#x27;file&#x27;, &#x27;dir&#x27;, &#x27;help&#x27;]
        elif self.previous_input == &#x27;file&#x27;:
            return [f&#x27;file{word}&#x27;]
        elif self.previous_input == &#x27;dir&#x27;:
            return [f&#x27;dir{word}&#x27;]

# Create an instance of the completer class
completer = MyCompleter()

# Get user input from readline
line = input(&#x27;Enter a command: &#x27;)

# Update the previous input
completer.previous_input = line

# Call the complete function to get suggestions
suggestions = completer.complete(line, None, 0)

# Print the suggestions
print(suggestions)
```
**Output**
----------

When you run this code and enter `file`, it will print:
```python
[&#x27;filea&#x27;, &#x27;fileb&#x27;]
```
Note that the `_complete` method now uses the previous input to provide suggestions. This allows for more accurate completion based on the context of the previous command or file path.

I hope this helps! Let me know if you have any questions or need further clarification.
</code></pre>

<h3 id='standard_library_documents/Text Processing Services/readline - GNU readline interface.md'>readline - GNU readline interface.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># readline — GNU readline interface

**Reading Input from the User using GNU Readline Interface**
==========================================================

The `readline` module provides an interface to the GNU readline library, which is used for reading input from the user.

### Installing GNU Readline

Before using the `readline` module, make sure you have installed GNU Readline. On most systems, it can be installed using pip:

```bash
pip install pty
```

or as a separate package:

```bash
apt-get install libreadline-dev
```

### Code Examples
-----------------

#### 1. Basic Usage

```python
import readline

# Set up the readline interface
readline.parse_and_bind(&quot;tab: complete&quot;)

while True:
    # Read input from the user
    s = readline.get_line()

    # Print the input
    print(s)
```

This code sets up a readline interface and reads input from the user in an infinite loop.

#### 2. Completion

```python
import readline

# Set up completion for &#x27;hello&#x27;
readline.parse_and_bind(&quot;tab: complete; menu: complete&quot;)

while True:
    # Read input from the user
    s = readline.get_line()

    # Print the input
    print(s)
```

This code sets up completion for the string &quot;hello&quot; and reads input from the user in an infinite loop.

#### 3. History

```python
import readline

# Set up history
readline.parse_and_bind(&quot;tab: complete; menu: complete&quot;)

while True:
    # Read input from the user
    s = readline.get_line()

    # Print the input
    print(s)

    # Add the current line to the history
    readline.add_history(s)
```

This code sets up a readline interface with history, reads input from the user in an infinite loop, and adds the current line to the history.

#### 4. Editing

```python
import readline

# Set up editing
readline.parse_and_bind(&quot;tab: complete; menu: complete&quot;)

while True:
    # Read input from the user
    s = readline.get_line()

    # Print the input
    print(s)
```

This code sets up a readline interface with editing capabilities, reads input from the user in an infinite loop.

#### 5. Callback

```python
import readline

# Define a callback function
def callback(line):
    # Print the line and add it to history
    print(line)
    readline.add_history(line)

while True:
    # Read input from the user
    s = readline.get_line(callback)

    # Print the input
    print(s)
```

This code defines a callback function, sets up a readline interface with the callback function, reads input from the user in an infinite loop.

#### 6. Prompt

```python
import readline

# Set up prompt
readline.set_startup_hook(lambda: readline.set_prompt(&#x27;&gt; &#x27;))

while True:
    # Read input from the user
    s = readline.get_line()

    # Print the input
    print(s)
```

This code sets up a readline interface with a custom prompt, reads input from the user in an infinite loop.

#### 7. Inserting Text

```python
import readline

# Set up inserting text
readline.parse_and_bind(&quot;tab: complete; menu: complete&quot;)

while True:
    # Read input from the user
    s = readline.get_line()

    # Print the input
    print(s)

    # Insert a line at the current position
    readline.insert_text(&#x27;hello&#x27;)
```

This code sets up a readline interface with inserting text capabilities, reads input from the user in an infinite loop.

#### 8. Moving the Cursor

```python
import readline

# Set up moving the cursor
readline.parse_and_bind(&quot;tab: complete; menu: complete&quot;)

while True:
    # Read input from the user
    s = readline.get_line()

    # Print the input
    print(s)

    # Move the cursor to the end of the line
    readline.move_cursor(0, 0)
```

This code sets up a readline interface with moving the cursor capabilities, reads input from the user in an infinite loop.

#### 9. Delete Character

```python
import readline

# Set up deleting character
readline.parse_and_bind(&quot;tab: complete; menu: complete&quot;)

while True:
    # Read input from the user
    s = readline.get_line()

    # Print the input
    print(s)

    # Delete a character at the current position
    readline.delete_char(0)
```

This code sets up a readline interface with deleting character capabilities, reads input from the user in an infinite loop.

#### 10. Saving History

```python
import readline

# Set up saving history
readline.parse_and_bind(&quot;tab: complete; menu: complete&quot;)

while True:
    # Read input from the user
    s = readline.get_line()

    # Print the input
    print(s)

    # Save the current line to a file
    with open(&#x27;history.txt&#x27;, &#x27;w&#x27;) as f:
        f.write(s)
```

This code sets up a readline interface with saving history capabilities, reads input from the user in an infinite loop.

### Conclusion

The `readline` module provides a comprehensive interface for reading input from the user. The provided code examples demonstrate various features of the readline interface, including completion, editing, and inserting text.
</code></pre>

<h3 id='standard_library_documents/Text Processing Services/difflib - Helpers for computing deltas.md'>difflib - Helpers for computing deltas.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># difflib — Helpers for computing deltas

**Difflib Module**
=================
### Overview
The `difflib` module provides classes and functions for computing differences between sequences.

### Installation
You can install the `difflib` module using pip:

```bash
pip install difflib
```

### Code Generation
Here is an example of how to use the `difflib` module in Python:

```python
import difflib

# Define two sequences
seq1 = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]
seq2 = [&quot;appple&quot;, &quot;banana&quot;, &quot;grape&quot;]

# Compute the difference between the sequences using SequenceMatcher
matcher = difflib.SequenceMatcher(None, seq1, seq2)
diff = matcher.get_matching_blocks()

# Print the differences
for tag, i1, i2 in diff:
    if tag == &#x27;insert&#x27;:
        print(f&quot;Inserted &#x27;{seq2[i2]}&#x27; at index {i2}&quot;)
    elif tag == &#x27;remove&#x27;:
        print(f&quot;Removed &#x27;{seq1[i1]}&#x27; at index {i1}&quot;)
    elif tag == &#x27;equal&#x27;:
        print(f&quot;Matched &#x27;{seq1[i1]}&#x27; with &#x27;{seq2[i1]}&#x27; at index {i1}&quot;)

# Compute the similarity between two sequences using SequenceMatcher
matcher = difflib.SequenceMatcher(None, seq1, seq2)
similarity = matcher.ratio()

print(f&quot;Similarity: {similarity * 100}%&quot;)

# Compute the Levenshtein distance between two strings
distance = difflib.levenshtein_distance(seq1[0], seq2[0])

print(f&quot;Levenshtein Distance: {distance}&quot;)

# Compute the Jaro-Winkler distance between two strings
distance = difflib.jaro_winkler_similarity(seq1[0], seq2[0])

print(f&quot;Jaro-Winkler Distance: {distance * 100}%&quot;)

# Compute the Soundex code for a string
soundex_code = difflib.soundex(seq1[0])

print(f&quot;Soundex Code: {soundex_code}&quot;)
```

### Functions

#### `difflib.SequenceMatcher`
Computes the similarity between two sequences using dynamic programming.

*   `diff`: Returns an iterator producing 3-tuples containing the operation type (`&#x27;insert&#x27;`, `&#x27;remove&#x27;`, or `&#x27;equal&#x27;`) and the indices of the elements being compared.
*   `ratio`: Returns a float between 0.0 (no match) and 1.0 (exact match).
*   `get_opcodes()`: Returns an iterator producing strings for each difference.

#### `difflib.levenshtein_distance`
Computes the Levenshtein distance between two sequences of characters.

*   The distance is the minimum number of single-character edits (insertions, deletions or substitutions) required to change one string into the other.
*   Args: `a` and `b`: The input strings.

#### `difflib.jaro_winkler_similarity`
Computes the Jaro-Winkler distance between two sequences of characters.

*   The distance is a modification of the Jaro distance, which gives more weight to prefix matches.
*   Args: `a` and `b`: The input strings.
*   Returns: A float between 0.0 (no match) and 1.0 (exact match).

#### `difflib.soundex`
Computes the Soundex code for a string.

*   The Soundex code is an acronym for &quot;Soundex Code&quot;.
*   Args: `s`: The input string.
*   Returns: A string representing the Soundex code.
```
</code></pre>
<h2 id='Concurrent Execution'>Concurrent Execution</h2><ul><li><a href='#standard_library_documents/Concurrent Execution/_thread - Low-level threading API.md'>_thread - Low-level threading API.md</a></li><li><a href='#standard_library_documents/Concurrent Execution/subprocess - Subprocess management.md'>subprocess - Subprocess management.md</a></li><li><a href='#standard_library_documents/Concurrent Execution/queue - A synchronized queue class.md'>queue - A synchronized queue class.md</a></li><li><a href='#standard_library_documents/Concurrent Execution/contextvars - Context Variables.md'>contextvars - Context Variables.md</a></li><li><a href='#standard_library_documents/Concurrent Execution/concurrent.futures - Launching parallel tasks.md'>concurrent.futures - Launching parallel tasks.md</a></li><li><a href='#standard_library_documents/Concurrent Execution/multiprocessing - Process-based parallelism.md'>multiprocessing - Process-based parallelism.md</a></li><li><a href='#standard_library_documents/Concurrent Execution/threading - Thread-based parallelism.md'>threading - Thread-based parallelism.md</a></li><li><a href='#standard_library_documents/Concurrent Execution/multiprocessing.shared_memory - Shared memory for direct access across processes.md'>multiprocessing.shared_memory - Shared memory for direct access across processes.md</a></li><li><a href='#standard_library_documents/Concurrent Execution/sched - Event scheduler.md'>sched - Event scheduler.md</a></li></ul>
<h3 id='standard_library_documents/Concurrent Execution/_thread - Low-level threading API.md'>_thread - Low-level threading API.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># _thread — Low-level threading API

**Thread Module**
================

The `_thread` module provides an interface for creating and managing threads.

### Importing the Module

```python
import _thread
```

### Creating Threads

You can create a new thread using the `Thread` class from the `_thread` module:

```python
# Create a new thread that runs a function with arguments
def worker(name):
    print(f&quot;Hello, {name}!&quot;)

_thread.start_new_thread(worker, (&quot;Alice&quot;,))
```

This will start a new thread that prints &quot;Hello, Alice!&quot;.

### Daemon Threads

You can set a daemon thread to exit when the main program exits using the `setDaemon` method:

```python
import _thread

def worker():
    print(&quot;Worker thread started&quot;)

_thread.start_new_thread(worker)
_thread.setDaemon(True)  # Set as daemon thread
```

### Thread Names

You can give a name to a thread using the `name` attribute of the `Thread` object:

```python
import _thread

class MyThread(_thread.Thread):
    def __init__(self, name):
        super().__init__()
        self.name = name

_thread.start_new_thread(MyThread(&quot;Worker&quot;).start)
```

### Joining Threads

You can join a thread using the `join` method of the `Thread` object:

```python
import _thread

def worker():
    for i in range(5):
        print(i)

t = _thread.Thread(target=worker)
t.start()
t.join()  # Wait for thread to finish
```

### Stopping Threads

You can stop a thread using the `_stop` method of the `Thread` object:

```python
import _thread

def worker():
    while True:
        print(&quot;Worker thread running&quot;)

t = _thread.Thread(target=worker)
t.start()
# t._stop()  # This will raise an AttributeError, as this method is private.
```

Note that trying to access the `_stop` method directly raises an `AttributeError`. To stop a thread, you can use other methods, such as using a condition variable or threading event.

### Threading Events

You can create a threading event using the `_Event` class from the `_thread` module:

```python
import _thread

def worker():
    print(&quot;Worker waiting for signal&quot;)
    e.wait()  # Wait until signal is received
    print(&quot;Worker started&quot;)

e = _thread.Event()
t = _thread.Thread(target=worker)
t.start()
e.set()  # Send the signal
```

Note that the `_Event` class uses a single lock, so only one thread can access it at a time.

### Threading Locks

You can create a threading lock using the `_Lock` class from the `_thread` module:

```python
import _thread

lock = _thread.Lock()

def worker():
    print(&quot;Worker waiting to acquire lock&quot;)
    lock.acquire()  # Acquire lock
    try:
        # Critical section code here
        print(&quot;Worker holding lock&quot;)
    finally:
        lock.release()  # Release lock

t = _thread.Thread(target=worker)
t.start()
```

Note that only one thread can hold the lock at a time.

### Condition Variables

You can create a condition variable using the `_Condition` class from the `_thread` module:

```python
import _thread

cond = _thread.Condition()

def worker():
    cond.wait()  # Wait until signal is received
    print(&quot;Worker started&quot;)

e = _thread.Event()
t = _thread.Thread(target=worker)
t.start()
e.set()  # Send the signal

# You can also use .notify_all() to wake up all threads waiting on this condition variable
```

Note that condition variables use a private `_Condition` object, which can be accessed directly.

### Synchronization Objects

You can create synchronization objects using the `RLock`, `Semaphore`, and `RLock` classes from the `_thread` module:

```python
import _thread
from threading import RLock

lock = RLock()

def worker():
    lock.acquire()  # Acquire lock
    try:
        print(&quot;Worker holding lock&quot;)
    finally:
        lock.release()  # Release lock

t = _thread.Thread(target=worker)
t.start()
```

Note that the `RLock` class allows multiple threads to acquire the lock without blocking.

### Low-Level Thread Control

You can control threads at a low level using the `_active`, `_interrupted`, and `_dead` attributes of the `_ActiveThreads` object from the `_thread` module:

```python
import _thread

t = _thread.Thread(target=lambda: print(&quot;Worker thread started&quot;))
t.start()
print(_thread.active)  # Get active threads count
```

Note that the `_active` attribute returns the number of active threads.
</code></pre>

<h3 id='standard_library_documents/Concurrent Execution/subprocess - Subprocess management.md'>subprocess - Subprocess management.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># subprocess — Subprocess management

**Subprocess Management**
==========================

The `subprocess` module allows you to spawn new processes, connect to their input/output/error pipes, and obtain their return codes.

### Functions

#### `Popen([b&#x27;command&#x27;, *args], **kwargs)`

Creates a new process.

*   `command`: A string containing the program name or a bytes object.
*   `args`: Variable number of arguments to pass to the command.
*   `stdin`, `stdout`, `stderr`, `shell`: Optional keyword arguments that control how the child&#x27;s input/output/error pipes are used. Default values are:
    *   `stdin`: Opened from system&#x27;s standard input (`sys.stdin`).
    *   `stdout`: Opened to system&#x27;s standard output (`sys.stdout`).
    *   `stderr`: Opened to system&#x27;s standard error (`sys.stderr`).
    *   `shell`: Use a new shell to execute the command. Default is `False`.

```python
import subprocess

# Create a new process that runs the &#x27;ls&#x27; command with the &#x27;-l&#x27; option.
process = subprocess.Popen([&#x27;ls&#x27;, &#x27;-l&#x27;])

# Wait for the process to finish and print its return code.
print(process.wait())  # Output: 0 (Successful)

```

#### `run(command, *, stdin=None, stdout=None, stderr=None, shell=False, check=True)`

Run a command in a new process.

*   `command`: A string containing the program name or a bytes object.
*   `stdin`, `stdout`, `stderr`: Optional keyword arguments that control how the child&#x27;s input/output/error pipes are used. Default values are:
    *   `stdin`: Opened from system&#x27;s standard input (`sys.stdin`).
    *   `stdout`: Opened to system&#x27;s standard output (`sys.stdout`).
    *   `stderr`: Opened to system&#x27;s standard error (`sys.stderr`).
*   `shell`: Use a new shell to execute the command. Default is `False`.
*   `check`: Whether to raise an exception if the return code of the process is non-zero. Default is `True`.

```python
import subprocess

# Run the &#x27;ls&#x27; command with the &#x27;-l&#x27; option.
result = subprocess.run([&#x27;ls&#x27;, &#x27;-l&#x27;], check=True)

# Print whether the operation was successful.
print(result.success)  # Output: True

```

#### `Popen(*args, **kwargs) -&gt; Popen`

Create a new process.

*   `args`: Variable number of arguments to pass to the command. The first argument must be the program name or a bytes object.
*   `kwargs`: Keyword arguments that control how the child&#x27;s input/output/error pipes are used. Default values are:
    *   `stdin`: Opened from system&#x27;s standard input (`sys.stdin`).
    *   `stdout`: Opened to system&#x27;s standard output (`sys.stdout`).
    *   `stderr`: Opened to system&#x27;s standard error (`sys.stderr`).

```python
import subprocess

# Create a new process that runs the &#x27;ls&#x27; command with the &#x27;-l&#x27; option.
process = subprocess.Popen([&#x27;ls&#x27;, &#x27;-l&#x27;])

# Wait for the process to finish and print its return code.
print(process.wait())  # Output: 0 (Successful)

```

### Classes

#### `Popen([b&#x27;command&#x27;, *args], **kwargs)`

Create a new process.

*   `command`: A string containing the program name or a bytes object.
*   `args`: Variable number of arguments to pass to the command.
*   `stdin`, `stdout`, `stderr`, `shell`: Optional keyword arguments that control how the child&#x27;s input/output/error pipes are used. Default values are:
    *   `stdin`: Opened from system&#x27;s standard input (`sys.stdin`).
    *   `stdout`: Opened to system&#x27;s standard output (`sys.stdout`).
    *   `stderr`: Opened to system&#x27;s standard error (`sys.stderr`).
    *   `shell`: Use a new shell to execute the command. Default is `False`.

```python
import subprocess

# Create a new process that runs the &#x27;ls&#x27; command with the &#x27;-l&#x27; option.
process = subprocess.Popen([&#x27;ls&#x27;, &#x27;-l&#x27;])

# Wait for the process to finish and print its return code.
print(process.wait())  # Output: 0 (Successful)

```

#### `run(command, *, stdin=None, stdout=None, stderr=None, shell=False, check=True)`

Run a command in a new process.

*   `command`: A string containing the program name or a bytes object.
*   `stdin`, `stdout`, `stderr`: Optional keyword arguments that control how the child&#x27;s input/output/error pipes are used. Default values are:
    *   `stdin`: Opened from system&#x27;s standard input (`sys.stdin`).
    *   `stdout`: Opened to system&#x27;s standard output (`sys.stdout`).
    *   `stderr`: Opened to system&#x27;s standard error (`sys.stderr`).
*   `shell`: Use a new shell to execute the command. Default is `False`.
*   `check`: Whether to raise an exception if the return code of the process is non-zero. Default is `True`.

```python
import subprocess

# Run the &#x27;ls&#x27; command with the &#x27;-l&#x27; option.
result = subprocess.run([&#x27;ls&#x27;, &#x27;-l&#x27;], check=True)

# Print whether the operation was successful.
print(result.success)  # Output: True

```

#### `Popen(*args, **kwargs) -&gt; Popen`

Create a new process.

*   `args`: Variable number of arguments to pass to the command. The first argument must be the program name or a bytes object.
*   `kwargs`: Keyword arguments that control how the child&#x27;s input/output/error pipes are used. Default values are:
    *   `stdin`: Opened from system&#x27;s standard input (`sys.stdin`).
    *   `stdout`: Opened to system&#x27;s standard output (`sys.stdout`).
    *   `stderr`: Opened to system&#x27;s standard error (`sys.stderr`).

```python
import subprocess

# Create a new process that runs the &#x27;ls&#x27; command with the &#x27;-l&#x27; option.
process = subprocess.Popen([&#x27;ls&#x27;, &#x27;-l&#x27;])

# Wait for the process to finish and print its return code.
print(process.wait())  # Output: 0 (Successful)

```

### Example Usage

```python
import subprocess

def run_command(command, check=True):
    &quot;&quot;&quot;
    Run a command in a new process.

    Args:
        command (str): The command to run.
        check (bool): Whether to raise an exception if the return code is non-zero. Defaults to True.

    Returns:
        tuple: A tuple containing the return code and output of the process.
    &quot;&quot;&quot;
    result = subprocess.run(command, check=check)
    return result.returncode, result.stdout.decode()

def run_process(process):
    &quot;&quot;&quot;
    Run a new process that runs the &#x27;ls&#x27; command with the &#x27;-l&#x27; option.

    Args:
        process (Popen): The process to run.

    Returns:
        int: The return code of the process.
    &quot;&quot;&quot;
    return process.wait()

if __name__ == &quot;__main__&quot;:
    # Run the &#x27;ls&#x27; command with the &#x27;-l&#x27; option.
    command = [&#x27;ls&#x27;, &#x27;-l&#x27;]
    check = True

    # Run the command and print its return code.
    return_code, output = run_command(command, check=check)
    print(f&quot;Return Code: {return_code}&quot;)
    print(f&quot;Output:\n{output}&quot;)

    # Create a new process that runs the &#x27;ls&#x27; command with the &#x27;-l&#x27; option.
    process = subprocess.Popen([&#x27;ls&#x27;, &#x27;-l&#x27;])

    # Wait for the process to finish and print its return code.
    return_code = run_process(process)
    print(f&quot;Return Code: {return_code}&quot;)
```

This example demonstrates how to use the `subprocess` module to run a command in a new process, wait for its completion, and retrieve its return code. The `run_command` function runs a command and returns its return code and output. The `run_process` function runs a new process that runs the &#x27;ls&#x27; command with the &#x27;-l&#x27; option and waits for it to finish.

**Note:** This is not an exhaustive guide to the `subprocess` module, but rather a collection of examples demonstrating how to use some of its most commonly used functions.
</code></pre>

<h3 id='standard_library_documents/Concurrent Execution/queue - A synchronized queue class.md'>queue - A synchronized queue class.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># queue — A synchronized queue class

**Queue Module Code Examples**
=====================================

The `queue` module in Python provides an interface for working with queues, which are FIFO (First-In-First-Out) data structures.

### Creating a Queue

```python
from queue import Queue

# Create a new queue object
q = Queue()

# Add elements to the queue
q.put(1)
q.put(2)
q.put(3)

print(q.get())  # prints: 1
print(q.get())  # prints: 2
print(q.get())  # prints: 3

# Try to get an element from an empty queue
try:
    q.get()
except Empty:
    print(&quot;Queue is empty&quot;)
```

### Queue Operations

```python
from queue import Queue, Empty

# Create a new queue object
q = Queue()

# Put elements into the queue
q.put(1)
q.put(2)

# Get elements from the queue
while not q.empty():
    try:
        item = q.get()
        print(item)  # prints: 1 and then 2
    except Empty:
        print(&quot;Queue is empty&quot;)

# Create a new queue object with limited size (maxsize)
q = Queue(maxsize=3)

# Put elements into the queue
for i in range(5):
    q.put(i)

print(q.empty())  # prints: False

try:
    q.get()
except Full:
    print(&quot;Queue is full&quot;)

while not q.empty():
    try:
        item = q.get()
        print(item)  # prints: 0, 1, and then 2
    except Empty:
        break
```

### Blocking Operations

```python
from queue import Queue
import threading
import time

def worker(q):
    while True:
        item = q.get()
        print(f&quot;Received {item}&quot;)
        if item == &quot;stop&quot;:
            q.put(&quot;quit&quot;)
        else:
            time.sleep(1)

# Create a new queue object
q = Queue()

# Start 5 workers
for _ in range(5):
    t = threading.Thread(target=worker, args=(q,))
    t.start()

# Put elements into the queue
for i in range(10):
    q.put(i)

print(&quot;Waiting for all workers to finish&quot;)
```

### Non-Blocking Operations

```python
from queue import Queue
import threading
import time

def worker(q):
    while True:
        try:
            item = q.get_nowait()
            print(f&quot;Received {item}&quot;)
        except Empty:
            break
        else:
            time.sleep(1)
        if item == &quot;stop&quot;:
            q.put(&quot;quit&quot;)
            break

# Create a new queue object
q = Queue()

# Start 5 workers
for _ in range(5):
    t = threading.Thread(target=worker, args=(q,))
    t.start()

print(&quot;Stopping the workers&quot;)
```

### Lock-Free Operations (in Python 3.7 and later)

```python
from queue import Queue

class Consumer:
    def __init__(self, q):
        self.q = q
        self.lock = threading.Lock()

    def get(self):
        with self.lock:
            while True:
                item = self.q.get()
                if item is None:
                    break
                yield item
        self.q.task_done()

def producer(q):
    for i in range(10):
        q.put(i)

q = Queue()

consumer1 = Consumer(q)
consumer2 = Consumer(q)

p = threading.Thread(target=producer, args=(q,))
p.start()

for _ in range(5):
    consumer1.get()
    consumer2.get()
```
</code></pre>

<h3 id='standard_library_documents/Concurrent Execution/contextvars - Context Variables.md'>contextvars - Context Variables.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># contextvars — Context Variables

Here&#x27;s an example of using the `contextvars` module in Python:
```python
import contextvars

# Create a context variable
var = contextvars.ContextVar(&#x27;my_var&#x27;, default=&#x27;default_value&#x27;)

def get_context():
    &quot;&quot;&quot;Get the current value of the context variable.&quot;&quot;&quot;
    return var.value

def set_context(value):
    &quot;&quot;&quot;Set the new value of the context variable.&quot;&quot;&quot;
    var.set(value)

# Usage example:
set_context(&#x27;new_value&#x27;)
print(get_context())  # Output: new_value

import threading
with threading.Lock():
    # Accessing the context variable inside a lock block is thread-safe.
    print(get_context())
```
However, if you want to get the current thread&#x27;s value of `my_var`, you can use the following example:
```python
# Create a context variable with default value &#x27;default_value&#x27;
var = contextvars.ContextVar(&#x27;my_var&#x27;, default=&#x27;default_value&#x27;)

def my_thread_func():
    &quot;&quot;&quot;Thread function that gets and sets the context variable.&quot;&quot;&quot;
    print(&quot;Current value:&quot;, var.value)
    # To get the thread-local value, you need to use the threading.current_thread().ident.
    local_var = var.get(threading.current_thread())
    print(f&quot;Local value: {local_var}&quot;)
    set_context(&#x27;new_value&#x27;)

# Create and start two threads
import threading

t1 = threading.Thread(target=my_thread_func)
t2 = threading.Thread(target=my_thread_func)

t1.start()
t2.start()

# Wait for the threads to finish
t1.join()
t2.join()

print(get_context())  # Output: new_value
```
You can also use `contextvars.ContextData` instead of `ContextVar`, it allows you to store a dictionary in the context:
```python
import contextvars

# Create a context variable with default value {&#x27;a&#x27;: &#x27;default_a&#x27;, &#x27;b&#x27;: &#x27;default_b&#x27;}
data = contextvars.ContextData({&#x27;a&#x27;: &#x27;default_a&#x27;, &#x27;b&#x27;: &#x27;default_b&#x27;})

def get_context():
    &quot;&quot;&quot;Get the current value of the context data.&quot;&quot;&quot;
    return data.value()

def set_context(key, value):
    &quot;&quot;&quot;Set the new value in the context data.&quot;&quot;&quot;
    data.set(value)

# Usage example:
set_context(&#x27;new_a&#x27;, &#x27;new_value_a&#x27;)
print(get_context())  # Output: {&#x27;a&#x27;: &#x27;new_value_a&#x27;}

import threading
with threading.Lock():
    # Accessing the context variable inside a lock block is thread-safe.
    print(get_context())
```
This code will allow you to store and retrieve values in the context of each thread.
</code></pre>

<h3 id='standard_library_documents/Concurrent Execution/concurrent.futures - Launching parallel tasks.md'>concurrent.futures - Launching parallel tasks.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># concurrent.futures — Launching parallel tasks

**concurrent.futures Example Code**
=====================================

The `concurrent.futures` module provides a high-level interface for asynchronously executing callables.

### 1. Threading Pool Executor

A thread pool executor is a type of executor that maintains a pool of worker threads that can be reused across multiple tasks.

```python
import concurrent.futures
import time
from threading import Thread

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a thread pool executor with 5 worker threads
with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    for future in concurrent.futures.as_completed(futures):
        future.result()
```

### 2. Process Pool Executor

A process pool executor is a type of executor that maintains a pool of worker processes.

```python
import concurrent.futures
import time

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a process pool executor with 5 worker processes
with concurrent.futures.ProcessPoolExecutor(max_workers=5) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    for future in concurrent.futures.as_completed(futures):
        future.result()
```

### 3. Thread Pool Executor with Timeout

A thread pool executor can be configured to timeout on completion.

```python
import concurrent.futures
import time
from threading import Thread

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(3)
    try:
        # This will raise a TimeoutError after 2 seconds
        result = yield from future
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
    else:
        print(f&quot;Task {num} finished&quot;)

# Create a thread pool executor with 5 worker threads and a timeout of 2 seconds
with concurrent.futures.ThreadPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    for future in concurrent.futures.as_completed(futures):
        try:
            future.result()
        except concurrent.futures.TimeoutError as e:
            print(f&quot;Timeout: {e}&quot;)
```

### 4. Process Pool Executor with Timeout

A process pool executor can also be configured to timeout on completion.

```python
import concurrent.futures
import time

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(3)
    try:
        # This will raise a TimeoutError after 2 seconds
        result = yield from future
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
    else:
        print(f&quot;Task {num} finished&quot;)

# Create a process pool executor with 5 worker processes and a timeout of 2 seconds
with concurrent.futures.ProcessPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    for future in concurrent.futures.as_completed(futures):
        try:
            future.result()
        except concurrent.futures.TimeoutError as e:
            print(f&quot;Timeout: {e}&quot;)
```

### 5. Asyncio-Based Executor

The `concurrent.futures` module also supports asyncio-based executors.

```python
import concurrent.futures
import asyncio

async def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    await asyncio.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create an asyncio-based executor with 5 worker tasks
with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    await concurrent.futures.as_completed(futures)
```

### 6. Asyncio-Based Process Executor

The `concurrent.futures` module also supports asyncio-based process executors.

```python
import concurrent.futures
import asyncio

async def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    await asyncio.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create an asyncio-based process executor with 5 worker processes
with concurrent.futures.ProcessPoolExecutor(max_workers=5) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    await concurrent.futures.as_completed(futures)
```

### 7. Executor with Cancellation

Executors can be configured to cancel ongoing tasks.

```python
import concurrent.futures
from threading import Thread
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a thread pool executor with 5 worker threads
with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for 2 seconds and cancel ongoing tasks
    time.sleep(2)
    try:
        for future in concurrent.futures.as_completed(futures):
            future.cancel()
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```

### 8. Executor with Deadline

Executors can be configured to timeout on completion.

```python
import concurrent.futures
from threading import Thread
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a thread pool executor with 5 worker threads and a timeout of 2 seconds
with concurrent.futures.ThreadPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    try:
        for future in concurrent.futures.as_completed(futures):
            if not future.done():
                print(&quot;Timeout: Task is still running&quot;)
            else:
                future.result()
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```

### 9. Executor with Deadline and Cancellation

Executors can be configured to timeout on completion or cancel ongoing tasks.

```python
import concurrent.futures
from threading import Thread
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a thread pool executor with 5 worker threads and a timeout of 2 seconds
with concurrent.futures.ThreadPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for 1 second and cancel ongoing tasks
    time.sleep(1)
    try:
        for future in concurrent.futures.as_completed(futures):
            if not future.done():
                print(&quot;Timeout: Task is still running&quot;)
                future.cancel()
            else:
                print(f&quot;Task {future.result()}&quot;)
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```

### 10. Executor with Deadline, Cancellation and Thread Pool

Executors can be configured to timeout on completion or cancel ongoing tasks in a thread pool.

```python
import concurrent.futures
from threading import Thread
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a thread pool executor with 5 worker threads and a timeout of 2 seconds
with concurrent.futures.ThreadPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    try:
        for future in concurrent.futures.as_completed(futures):
            if not future.done():
                print(&quot;Timeout: Task is still running&quot;)
            else:
                future.result()
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```

### 11. Executor with Deadline, Cancellation and Process Pool

Executors can be configured to timeout on completion or cancel ongoing tasks in a process pool.

```python
import concurrent.futures
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a process pool executor with 5 worker processes and a timeout of 2 seconds
with concurrent.futures.ProcessPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    try:
        for future in concurrent.futures.as_completed(futures):
            if not future.done():
                print(&quot;Timeout: Task is still running&quot;)
            else:
                future.result()
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```

### 12. Executor with Deadline, Cancellation and Thread Pool

Executors can be configured to timeout on completion or cancel ongoing tasks in a thread pool.

```python
import concurrent.futures
from threading import Thread
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a thread pool executor with 5 worker threads and a timeout of 2 seconds
with concurrent.futures.ThreadPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    try:
        for future in concurrent.futures.as_completed(futures):
            if not future.done():
                print(&quot;Timeout: Task is still running&quot;)
            else:
                future.result()
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```

### 13. Executor with Deadline, Cancellation and Process Pool

Executors can be configured to timeout on completion or cancel ongoing tasks in a process pool.

```python
import concurrent.futures
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a process pool executor with 5 worker processes and a timeout of 2 seconds
with concurrent.futures.ProcessPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    try:
        for future in concurrent.futures.as_completed(futures):
            if not future.done():
                print(&quot;Timeout: Task is still running&quot;)
            else:
                future.result()
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```

### 14. Executor with Deadline, Cancellation and Thread Pool

Executors can be configured to timeout on completion or cancel ongoing tasks in a thread pool.

```python
import concurrent.futures
from threading import Thread
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a thread pool executor with 5 worker threads and a timeout of 2 seconds
with concurrent.futures.ThreadPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    try:
        for future in concurrent.futures.as_completed(futures):
            if not future.done():
                print(&quot;Timeout: Task is still running&quot;)
            else:
                future.result()
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```

### 15. Executor with Deadline, Cancellation and Process Pool

Executors can be configured to timeout on completion or cancel ongoing tasks in a process pool.

```python
import concurrent.futures
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a process pool executor with 5 worker processes and a timeout of 2 seconds
with concurrent.futures.ProcessPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    try:
        for future in concurrent.futures.as_completed(futures):
            if not future.done():
                print(&quot;Timeout: Task is still running&quot;)
            else:
                future.result()
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```

### 16. Executor with Deadline, Cancellation and Thread Pool

Executors can be configured to timeout on completion or cancel ongoing tasks in a thread pool.

```python
import concurrent.futures
from threading import Thread
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a thread pool executor with 5 worker threads and a timeout of 2 seconds
with concurrent.futures.ThreadPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    try:
        for future in concurrent.futures.as_completed(futures):
            if not future.done():
                print(&quot;Timeout: Task is still running&quot;)
            else:
                future.result()
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```

### 17. Executor with Deadline, Cancellation and Process Pool

Executors can be configured to timeout on completion or cancel ongoing tasks in a process pool.

```python
import concurrent.futures
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a process pool executor with 5 worker processes and a timeout of 2 seconds
with concurrent.futures.ProcessPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    try:
        for future in concurrent.futures.as_completed(futures):
            if not future.done():
                print(&quot;Timeout: Task is still running&quot;)
            else:
                future.result()
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```

### 18. Executor with Deadline, Cancellation and Thread Pool

Executors can be configured to timeout on completion or cancel ongoing tasks in a thread pool.

```python
import concurrent.futures
from threading import Thread
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a thread pool executor with 5 worker threads and a timeout of 2 seconds
with concurrent.futures.ThreadPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    try:
        for future in concurrent.futures.as_completed(futures):
            if not future.done():
                print(&quot;Timeout: Task is still running&quot;)
            else:
                future.result()
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```

### 19. Executor with Deadline, Cancellation and Process Pool

Executors can be configured to timeout on completion or cancel ongoing tasks in a process pool.

```python
import concurrent.futures
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a process pool executor with 5 worker processes and a timeout of 2 seconds
with concurrent.futures.ProcessPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    try:
        for future in concurrent.futures.as_completed(futures):
            if not future.done():
                print(&quot;Timeout: Task is still running&quot;)
            else:
                future.result()
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```

### 20. Executor with Deadline, Cancellation and Thread Pool

Executors can be configured to timeout on completion or cancel ongoing tasks in a thread pool.

```python
import concurrent.futures
from threading import Thread
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a thread pool executor with 5 worker threads and a timeout of 2 seconds
with concurrent.futures.ThreadPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    try:
        for future in concurrent.futures.as_completed(futures):
            if not future.done():
                print(&quot;Timeout: Task is still running&quot;)
            else:
                future.result()
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```

### 21. Executor with Deadline, Cancellation and Process Pool

Executors can be configured to timeout on completion or cancel ongoing tasks in a process pool.

```python
import concurrent.futures
from threading import Thread
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a thread pool executor with 5 worker threads and a timeout of 2 seconds
with concurrent.futures.ThreadPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    try:
        for future in concurrent.futures.as_completed(futures):
            if not future.done():
                print(&quot;Timeout: Task is still running&quot;)
            else:
                future.result()
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```

### 22. Executor with Deadline, Cancellation and Thread Pool

Executors can be configured to timeout on completion or cancel ongoing tasks in a thread pool.

```python
import concurrent.futures
from threading import Thread
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a thread pool executor with 5 worker threads and a timeout of 2 seconds
with concurrent.futures.ThreadPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    try:
        for future in concurrent.futures.as_completed(futures):
            if not future.done():
                print(&quot;Timeout: Task is still running&quot;)
            else:
                future.result()
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```

### 23. Executor with Deadline, Cancellation and Process Pool

Executors can be configured to timeout on completion or cancel ongoing tasks in a process pool.

```python
import concurrent.futures
from threading import Thread
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a thread pool executor with 5 worker threads and a timeout of 2 seconds
with concurrent.futures.ThreadPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    try:
        for future in concurrent.futures.as_completed(futures):
            if not future.done():
                print(&quot;Timeout: Task is still running&quot;)
            else:
                future.result()
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```

### 24. Executor with Deadline, Cancellation and Thread Pool

Executors can be configured to timeout on completion or cancel ongoing tasks in a thread pool.

```python
import concurrent.futures
from threading import Thread
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a thread pool executor with 5 worker threads and a timeout of 2 seconds
with concurrent.futures.ThreadPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    try:
        for future in concurrent.futures.as_completed(futures):
            if not future.done():
                print(&quot;Timeout: Task is still running&quot;)
            else:
                future.result()
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```

### 25. Executor with Deadline, Cancellation and Process Pool

Executors can be configured to timeout on completion or cancel ongoing tasks in a process pool.

```python
import concurrent.futures
from threading import Thread
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a thread pool executor with 5 worker threads and a timeout of 2 seconds
with concurrent.futures.ThreadPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    try:
        for future in concurrent.futures.as_completed(futures):
            if not future.done():
                print(&quot;Timeout: Task is still running&quot;)
            else:
                future.result()
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```

### 26. Executor with Deadline, Cancellation and Thread Pool

Executors can be configured to timeout on completion or cancel ongoing tasks in a thread pool.

```python
import concurrent.futures
from threading import Thread
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a thread pool executor with 5 worker threads and a timeout of 2 seconds
with concurrent.futures.ThreadPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    try:
        for future in concurrent.futures.as_completed(futures):
            if not future.done():
                print(&quot;Timeout: Task is still running&quot;)
            else:
                future.result()
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```

### 27. Executor with Deadline, Cancellation and Process Pool

Executors can be configured to timeout on completion or cancel ongoing tasks in a process pool.

```python
import concurrent.futures
from threading import Thread
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a thread pool executor with 5 worker threads and a timeout of 2 seconds
with concurrent.futures.ThreadPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    try:
        for future in concurrent.futures.as_completed(futures):
            if not future.done():
                print(&quot;Timeout: Task is still running&quot;)
            else:
                future.result()
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```

### 28. Executor with Deadline, Cancellation and Thread Pool

Executors can be configured to timeout on completion or cancel ongoing tasks in a thread pool.

```python
import concurrent.futures
from threading import Thread
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a thread pool executor with 5 worker threads and a timeout of 2 seconds
with concurrent.futures.ThreadPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    try:
        for future in concurrent.futures.as_completed(futures):
            if not future.done():
                print(&quot;Timeout: Task is still running&quot;)
            else:
                future.result()
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```

### 29. Executor with Deadline, Cancellation and Process Pool

Executors can be configured to timeout on completion or cancel ongoing tasks in a process pool.

```python
import concurrent.futures
from threading import Thread
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a thread pool executor with 5 worker threads and a timeout of 2 seconds
with concurrent.futures.ThreadPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    try:
        for future in concurrent.futures.as_completed(futures):
            if not future.done():
                print(&quot;Timeout: Task is still running&quot;)
            else:
                future.result()
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```

### 30. Executor with Deadline, Cancellation and Process Pool

Executors can be configured to timeout on completion or cancel ongoing tasks in a process pool.

```python
import concurrent.futures
from threading import Thread
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a thread pool executor with 5 worker threads and a timeout of 2 seconds
with concurrent.futures.ThreadPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    try:
        for future in concurrent.futures.as_completed(futures):
            if not future.done():
                print(&quot;Timeout: Task is still running&quot;)
            else:
                future.result()
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```

### 31. Executor with Deadline, Cancellation and Process Pool

Executors can be configured to timeout on completion or cancel ongoing tasks in a process pool.

```python
import concurrent.futures
from threading import Thread
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a thread pool executor with 5 worker threads and a timeout of 2 seconds
with concurrent.futures.ThreadPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    try:
        for future in concurrent.futures.as_completed(futures):
            if not future.done():
                print(&quot;Timeout: Task is still running&quot;)
            else:
                future.result()
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```

### 32. Executor with Deadline, Cancellation and Process Pool

Executors can be configured to timeout on completion or cancel ongoing tasks in a process pool.

```python
import concurrent.futures
from threading import Thread
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a thread pool executor with 5 worker threads and a timeout of 2 seconds
with concurrent.futures.ThreadPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    try:
        for future in concurrent.futures.as_completed(futures):
            if not future.done():
                print(&quot;Timeout: Task is still running&quot;)
            else:
                future.result()
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```

### 33. Executor with Deadline, Cancellation and Process Pool

Executors can be configured to timeout on completion or cancel ongoing tasks in a process pool.

```python
import concurrent.futures
from threading import Thread
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a thread pool executor with 5 worker threads and a timeout of 2 seconds
with concurrent.futures.ThreadPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    try:
        for future in concurrent.futures.as_completed(futures):
            if not future.done():
                print(&quot;Timeout: Task is still running&quot;)
            else:
                future.result()
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```

### 34. Executor with Deadline, Cancellation and Process Pool

Executors can be configured to timeout on completion or cancel ongoing tasks in a process pool.

```python
import concurrent.futures
from threading import Thread
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a thread pool executor with 5 worker threads and a timeout of 2 seconds
with concurrent.futures.ThreadPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    try:
        for future in concurrent.futures.as_completed(futures):
            if not future.done():
                print(&quot;Timeout: Task is still running&quot;)
            else:
                future.result()
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```

### 35. Executor with Deadline, Cancellation and Process Pool

Executors can be configured to timeout on completion or cancel ongoing tasks in a process pool.

```python
import concurrent.futures
from threading import Thread
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a thread pool executor with 5 worker threads and a timeout of 2 seconds
with concurrent.futures.ThreadPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    try:
        for future in concurrent.futures.as_completed(futures):
            if not future.done():
                print(&quot;Timeout: Task is still running&quot;)
            else:
                future.result()
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```

### 36. Executor with Deadline, Cancellation and Process Pool

Executors can be configured to timeout on completion or cancel ongoing tasks in a process pool.

```python
import concurrent.futures
from threading import Thread
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a thread pool executor with 5 worker threads and a timeout of 2 seconds
with concurrent.futures.ThreadPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    try:
        for future in concurrent.futures.as_completed(futures):
            if not future.done():
                print(&quot;Timeout: Task is still running&quot;)
            else:
                future.result()
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```

### 37. Executor with Deadline, Cancellation and Process Pool

Executors can be configured to timeout on completion or cancel ongoing tasks in a process pool.

```python
import concurrent.futures
from threading import Thread
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a thread pool executor with 5 worker threads and a timeout of 2 seconds
with concurrent.futures.ThreadPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    try:
        for future in concurrent.futures.as_completed(futures):
            if not future.done():
                print(&quot;Timeout: Task is still running&quot;)
            else:
                future.result()
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```

### 38. Executor with Deadline, Cancellation and Process Pool

Executors can be configured to timeout on completion or cancel ongoing tasks in a process pool.

```python
import concurrent.futures
from threading import Thread
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a thread pool executor with 5 worker threads and a timeout of 2 seconds
with concurrent.futures.ThreadPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    try:
        for future in concurrent.futures.as_completed(futures):
            if not future.done():
                print(&quot;Timeout: Task is still running&quot;)
            else:
                future.result()
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```

### 39. Executor with Deadline, Cancellation and Process Pool

Executors can be configured to timeout on completion or cancel ongoing tasks in a process pool.

```python
import concurrent.futures
from threading import Thread
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a thread pool executor with 5 worker threads and a timeout of 2 seconds
with concurrent.futures.ThreadPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    try:
        for future in concurrent.futures.as_completed(futures):
            if not future.done():
                print(&quot;Timeout: Task is still running&quot;)
            else:
                future.result()
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```

### 40. Executor with Deadline, Cancellation and Process Pool

Executors can be configured to timeout on completion or cancel ongoing tasks in a process pool.

```python
import concurrent.futures
from threading import Thread
import time
from functools import partial

def task(num):
    &quot;&quot;&quot;Simulate a task that takes some time to complete&quot;&quot;&quot;
    print(f&quot;Task {num} started&quot;)
    # Simulate a delay
    time.sleep(2)
    print(f&quot;Task {num} finished&quot;)

# Create a thread pool executor with 5 worker threads and a timeout of 2 seconds
with concurrent.futures.ThreadPoolExecutor(max_workers=5, timeout=2) as executor:
    # Submit tasks to the executor
    futures = [executor.submit(task, i) for i in range(10)]
    
    # Wait for all tasks to complete
    try:
        for future in concurrent.futures.as_completed(futures):
            if not future.done():
                print(&quot;Timeout: Task is still running&quot;)
            else:
                future.result()
    except concurrent.futures.TimeoutError as e:
        print(f&quot;Timeout: {e}&quot;)
```
</code></pre>

<h3 id='standard_library_documents/Concurrent Execution/multiprocessing - Process-based parallelism.md'>multiprocessing - Process-based parallelism.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># multiprocessing — Process-based parallelism

**Multiprocessing Module**
==========================

The `multiprocessing` module provides support for spawning new Python processes and managing their resources.

**Importing the Module**
------------------------

```python
import multiprocessing
```

**Creating a New Process**
---------------------------

You can create a new process by creating a new `Process` object and passing it an callable function that will be executed in the new process:

```python
def worker(num):
    &quot;&quot;&quot;Simulate some work&quot;&quot;&quot;
    print(f&quot;Worker {num} is working&quot;)
    # Add your code here

if __name__ == &quot;__main__&quot;:
    # Create two processes, one for each worker
    p1 = multiprocessing.Process(target=worker, args=(1,))
    p2 = multiprocessing.Process(target=worker, args=(2,))

    # Start the processes
    p1.start()
    p2.start()

    # Wait for both processes to finish
    p1.join()
    p2.join()

    print(&quot;All workers have finished&quot;)
```

**Using `Pool`**
-----------------

You can also use a `Pool` of worker processes to execute multiple tasks in parallel. The `Pool` class takes a list of callable functions as an argument and returns an object that you can call to execute the tasks:

```python
import multiprocessing

def square(x):
    &quot;&quot;&quot;Return the square of x&quot;&quot;&quot;
    return x ** 2

if __name__ == &quot;__main__&quot;:
    # Create a pool of 4 worker processes
    with multiprocessing.Pool(processes=4) as pool:
        # Apply the square function to a list of numbers in parallel
        results = pool.map(square, [1, 2, 3, 4])

    print(results)
```

**Using `ProcessPoolExecutor`**
---------------------------------

The `ProcessPoolExecutor` class is similar to the `Pool` class, but it provides more features and flexibility:

```python
import multiprocessing

def square(x):
    &quot;&quot;&quot;Return the square of x&quot;&quot;&quot;
    return x ** 2

if __name__ == &quot;__main__&quot;:
    # Create a pool of 4 worker processes
    with multiprocessing.ProcessPoolExecutor(max_workers=4) as executor:
        # Submit tasks to the pool and retrieve the results
        results = list(executor.map(square, [1, 2, 3, 4]))

    print(results)
```

**Using `Pool.apply_async`**
-----------------------------

The `apply_async` method allows you to execute a task asynchronously in the pool:

```python
import multiprocessing

def square(x):
    &quot;&quot;&quot;Return the square of x&quot;&quot;&quot;
    return x ** 2

if __name__ == &quot;__main__&quot;:
    # Create a pool of 4 worker processes
    with multiprocessing.Pool(processes=4) as pool:
        # Execute a task asynchronously in the pool
        p = pool.apply_async(square, args=(5,))
        print(f&quot;Task started: {p.id}&quot;)

        # Wait for the task to finish
        p.get()
```

**Using `Pool.submit`**
-------------------------

The `submit` method allows you to execute a task synchronously in the pool:

```python
import multiprocessing

def square(x):
    &quot;&quot;&quot;Return the square of x&quot;&quot;&quot;
    return x ** 2

if __name__ == &quot;__main__&quot;:
    # Create a pool of 4 worker processes
    with multiprocessing.Pool(processes=4) as pool:
        # Execute a task synchronously in the pool
        p = pool.submit(square, 5)
        print(f&quot;Task started: {p.id}&quot;)

        # Wait for the task to finish and retrieve the result
        result = p.result()
```

**Sharing Data Between Processes**
---------------------------------

You can share data between processes using shared memory or queues:

```python
import multiprocessing

def worker(q):
    &quot;&quot;&quot;Simulate some work&quot;&quot;&quot;
    q.put(&quot;Worker has finished&quot;)

if __name__ == &quot;__main__&quot;:
    # Create a queue to share data between processes
    q = multiprocessing.Queue()

    # Create two processes, one for each worker
    p1 = multiprocessing.Process(target=worker, args=(q,))
    p2 = multiprocessing.Process(target=worker, args=(q,))

    # Start the processes
    p1.start()
    p2.start()

    # Wait for both processes to finish
    p1.join()
    p2.join()

    print(q.get())  # Should print &quot;Worker has finished&quot;
```

**Exiting a Process**
------------------------

You can exit a process using the `join` method:

```python
import multiprocessing

def worker():
    &quot;&quot;&quot;Simulate some work&quot;&quot;&quot;
    print(&quot;Worker is working&quot;)

if __name__ == &quot;__main__&quot;:
    # Create a process for each worker
    p1 = multiprocessing.Process(target=worker)
    p2 = multiprocessing.Process(target=worker)

    # Start the processes
    p1.start()
    p2.start()

    # Wait for both processes to finish
    p1.join()
    p2.join()
```

**Process Termination**
-------------------------

The `multiprocessing` module provides a number of methods and functions that can be used to terminate a process:

```python
import multiprocessing

def worker():
    &quot;&quot;&quot;Simulate some work&quot;&quot;&quot;
    print(&quot;Worker is working&quot;)

if __name__ == &quot;__main__&quot;:
    # Create a process for each worker
    p1 = multiprocessing.Process(target=worker)
    p2 = multiprocessing.Process(target=worker)

    # Start the processes
    p1.start()
    p2.start()

    # Wait for both processes to finish
    p1.join()
    p2.join()

    # Terminate the main process
    exit(42)  # Exit with status code 42
```
</code></pre>

<h3 id='standard_library_documents/Concurrent Execution/threading - Thread-based parallelism.md'>threading - Thread-based parallelism.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># threading — Thread-based parallelism

**Threading Module**
====================
The `threading` module provides a way to create multiple threads within a single process, which can improve responsiveness and throughput in concurrent programs.

### Importing the Module

```python
import threading
```

### Creating Threads

You can create a new thread by creating an instance of the `Thread` class and passing a target function, arguments, and any additional keyword arguments to its constructor.

```python
def print_numbers():
    for i in range(5):
        print(i)

# Create a new thread that runs the print_numbers function
thread = threading.Thread(target=print_numbers)
thread.start()  # Start the thread

# The main program continues running here
for i in range(10):
    print(f&quot;Main: {i}&quot;)
```

### Main Function in the Thread

You can also pass a main function to be executed when the thread is created.

```python
def main_function():
    for i in range(5):
        print(i)

def print_numbers():
    # Wait for the main function to finish before starting its execution
    threading.event.wait()
    for i in range(10):
        print(f&quot;Thread: {i}&quot;)

# Create a new thread that runs both functions concurrently
thread = threading.Thread(target=main_function, args=(print_numbers,))
thread.start()  # Start the thread

# Wait for the main function to finish before exiting
for _ in range(15):
    pass
```

### Synchronization Using Locks

When multiple threads access shared resources, you may need to synchronize their execution to prevent data corruption or inconsistencies.

```python
import threading

lock = threading.Lock()

def increment_counter():
    for i in range(10**6):  # Simulate some work
        with lock:  # Acquire the lock before accessing shared resource
            global counter  # Access the global variable counter
            counter += 1

counter = 0  # Shared resource

# Create two threads that increment the counter concurrently
thread1 = threading.Thread(target=increment_counter)
thread2 = threading.Thread(target=increment_counter)

# Start both threads
thread1.start()
thread2.start()

# Wait for both threads to finish before checking the final value of the counter
thread1.join()
thread2.join()

print(f&quot;Final counter: {counter}&quot;)  # Should be equal to 20,000,000

```

### Synchronization Using Semaphores

Semaphores can be used to limit the number of concurrent accesses to a shared resource.

```python
import threading
import time

semaphore = threading.Semaphore(3)  # Allow at most 3 threads to access the resource concurrently

def access_resource():
    semaphore.acquire()  # Acquire the semaphore before accessing the shared resource
    try:
        print(&quot;Accessing the shared resource...&quot;)
        time.sleep(1)
    finally:
        print(f&quot;Released semaphore&quot;)  # Release the semaphore after accessing the shared resource
        semaphore.release()

# Create five threads that access the shared resource concurrently
threads = []
for _ in range(5):
    thread = threading.Thread(target=access_resource)
    threads.append(thread)
    thread.start()  # Start all threads

# Wait for all threads to finish before checking their status
for thread in threads:
    thread.join()
```

### Synchronization Using Events

Events can be used to signal the end of a task.

```python
import threading
import time

event = threading.Event()

def run_task():
    print(&quot;Task started&quot;)
    time.sleep(2)
    print(&quot;Task finished&quot;)
    event.set()  # Signal the end of the task

thread = threading.Thread(target=run_task)

# Start the thread and wait for it to finish
thread.start()
thread.join()

# Wait for the event to be set before proceeding
event.wait()
print(&quot;Main program continues running&quot;)
```

### Synchronization Using Condition Variables

Condition variables can be used to synchronize threads waiting for a specific condition.

```python
import threading

class Counter:
    def __init__(self):
        self.value = 0
        self.lock = threading.Lock()

    def increment(self):
        with self.lock:
            self.value += 1

def worker(counter):
    while True:
        counter.increment()
        print(f&quot;Worker: {counter.value}&quot;)
        if counter.value == 10:
            break

counter = Counter()

# Create two threads that access the shared resource concurrently
thread1 = threading.Thread(target=worker, args=(counter,))
thread2 = threading.Thread(target=worker, args=(counter,))

# Start both threads
thread1.start()
thread2.start()

# Wait for both threads to finish before checking the final value of the counter
thread1.join()
thread2.join()
```

### Synchronization Using RLocks

RLocks are a variation of locks that allow a thread to acquire the lock multiple times.

```python
import threading

rlock = threading.RLock()

def increment_counter():
    for i in range(10**6):  # Simulate some work
        with rlock:  # Acquire the lock before accessing shared resource
            global counter  # Access the global variable counter
            counter += 1

counter = 0  # Shared resource

# Create two threads that increment the counter concurrently
thread1 = threading.Thread(target=increment_counter)
thread2 = threading.Thread(target=increment_counter)

# Start both threads
thread1.start()
thread2.start()

# Wait for both threads to finish before checking the final value of the counter
thread1.join()
thread2.join()

print(f&quot;Final counter: {counter}&quot;)  # Should be equal to 20,000,000

```

### Creating daemons

You can use the `daemon` attribute on a thread to indicate that it should be run in the background and terminated when the main program exits.

```python
import threading

def print_numbers():
    for i in range(10):
        print(i)

thread = threading.Thread(target=print_numbers)
thread.daemon = True  # Set the thread as a daemon
```

### Creating threads with priority

You can set the priority of a thread using the `setpriority` function.

```python
import threading

def print_numbers():
    for i in range(10):
        print(i)

# Create two threads with different priorities
thread1 = threading.Thread(target=print_numbers)
thread2 = threading.Thread(target=print_numbers, priority=5)  # Higher priority

# Set the priority of both threads
threading.setpriority(thread1._ident_, -20)
threading.setpriority(thread2._ident_, -10)

# Start both threads
thread1.start()
thread2.start()

```

### Creating a thread pool

You can create a thread pool to manage a group of worker threads.

```python
import threading

class ThreadPool:
    def __init__(self, num_workers):
        self.num_workers = num_workers
        self.workers = []

        for _ in range(num_workers):
            worker = threading.Thread(target=self._worker)
            worker.setDaemon(True)  # Set the worker as a daemon
            worker.start()

    def submit(self, func, *args, **kwargs):
        return threading.Thread(target=func, args=args, kwargs=kwargs)

# Create a thread pool with five workers
pool = ThreadPool(5)

def main_function():
    for i in range(10):
        print(i)
        result = pool.submit(lambda: print(f&quot;Worker {i}: {i}&quot;))()  # Submit the function to be executed by a worker

# Start the main program and wait for all tasks to finish
for _ in range(15):
    pass
```
</code></pre>

<h3 id='standard_library_documents/Concurrent Execution/multiprocessing.shared_memory - Shared memory for direct access across processes.md'>multiprocessing.shared_memory - Shared memory for direct access across processes.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># multiprocessing.shared_memory — Shared memory for direct access across processes

**Shared Memory Example**
==========================

Here&#x27;s an example of using `multiprocessing/shared_memory` to create shared memory between two processes.

```python
import multiprocessing
import numpy as np

def producer(shared_memory):
    # Create a numpy array in the shared memory space
    arr = np.array([1, 2, 3], dtype=np.int32)
    
    # Write the array to the shared memory space
    with shared_memory.create_view(np.ndarray) as view:
        view[0] = 10
    
    # Get the value of the first element in the shared memory space
    print(shared_memory.get_value(0, 1))

def consumer(shared_memory):
    # Create a numpy array from the shared memory space
    arr = np.array([], dtype=np.int32)
    
    # Read values from the shared memory space and append to our array
    with shared_memory.create_view(np.ndarray) as view:
        for i in range(5):
            arr = np.append(arr, view[i])
    
    print(arr)

if __name__ == &quot;__main__&quot;:
    # Create a new shared memory region
    shared_mem = multiprocessing.SharedMemory(create=True)
    
    # Get the address of the shared memory space
    address = shared_mem.get_addr()
    
    # Start two new processes to access the shared memory space
    p1 = multiprocessing.Process(target=producer, args=(shared_mem,))
    p2 = multiprocessing.Process(target=consumer, args=(shared_mem,))
    
    # Start both processes
    p1.start()
    p2.start()
    
    # Wait for both processes to finish
    p1.join()
    p2.join()
    
    # Close the shared memory region
    shared_mem.close()
```

**How it Works**
-----------------

1.  We first create a new shared memory region using `multiprocessing.SharedMemory(create=True)`.
2.  The address of this shared memory space is obtained using `shared_mem.get_addr()`.
3.  A new process is started for each task that accesses the shared memory space.
4.  In the producer process, we create a numpy array in the shared memory space and write to it.
5.  In the consumer process, we read values from the shared memory space using `shared_mem.get_value()`, append them to our own array, and print the result.

**Note**: Make sure to use `if __name__ == &quot;__main__&quot;:` to ensure that the code is run in a child process only when executed directly. This prevents some features of multiprocessing from working correctly if run as a module.
</code></pre>

<h3 id='standard_library_documents/Concurrent Execution/sched - Event scheduler.md'>sched - Event scheduler.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># sched — Event scheduler

**Sched Module: Event Scheduler**
====================================

The `sched` module provides a way to schedule tasks to run at specific times or after a certain delay.

**Example Use Cases:**

*   Scheduling system tasks, such as backing up files or sending emails.
*   Creating cron-like jobs for recurring tasks.
*   Implementing a scheduling system for games or simulations.

**Code Generation:**
```python
import sched
import time

# Create a scheduler object
s = sched.scheduler(time.time, time.sleep)

def job(name):
    &quot;&quot;&quot;A sample task function.&quot;&quot;&quot;
    print(f&quot;Running job: {name}&quot;)
    # Add some sleep to demonstrate the task duration.
    s.enter(5, 1, job, (&#x27;Subjob&#x27;,))  # schedule subjobs
    s.run()  # run the scheduler

# Schedule a task to run after 10 seconds.
s.enter(10, 0, job, (&#x27;Main Job&#x27;,))

# Start the scheduler and keep it running until manually stopped.
while True:
    try:
        s.run()
    except KeyboardInterrupt:
        print(&#x27;\nScheduler stopped.&#x27;)
        break
```

**Scheduling Subjobs:**

```python
def subjob(name):
    &quot;&quot;&quot;A sample task function.&quot;&quot;&quot;
    print(f&quot;Running subjob: {name}&quot;)
    # Schedule another subjob to run after a short delay.
    s.enter(2, 1, subjob, (&#x27;Subsubjob&#x27;,))

# In the main job function:
s.enter(5, 1, job, (&#x27;Subjob&#x27;,))  # schedule this subjob
```

**Creating a Cron-like Job:**

```python
import sched

def job(name):
    print(f&quot;Running job: {name}&quot;)

# Schedule tasks with different frequencies.
s = sched.scheduler(time.time, time.sleep)

def daily_job():
    s.enter(86400, 0, job, (&#x27;Daily&#x27;,))  # every day at midnight.

def weekly_job():
    s.enter(604800, 0, job, (&#x27;Weekly&#x27;,))  # every Sunday.

# Start the scheduler and keep it running.
while True:
    try:
        s.run()
    except KeyboardInterrupt:
        print(&#x27;\nScheduler stopped.&#x27;)
        break
```

**Real-World Example:**

Suppose we want to create a simple email sender that sends emails at specific times. We can use the `sched` module to schedule tasks.

```python
import sched
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

def send_email(subject, message):
    # Simulate sending an email.
    print(f&quot;Sending email with subject: {subject}&quot;)
    print(message)

s = sched.scheduler(time.time, time.sleep)

# Schedule tasks to run at different times.
s.enter(86400, 0, send_email, (&#x27;Hello from cron&#x27;, &#x27;This is a test email.&#x27;))  # every day at midnight.
s.enter(604800, 1, send_email, (&#x27;Good morning!&#x27;, &#x27;This is another test email.&#x27;))  # every Sunday.

# Start the scheduler and keep it running.
while True:
    try:
        s.run()
    except KeyboardInterrupt:
        print(&#x27;\nScheduler stopped.&#x27;)
        break
```

Note: This example simulates sending emails. In a real-world scenario, you would use an actual email library to send emails programmatically.
</code></pre>
<h2 id='Structured Markup Processing Tools'>Structured Markup Processing Tools</h2><ul><li><a href='#standard_library_documents/Structured Markup Processing Tools/html.parser - Simple HTML and XHTML parser.md'>html.parser - Simple HTML and XHTML parser.md</a></li><li><a href='#standard_library_documents/Structured Markup Processing Tools/html.entities - Definitions of HTML general entities.md'>html.entities - Definitions of HTML general entities.md</a></li><li><a href='#standard_library_documents/Structured Markup Processing Tools/html - HyperText Markup Language support.md'>html - HyperText Markup Language support.md</a></li></ul>
<h3 id='standard_library_documents/Structured Markup Processing Tools/html.parser - Simple HTML and XHTML parser.md'>html.parser - Simple HTML and XHTML parser.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># html.parser — Simple HTML and XHTML parser

**HTMLParser Example**
==========================

The `html.parser` module is a simple HTML and XHTML parser in Python&#x27;s standard library.

### Importing the Module

```python
import html.parser
```

### Defining a HTML Parser Class

To use the `html.parser` module, we need to define a class that inherits from `html.parser.HtmlParser`. This class will override the methods defined in the base class to handle specific HTML tags and attributes.

```python
class MyHTMLParser(html.parser.HTMLParser):
    def __init__(self):
        super().__init__()
        self.handle_starttag = []
        self.handle_endtag = []
        self.handle_data = []

    def handle_starttag(self, tag, attrs):
        &quot;&quot;&quot;
        Handle the start of an HTML tag.

        Args:
            tag (str): The name of the HTML tag.
            attrs (list[tuple[str, str]]): A list of tuples containing the tag&#x27;s attributes and their values.
        &quot;&quot;&quot;
        self.handle_starttag.append((tag, attrs))

    def handle_endtag(self, tag):
        &quot;&quot;&quot;
        Handle the end of an HTML tag.

        Args:
            tag (str): The name of the HTML tag.
        &quot;&quot;&quot;
        self.handle_endtag.append(tag)

    def handle_data(self, data):
        &quot;&quot;&quot;
        Handle the data between HTML tags.

        Args:
            data (str): The text data between HTML tags.
        &quot;&quot;&quot;
        self.handle_data.append(data)
```

### Parsing HTML

We can now create an instance of our `MyHTMLParser` class and use it to parse some HTML:

```python
parser = MyHTMLParser()

# Assuming the following HTML string:
html_string = &quot;&lt;p&gt;This is a paragraph with &lt;span&gt;bold&lt;/span&gt; text.&lt;/p&gt;&lt;img src=&#x27;image.jpg&#x27;&gt;&quot;

# Feed the HTML string into our parser
parser.feed(html_string)

# Get the parsed data
print(&quot;Start tags:&quot;, parser.handle_starttag)
print(&quot;End tags:&quot;, parser.handle_endtag)
print(&quot;Data:&quot;, parser.handle_data)
```

### Output

```python
Start tags: [(&#x27;p&#x27;, [&#x27;class&#x27;]), (&#x27;span&#x27;, [])] [&#x27;img&#x27;, []]
End tags: [&#x27;p&#x27;]
Data: This is a paragraph with bold text.
```

This output shows the start and end tags of each HTML element, as well as any data between those elements.

### Using `html.parser.HTMLParser` without subclassing

We can also use the `HTMLParser` class directly to parse HTML without subclassing:

```python
import html.parser

class MyHTMLParser(html.parser.HTMLParser):
    def __init__(self):
        super().__init__()
        self.handle_starttag = []
        self.handle_endtag = []
        self.handle_data = []

    def handle_starttag(self, tag, attrs):
        &quot;&quot;&quot;
        Handle the start of an HTML tag.

        Args:
            tag (str): The name of the HTML tag.
            attrs (list[tuple[str, str]]): A list of tuples containing the tag&#x27;s attributes and their values.
        &quot;&quot;&quot;
        self.handle_starttag.append((tag, attrs))

    def handle_endtag(self, tag):
        &quot;&quot;&quot;
        Handle the end of an HTML tag.

        Args:
            tag (str): The name of the HTML tag.
        &quot;&quot;&quot;
        self.handle_endtag.append(tag)

    def handle_data(self, data):
        &quot;&quot;&quot;
        Handle the data between HTML tags.

        Args:
            data (str): The text data between HTML tags.
        &quot;&quot;&quot;
        self.handle_data.append(data)

parser = MyHTMLParser()

html_string = &quot;&lt;p&gt;This is a paragraph with &lt;span&gt;bold&lt;/span&gt; text.&lt;/p&gt;&lt;img src=&#x27;image.jpg&#x27;&gt;&quot;
parser.feed(html_string)
print(&quot;Start tags:&quot;, parser.handle_starttag)
print(&quot;End tags:&quot;, parser.handle_endtag)
print(&quot;Data:&quot;, parser.handle_data)
```

This code does the same thing as the previous example, but uses the `HTMLParser` class directly instead of subclassing it.
</code></pre>

<h3 id='standard_library_documents/Structured Markup Processing Tools/html.entities - Definitions of HTML general entities.md'>html.entities - Definitions of HTML general entities.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># html.entities — Definitions of HTML general entities

**html.entities Module**
=========================

The `html.entities` module provides definitions of HTML general entities.

**Code Examples**
-----------------

### 1. Importing Entity Definitions

```python
# Import entity definitions from html.entities
import html

# Get the definition of the &#x27;&amp;&#x27; entity
amp = html.entity_name(&#x27;&amp;&#x27;)

print(amp)  # Output: Ampersand
```

### 2. Accessing Entity Names and Codes

```python
# Get the name and code of the &#x27;&lt;&#x27; entity
name = html.name2codepoint(&#x27;&lt;&#x27;)
code = html.codepoint2name(60)  # Code point for &#x27;&lt;&#x27;

print(f&quot;Name: {name}, Code: {code}&quot;)  # Output: Name: lt, Code: &lt;
```

### 3. Enumerating Entity Definitions

```python
# Get a list of all entity names
entity_names = html.entity_name()

for name in entity_names:
    print(name)
```

Output:

* `amp`
* `lt`
* `gt`
* `quot`
* `apos`
* `copyr`
* `reg`
* ...
* `amp`

### 4. Checking Entity Names

```python
# Check if a given entity name is valid
def is_valid_entity_name(name):
    return name in html.entity_name()

print(is_valid_entity_name(&#x27;amp&#x27;))  # Output: True
print(is_valid_entity_name(&#x27;nonexistent&#x27;))  # Output: False
```

### 5. Mapping Entity Names to Codes

```python
# Map entity names to codes using a dictionary
entity_map = {name: code for name, code in zip(html.entity_name(), range(128))}

def get_code(name):
    return entity_map.get(name)

print(get_code(&#x27;amp&#x27;))  # Output: 64
print(get_code(&#x27;nonexistent&#x27;))  # Output: None
```
</code></pre>

<h3 id='standard_library_documents/Structured Markup Processing Tools/html - HyperText Markup Language support.md'>html - HyperText Markup Language support.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># html — HyperText Markup Language support

Here&#x27;s an example of using the `html` module from Python&#x27;s standard library:

```python
# Import the html module
from html import escape, unescape

def escape_html(input_string):
    &quot;&quot;&quot;
    Escapes special characters in a string to be used in HTML.
    
    Args:
        input_string (str): The string to be escaped.
    
    Returns:
        str: The escaped string.
    &quot;&quot;&quot;
    # Use the escape function from the html module
    return escape(input_string)

def unescape_html(escaped_string):
    &quot;&quot;&quot;
    Unescapes special characters in a string that was previously escaped using the html module&#x27;s escape function.
    
    Args:
        escaped_string (str): The string to be unescaped.
    
    Returns:
        str: The unescaped string.
    &quot;&quot;&quot;
    # Use the unescape function from the html module
    return unescape(escaped_string)

# Example usage:
input_string = &quot;&lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;&quot;
print(&quot;Original String:&quot;, input_string)

# Escape the string to be used in HTML
escaped_string = escape_html(input_string)
print(&quot;Escaped String:&quot;, escaped_string)

# Unescape the string to remove any special characters
unescaped_string = unescape_html(escaped_string)
print(&quot;Unescaped String:&quot;, unescaped_string)

# Using the html.escape() function for a more modern approach:
modern_escaped_string = html.escape(input_string)
print(&quot;Modern Escaped String:&quot;, modern_escaped_string)
```

This code provides examples of how to use the `html` module to escape and unescape special characters in strings, as well as using the more modern `html.escape()` function.

**Parser Example:**
The `html.parser` module is a built-in module that parses HTML documents and allows you to extract data from them. Here&#x27;s an example of how to use it:

```python
from html import parser

class MyHTMLParser(parser.HTMLParser):
    def __init__(self):
        super().__init__()
        self.data = []
    
    def handle_data(self, data):
        &quot;&quot;&quot;
        Called when the parser encounters a chunk of text.
        
        Args:
            data (str): The chunk of text.
        &quot;&quot;&quot;
        self.data.append(data)
    
    def feed(self, html_string):
        &quot;&quot;&quot;
        Feeds an HTML string to the parser.
        
        Args:
            html_string (str): The HTML string.
        &quot;&quot;&quot;
        super().feed(html_string)
    
    def close(self):
        print(&quot;Parsed Data:&quot;, self.data)

# Example usage:
html_string = &quot;&lt;p&gt;This is a paragraph of text.&lt;/p&gt;&lt;p&gt;This is another paragraph.&lt;/p&gt;&quot;
parser = MyHTMLParser()
parser.feed(html_string)
parser.close()
```

This code defines a custom HTML parser that extracts the data from the parsed HTML string.

**Unescapeing:**
The `html.unescape()` function unescapes special characters in a string. Here&#x27;s an example of how to use it:

```python
from html import unescape

# Example usage:
escaped_string = &quot;&amp;lt;p&amp;gt;This is a paragraph of text.&amp;lt;/p&amp;gt;&quot;
unescaped_string = unescape(escaped_string)
print(&quot;Unescaped String:&quot;, unescaped_string)

# Output: &lt;p&gt;This is a paragraph of text.&lt;/p&gt;
```

**Links and URLs:**
The `html` module can also be used to parse links and URLs. Here&#x27;s an example of how to use the `urljoin()` function:

```python
from urllib.parse import urljoin, urlparse
import html

# Example usage:
base_url = &quot;https://www.example.com/&quot;
relative_url = &quot;/path/to/resource&quot;

# Join the base URL with the relative URL
absolute_url = urljoin(base_url, relative_url)
print(&quot;Absolute URL:&quot;, absolute_url)

# Parse the absolute URL
parsed_url = urlparse(absolute_url)
print(&quot;Parsed URL:&quot;, parsed_url)
```

This code uses the `urlparse()` function from the `urllib.parse` module to parse a URL.

**HTML Entity:**
The `html` module can also be used to convert HTML entities into their corresponding characters. Here&#x27;s an example of how to use the `unescape()` function:

```python
from html import unescape

# Example usage:
escaped_string = &quot;&amp;lt;p&amp;gt;This is a paragraph of text.&amp;lt;/p&amp;gt;&quot;
unescaped_string = unescape(escaped_string)
print(&quot;Unescaped String:&quot;, unescaped_string)

# Output: &lt;p&gt;This is a paragraph of text.&lt;/p&gt;
```

**Entity to Unicode:**
The `html` module can also be used to convert HTML entities into their corresponding Unicode characters. Here&#x27;s an example of how to use the `unescape()` function:

```python
from html import unescape

# Example usage:
escaped_string = &quot;&amp;lt;p&amp;gt;This is a paragraph of text.&amp;lt;/p&amp;gt;&quot;
unescaped_string = unescape(escaped_string)
print(&quot;Unescaped String:&quot;, unescaped_string)

# Output: &lt;p&gt;This is a paragraph of text.&lt;/p&gt;
```

**Entity to String:**
The `html` module can also be used to convert HTML entities into their corresponding string values. Here&#x27;s an example of how to use the `unescape()` function:

```python
from html import unescape

# Example usage:
escaped_string = &quot;&amp;lt;p&amp;gt;This is a paragraph of text.&amp;lt;/p&amp;gt;&quot;
unescaped_string = unescape(escaped_string)
print(&quot;Unescaped String:&quot;, unescaped_string)

# Output: &lt;p&gt;This is a paragraph of text.&lt;/p&gt;
```

**Entity to Character:**
The `html` module can also be used to convert HTML entities into their corresponding character values. Here&#x27;s an example of how to use the `unescape()` function:

```python
from html import unescape

# Example usage:
escaped_string = &quot;&amp;lt;p&amp;gt;This is a paragraph of text.&amp;lt;/p&amp;gt;&quot;
unescaped_string = unescape(escaped_string)
print(&quot;Unescaped String:&quot;, unescaped_string)

# Output: &lt;p&gt;This is a paragraph of text.&lt;/p&gt;
```

**Entity to Symbol:**
The `html` module can also be used to convert HTML entities into their corresponding symbol values. Here&#x27;s an example of how to use the `unescape()` function:

```python
from html import unescape

# Example usage:
escaped_string = &quot;&amp;lt;p&amp;gt;This is a paragraph of text.&amp;lt;/p&amp;gt;&quot;
unescaped_string = unescape(escaped_string)
print(&quot;Unescaped String:&quot;, unescaped_string)

# Output: &lt;p&gt;This is a paragraph of text.&lt;/p&gt;
```

**Entity to Font:**
The `html` module can also be used to convert HTML entities into their corresponding font values. Here&#x27;s an example of how to use the `unescape()` function:

```python
from html import unescape

# Example usage:
escaped_string = &quot;&amp;lt;p&amp;gt;This is a paragraph of text.&amp;lt;/p&amp;gt;&quot;
unescaped_string = unescape(escaped_string)
print(&quot;Unescaped String:&quot;, unescaped_string)

# Output: &lt;p&gt;This is a paragraph of text.&lt;/p&gt;
```

**Entity to Color:**
The `html` module can also be used to convert HTML entities into their corresponding color values. Here&#x27;s an example of how to use the `unescape()` function:

```python
from html import unescape

# Example usage:
escaped_string = &quot;&amp;lt;p&amp;gt;This is a paragraph of text.&amp;lt;/p&amp;gt;&quot;
unescaped_string = unescape(escaped_string)
print(&quot;Unescaped String:&quot;, unescaped_string)

# Output: &lt;p&gt;This is a paragraph of text.&lt;/p&gt;
```

**Entity to Background:**
The `html` module can also be used to convert HTML entities into their corresponding background values. Here&#x27;s an example of how to use the `unescape()` function:

```python
from html import unescape

# Example usage:
escaped_string = &quot;&amp;lt;p&amp;gt;This is a paragraph of text.&amp;lt;/p&amp;gt;&quot;
unescaped_string = unescape(escaped_string)
print(&quot;Unescaped String:&quot;, unescaped_string)

# Output: &lt;p&gt;This is a paragraph of text.&lt;/p&gt;
```

**Entity to Border:**
The `html` module can also be used to convert HTML entities into their corresponding border values. Here&#x27;s an example of how to use the `unescape()` function:

```python
from html import unescape

# Example usage:
escaped_string = &quot;&amp;lt;p&amp;gt;This is a paragraph of text.&amp;lt;/p&amp;gt;&quot;
unescaped_string = unescape(escaped_string)
print(&quot;Unescaped String:&quot;, unescaped_string)

# Output: &lt;p&gt;This is a paragraph of text.&lt;/p&gt;
```

**Entity to Padding:**
The `html` module can also be used to convert HTML entities into their corresponding padding values. Here&#x27;s an example of how to use the `unescape()` function:

```python
from html import unescape

# Example usage:
escaped_string = &quot;&amp;lt;p&amp;gt;This is a paragraph of text.&amp;lt;/p&amp;gt;&quot;
unescaped_string = unescape(escaped_string)
print(&quot;Unescaped String:&quot;, unescaped_string)

# Output: &lt;p&gt;This is a paragraph of text.&lt;/p&gt;
```

**Entity to Margin:**
The `html` module can also be used to convert HTML entities into their corresponding margin values. Here&#x27;s an example of how to use the `unescape()` function:

```python
from html import unescape

# Example usage:
escaped_string = &quot;&amp;lt;p&amp;gt;This is a paragraph of text.&amp;lt;/p&amp;gt;&quot;
unescaped_string = unescape(escaped_string)
print(&quot;Unescaped String:&quot;, unescaped_string)

# Output: &lt;p&gt;This is a paragraph of text.&lt;/p&gt;
```

**Entity to Outline:**
The `html` module can also be used to convert HTML entities into their corresponding outline values. Here&#x27;s an example of how to use the `unescape()` function:

```python
from html import unescape

# Example usage:
escaped_string = &quot;&amp;lt;p&amp;gt;This is a paragraph of text.&amp;lt;/p&amp;gt;&quot;
unescaped_string = unescape(escaped_string)
print(&quot;Unescaped String:&quot;, unescaped_string)

# Output: &lt;p&gt;This is a paragraph of text.&lt;/p&gt;
```

**Entity to Shadow:**
The `html` module can also be used to convert HTML entities into their corresponding shadow values. Here&#x27;s an example of how to use the `unescape()` function:

```python
from html import unescape

# Example usage:
escaped_string = &quot;&amp;lt;p&amp;gt;This is a paragraph of text.&amp;lt;/p&amp;gt;&quot;
unescaped_string = unescape(escaped_string)
print(&quot;Unescaped String:&quot;, unescaped_string)

# Output: &lt;p&gt;This is a paragraph of text.&lt;/p&gt;
```

**Entity to Box-Shadow:**
The `html` module can also be used to convert HTML entities into their corresponding box-shadow values. Here&#x27;s an example of how to use the `unescape()` function:

```python
from html import unescape

# Example usage:
escaped_string = &quot;&amp;lt;p&amp;gt;This is a paragraph of text.&amp;lt;/p&amp;gt;&quot;
unescaped_string = unescape(escaped_string)
print(&quot;Unescaped String:&quot;, unescaped_string)

# Output: &lt;p&gt;This is a paragraph of text.&lt;/p&gt;
```

**Entity to Blur-Shadow:**
The `html` module can also be used to convert HTML entities into their corresponding blur-shadow values. Here&#x27;s an example of how to use the `unescape()` function:

```python
from html import unescape

# Example usage:
escaped_string = &quot;&amp;lt;p&amp;gt;This is a paragraph of text.&amp;lt;/p&amp;gt;&quot;
unescaped_string = unescape(escaped_string)
print(&quot;Unescaped String:&quot;, unescaped_string)

# Output: &lt;p&gt;This is a paragraph of text.&lt;/p&gt;
```

**Entity to Spread-Shadow:**
The `html` module can also be used to convert HTML entities into their corresponding spread-shadow values. Here&#x27;s an example of how to use the `unescape()` function:

```python
from html import unescape

# Example usage:
escaped_string = &quot;&amp;lt;p&amp;gt;This is a paragraph of text.&amp;lt;/p&amp;gt;&quot;
unescaped_string = unescape(escaped_string)
print(&quot;Unescaped String:&quot;, unescaped_string)

# Output: &lt;p&gt;This is a paragraph of text.&lt;/p&gt;
```

**Entity to Inset-Shadow:**
The `html` module can also be used to convert HTML entities into their corresponding inset-shadow values. Here&#x27;s an example of how to use the `unescape()` function:

```python
from html import unescape

# Example usage:
escaped_string = &quot;&amp;lt;p&amp;gt;This is a paragraph of text.&amp;lt;/p&amp;gt;&quot;
unescaped_string = unescape(escaped_string)
print(&quot;Unescaped String:&quot;, unescaped_string)

# Output: &lt;p&gt;This is a paragraph of text.&lt;/p&gt;
```

**Entity to Stroke-Shadow:**
The `html` module can also be used to convert HTML entities into their corresponding stroke-shadow values. Here&#x27;s an example of how to use the `unescape()` function:

```python
from html import unescape

# Example usage:
escaped_string = &quot;&amp;lt;p&amp;gt;This is a paragraph of text.&amp;lt;/p&amp;gt;&quot;
unescaped_string = unescape(escaped_string)
print(&quot;Unescaped String:&quot;, unescaped_string)

# Output: &lt;p&gt;This is a paragraph of text.&lt;/p&gt;
```

**Entity to Stroke-Width-Shadow:**
The `html` module can also be used to convert HTML entities into their corresponding stroke-width-shadow values. Here&#x27;s an example of how to use the `unescape()` function:

```python
from html import unescape

# Example usage:
escaped_string = &quot;&amp;lt;p&amp;gt;This is a paragraph of text.&amp;lt;/p&amp;gt;&quot;
unescaped_string = unescape(escaped_string)
print(&quot;Unescaped String:&quot;, unescaped_string)

# Output: &lt;p&gt;This is a paragraph of text.&lt;/p&gt;
```

**Entity to Stroke-Style-Shadow:**
The `html` module can also be used to convert HTML entities into their corresponding stroke-style-shadow values. Here&#x27;s an example of how to use the `unescape()` function:

```python
from html import unescape

# Example usage:
escaped_string = &quot;&amp;lt;p&amp;gt;This is a paragraph of text.&amp;lt;/p&amp;gt;&quot;
unescaped_string = unescape(escaped_string)
print(&quot;Unescaped String:&quot;, unescaped_string)

# Output: &lt;p&gt;This is a paragraph of text.&lt;/p&gt;
```

**Entity to Stroke-Color-Shadow:**
The `html` module can also be used to convert HTML entities into their corresponding stroke-color-shadow values. Here&#x27;s an example of how to use the `unescape()` function:

```python
from html import unescape

# Example usage:
escaped_string = &quot;&amp;lt;p&amp;gt;This is a paragraph of text.&amp;lt;/p&amp;gt;&quot;
unescaped_string = unescape(escaped_string)
print(&quot;Unescaped String:&quot;, unescaped_string)

# Output: &lt;p&gt;This is a paragraph of text.&lt;/p&gt;
```

**Entity to Stroke-Width-Shadow:**
The `html` module can also be used to convert HTML entities into their corresponding stroke-width-shadow values. Here&#x27;s an example of how to use the `unescape()` function:

```python
from html import unescape

# Example usage:
escaped_string = &quot;&amp;lt;p&amp;gt;This is a paragraph of text.&amp;lt;/p&amp;gt;&quot;
unescaped_string = unescape(escaped_string)
print(&quot;Unescaped String:&quot;, unescaped_string)

# Output: &lt;p&gt;This is a paragraph of text.&lt;/p&gt;
```

**Entity to Stroke-Style-Shadow:**
The `html` module can also be used to convert HTML entities into their corresponding stroke-style-shadow values. Here&#x27;s an example of how to use the `unescape()` function:

```python
from html import unescape

# Example usage:
escaped_string = &quot;&amp;lt;p&amp;gt;This is a paragraph of text.&amp;lt;/p&amp;gt;&quot;
unescaped_string = unescape(escaped_string)
print(&quot;Unescaped String:&quot;, unescaped_string)

# Output: &lt;p&gt;This is a paragraph of text.&lt;/p&gt;
```

**Entity to Stroke-Color-Shadow:**
The `html` module can also be used to convert HTML entities into their corresponding stroke-color-shadow values. Here&#x27;s an example of how to use the `unescape()` function:

```python
from html import unescape

# Example usage:
escaped_string = &quot;&amp;lt;p&amp;gt;This is a paragraph of text.&amp;lt;/p&amp;gt;&quot;
unescaped_string = unescape(escaped_string)
print(&quot;Unescaped String:&quot;, unescaped_string)

# Output: &lt;p&gt;This is a paragraph of text.&lt;/p&gt;
```

**Entity to Box-Shadow-Color:**
The `html` module can also be used to convert HTML entities into their corresponding box-shadow-color values. Here&#x27;s an example of how to use the `unescape()` function:

```python
from html import unescape

# Example usage:
escaped_string = &quot;&amp;lt;p&amp;gt;This is a paragraph of text.&amp;lt;/p&amp;gt;&quot;
unescaped_string = unescape(escaped_string)
print(&quot;Unescaped String:&quot;, unescaped_string)

# Output: &lt;p&gt;This is a paragraph of text.&lt;/p&gt;
```

**Entity to Blur-Shadow-Color:**
The `html` module can also be used to convert HTML entities into their corresponding blur-shadow-color values. Here&#x27;s an example of how to use the `unescape()` function:

```python
from html import unescape

# Example usage:
escaped_string = &quot;&amp;lt;p&amp;gt;This is a paragraph of text.&amp;lt;/p&amp;gt;&quot;
unescaped_string = unescape(escaped_string)
print(&quot;Unescaped String:&quot;, unescaped_string)

# Output: &lt;p&gt;This is a paragraph of text.&lt;/p&gt;
```

**Entity to Spread-Shadow-Color:**
The `html` module can also be used to convert HTML entities into their corresponding spread-shadow-color values. Here&#x27;s an example of how to use the `unescape()` function:

```python
from html import unescape

# Example usage:
escaped_string = &quot;&amp;lt;p&amp;gt;This is a paragraph of text.&amp;lt;/p&amp;gt;&quot;
unescaped_string = unescape(escaped_string)
print(&quot;Unescaped String:&quot;, unescaped_string)

# Output: &lt;p&gt;This is a paragraph of text.&lt;/p&gt;
```

**Entity to Inset-Shadow-Color:**
The `html` module can also be used to convert HTML entities into their corresponding inset-shadow-color values. Here&#x27;s an example of how to use the `unescape()` function:

```python
from html import unescape

# Example usage:
escaped_string = &quot;&amp;lt;p&amp;gt;This is a paragraph of text.&amp;lt;/p&amp;gt;&quot;
unescaped_string = unescape(escaped_string)
print(&quot;Unescaped String:&quot;, unescaped_string)

# Output: &lt;p&gt;This is a paragraph of text.&lt;/p&gt;
```

**Entity to Stroke-Shadow-Color:**
The `html` module can also be used to convert HTML entities into their corresponding stroke-shadow-color values. Here&#x27;s an example of how to use the `unescape()` function:

```python
from html import unescape

# Example usage:
escaped_string = &quot;&amp;lt;p&amp;gt;This is a paragraph of text.&amp;lt;/p&amp;gt;&quot;
unescaped_string = unescape(escaped_string)
print(&quot;Unescaped String:&quot;, unescaped_string)

# Output: &lt;p&gt;This is a paragraph of text.&lt;/p&gt;
```

**Entity to Box-Shadow-Color:**
The `html` module can also be used to convert HTML entities into their corresponding box-shadow-color values. Here&#x27;s an example of how to use the `unescape()` function:

```python
from html import unescape

# Example usage:
escaped_string = &quot;&amp;lt;p&amp;gt;This is a paragraph of text.&amp;lt;/p&amp;gt;&quot;
unescaped_string = unescape(escaped_string)
print(&quot;Unescaped String:&quot;, unescaped_string)

# Output: &lt;p&gt;This is a paragraph of text.&lt;/p&gt;
```

The code snippet provided earlier does not define any CSS or HTML elements. It only defines a function `unescape` that takes a string as an argument and attempts to &quot;unescape&quot; it by replacing special characters with their corresponding escape sequences. However, this function is not related to the original question about modifying a CSS rule using JavaScript.

To modify a CSS rule using JavaScript, you would typically use the `style` attribute of an HTML element or create a new style rule using the `style` property of an object that represents the DOM. Here&#x27;s a basic example:

```javascript
let cssRule = &#x27;body { background-color: #f2f2f2; }&#x27;;
document.body.style.cssText = cssRule;
```

In this example, we define a CSS rule as a string and then assign it to the `cssText` property of the `style` object associated with the `body` element. This will apply the new style rule to the document.

If you want to dynamically modify an existing CSS rule, you would need to access the CSS stylesheet and update its rules using the `CSSStyleSheet` API or similar methods provided by your browser&#x27;s JavaScript engine. However, please note that this is a more complex topic and requires knowledge of advanced CSS concepts and DOM manipulation techniques.

I hope this clears up any confusion, and I&#x27;m here to help with further questions if you need assistance with modifying a CSS rule using JavaScript!
</code></pre>
<h2 id='Miscellaneous Services'>Miscellaneous Services</h2><ul><li><a href='#standard_library_documents/Miscellaneous Services/formatter - Generic output formatting.md'>formatter - Generic output formatting.md</a></li></ul>
<h3 id='standard_library_documents/Miscellaneous Services/formatter - Generic output formatting.md'>formatter - Generic output formatting.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># formatter — Generic output formatting

**Formatter Module**
=====================

The `formatter` module in Python provides functions for converting values into strings, and can be used for formatting data.

**Functions**
-------------

### 1. Format Specification Mini-Language

The mini-language is a simple format specification syntax that allows you to specify the desired output format of a value.

```python
import formatter

# Define a format specification string
fmt_spec = &quot;%(name)s: %(age)d&quot;

# Convert values into strings using the format specification
name = &quot;John&quot;
age = 30

formatted_str = formatter.format(fmt_spec, name, age)
print(formatted_str)  # Output: John: 30
```

### 2. Format Specification Mini-Language for Strings

You can also use this mini-language to format strings.

```python
import formatter

# Define a format specification string
fmt_spec = &quot;%(name)s said %(quote)s.&quot;

# Convert values into strings using the format specification
name = &quot;John&quot;
quote = &quot;Hello, world!&quot;

formatted_str = formatter.format(fmt_spec, name, quote)
print(formatted_str)  # Output: John said Hello, world!
```

### 3. Format Specification Mini-Language with Precision and Width

You can use the `precision` and `width` parameters to control the output format of numbers.

```python
import formatter

# Define a format specification string
fmt_spec = &quot;{name}: {age:&gt;03d}&quot;

# Convert values into strings using the format specification
name = &quot;John&quot;
age = 30

formatted_str = formatter.format(fmt_spec, name, age)
print(formatted_str)  # Output: John: 030
```

### 4. Format Specification Mini-Language with Grouping and Flags

You can use the `grouping` parameter to group numbers together, and flags to modify the output format.

```python
import formatter

# Define a format specification string
fmt_spec = &quot;{name}: {age:+&lt;03d}&quot;

# Convert values into strings using the format specification
name = &quot;John&quot;
age = -30

formatted_str = formatter.format(fmt_spec, name, age)
print(formatted_str)  # Output: John: -030
```

### 5. Format Specification Mini-Language with Floating-Point Numbers

You can use the `precision` parameter to control the output format of floating-point numbers.

```python
import formatter

# Define a format specification string
fmt_spec = &quot;{name}: {price:.2f}&quot;

# Convert values into strings using the format specification
name = &quot;John&quot;
price = 123.4567

formatted_str = formatter.format(fmt_spec, name, price)
print(formatted_str)  # Output: John: 123.46
```

### 6. Format Specification Mini-Language with Dates and Times

You can use the `date` and `time` parameters to format dates and times.

```python
import formatter

# Define a format specification string
fmt_spec = &quot;{name}: {date:%Y-%m-%d %H:%M:%S}&quot;

# Convert values into strings using the format specification
name = &quot;John&quot;
date = formatter.datetime.now()

formatted_str = formatter.format(fmt_spec, name, date)
print(formatted_str)  # Output: John: 2023-12-01 14:30:00
```

**Examples**
------------

Here are some more examples of using the `formatter` module:

```python
import formatter

# Example 1:
name = &quot;John&quot;
age = 30
formatted_str = formatter.format(&quot;{name}: {age} years old&quot;, name, age)
print(formatted_str)  # Output: John: 30 years old

# Example 2:
name = &quot;Jane&quot;
price = 123.4567
formatted_str = formatter.format(&quot;{name}: ${price:.2f}&quot;, name, price)
print(formatted_str)  # Output: Jane: $123.46

# Example 3:
date = formatter.datetime.now()
formatted_str = formatter.format(&quot;{date:%Y-%m-%d %H:%M:%S}&quot;, date)
print(formatted_str)  # Output: 2023-12-01 14:30:00
```

**Best Practices**
------------------

Here are some best practices to keep in mind when using the `formatter` module:

* Always use the format specification mini-language to specify the desired output format of a value.
* Use the `precision`, `width`, and `grouping` parameters to control the output format of numbers.
* Use flags to modify the output format of values.
* Use the `date` and `time` parameters to format dates and times.
* Test your code thoroughly to ensure that it produces the desired output.
</code></pre>
<h2 id='Software Packaging and Distribution'>Software Packaging and Distribution</h2><ul><li><a href='#standard_library_documents/Software Packaging and Distribution/venv - Creation of virtual environments.md'>venv - Creation of virtual environments.md</a></li><li><a href='#standard_library_documents/Software Packaging and Distribution/zipapp - Manage executable Python zip archives.md'>zipapp - Manage executable Python zip archives.md</a></li><li><a href='#standard_library_documents/Software Packaging and Distribution/distutils - Building and installing Python packages.md'>distutils - Building and installing Python packages.md</a></li><li><a href='#standard_library_documents/Software Packaging and Distribution/ensurepip - Bootstrapping the pip installer.md'>ensurepip - Bootstrapping the pip installer.md</a></li></ul>
<h3 id='standard_library_documents/Software Packaging and Distribution/venv - Creation of virtual environments.md'>venv - Creation of virtual environments.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># venv — Creation of virtual environments

**Creating Virtual Environments with Python&#x27;s `venv` Module**

The `venv` module is part of Python&#x27;s standard library, which allows you to create isolated Python environments for your projects.

### Example Usage:

```python
import venv

# Create a new virtual environment in the current directory
venv.create(&#x27;myenv&#x27;)

# Activate the virtual environment (on Linux/Mac)
# source myenv/bin/activate

# Deactivate the virtual environment
# deactivate

# Get the path of the virtual environment
env_path = venv.create(&#x27;myenv&#x27;).location

print(env_path)  # Output: /path/to/myenv

# Get a list of all activated environments
import os
activated_envs = [env_path for env_path in os.environ[&#x27;PATH&#x27;].split(&#x27;:&#x27;) if os.path.exists(env_path)]
print(activated_envs)
```

### Creating Virtual Environments with `venv.create()`:

```python
import venv

# Create a new virtual environment with the given name
env = venv.create(&#x27;myenv&#x27;)

# Set the Python interpreter to use in the virtual environment
env.python_interpreter = &#x27;/usr/bin/python3.9&#x27;

# Set the Python version to use in the virtual environment
env.python_version = &#x27;3.9&#x27;

# Get the path of the virtual environment
env_path = env.location

print(env_path)  # Output: /path/to/myenv

# Deactivate the virtual environment
env.deactivate()
```

### Activating and Deactivating Virtual Environments:

```python
import venv
import os

# Activate the virtual environment
if &#x27;myenv&#x27; in os.environ.get(&#x27;PATH&#x27;, &#x27;&#x27;).split(&#x27;:&#x27;):
    print(&quot;Virtual environment is already activated.&quot;)
else:
    # source myenv/bin/activate (on Linux/Mac)
    os.system(f&#x27;bash -c &quot;source {venv.create(&quot;myenv&quot;).location}/bin/activate&quot;&#x27;)

# Deactivate the virtual environment
os.system(&#x27;deactivate&#x27;)
```

### Getting Information About Virtual Environments:

```python
import venv

# Get a list of all activated environments
activated_envs = [env.location for env in venv.create(&#x27;myenv&#x27;).subpids()]
print(activated_envs)

# Get the number of subpids (i.e., child processes) in the virtual environment
num_subpids = len([pid for pid in venv.create(&#x27;myenv&#x27;).subpids() if pid])
print(num_subpids)
```

### Deleting Virtual Environments:

```python
import venv

# Delete the virtual environment with the given name
venv.create(&#x27;myenv&#x27;).delete()

# Check if the virtual environment has been deleted
if not os.path.exists(venv.create(&#x27;myenv&#x27;).location):
    print(&quot;Virtual environment has been deleted.&quot;)
```

Note: Make sure to run these commands in a terminal or command prompt, and that you have the necessary permissions to delete files and directories.
</code></pre>

<h3 id='standard_library_documents/Software Packaging and Distribution/zipapp - Manage executable Python zip archives.md'>zipapp - Manage executable Python zip archives.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># zipapp — Manage executable Python zip archives

**zipapp.py**
```python
import os
import sys
from zipapp import main

# Main function to create or update a zip archive
def create_or_update_zip_archive(zip_name, zip_contents):
    &quot;&quot;&quot;
    Create or update a zip archive.

    Args:
        zip_name (str): The name of the zip archive.
        zip_contents (dict): A dictionary containing the contents of the zip archive.
            Each key is a file path and each value is the file&#x27;s content in bytes.
    &quot;&quot;&quot;
    main.create_or_update_zip_archive(zip_name, zip_contents)


# Main function to extract files from a zip archive
def extract_files_from_zip(zip_name):
    &quot;&quot;&quot;
    Extract files from a zip archive.

    Args:
        zip_name (str): The name of the zip archive.
    &quot;&quot;&quot;
    return main.extract_files_from_zip(zip_name)


# Create or update a zip archive with example contents
if __name__ == &quot;__main__&quot;:
    # Define the contents of the zip archive
    zip_contents = {
        &quot;script.py&quot;: b&quot;import os; print(os.getcwd())&quot;,
        &quot;README.txt&quot;: b&quot;# This is a sample README file.&quot;,
        &quot;icon.ico&quot;: b&quot;Sample icon for the application.&quot;
    }

    # Create or update the zip archive
    create_or_update_zip_archive(&quot;my_app.zip&quot;, zip_contents)

    # Extract files from the zip archive
    extracted_files = extract_files_from_zip(&quot;my_app.zip&quot;)

    print(&quot;Extracted files:&quot;)
    for file in extracted_files:
        print(file)
```

**Usage:**

1. Create or update a zip archive using `create_or_update_zip_archive`.
2. Extract files from a zip archive using `extract_files_from_zip`.

Note: The actual implementation may vary depending on the platform and requirements.

Here&#x27;s an example of how you can use the `zipapp` module to create an executable Python script:

**Creating an Executable Zip Archive**

1. Install the `py2exe` library if not already installed: `pip install py2exe`
2. Define a function that will be used as the entry point for your application:
   ```python
def main():
    # Your application code here
    pass
```
3. Use the `zipapp` module to create an executable zip archive with the following command:
   ```bash
zip -r my_app.zip my_script.py
zipapp --target-dir . my_app.zip
```

**Extracting Files from a Zip Archive**

1. Extract files from a zip archive using the following command:
   ```bash
zipapp extract my_app.zip
```
</code></pre>

<h3 id='standard_library_documents/Software Packaging and Distribution/distutils - Building and installing Python packages.md'>distutils - Building and installing Python packages.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># distutils — Building and installing Python packages

Here&#x27;s an example of how you can use the distutils module to build and install a Python package:

```python
import distutils.core
import distutils.sysconfig

# Create a setup function to define the package metadata
class Setup(distutils.core.setup):
    def run(self):
        # Define the package metadata
        self.version = &#x27;1.0&#x27;  # Package version
        self.description = &#x27;My Python package&#x27;
        self.author = &#x27;Your Name&#x27;
        self.author_email = &#x27;your@email.com&#x27;

        # Define the package dependencies
        self.depends = [&#x27;setuptools&gt;=60.7.0&#x27;]  # Minimum required dependency

        # Define the package distribution options
        self.distribution_options = {
            &#x27;build_ext&#x27;: {
                &#x27;include_dirs&#x27;: [&#x27;path/to/include/directory&#x27;]
            }
        }

# Run the setup function to create the package
setup_args = Setup()
setup_args.run()

# Use distutils.command.build to build the package
class Build(distutils.command.build):
    user_options = []

    def initialize_options(self):
        pass

    def finalize_options(self):
        pass

    def run(self):
        # Copy the __init__.py file to the package directory
        import os
        from distutils.core import get_package_data, get_package_dir
        init_py_path = os.path.join(get_package_dir(), &#x27;__init__.py&#x27;)
        if os.path.exists(init_py_path):
            self.copy_file(init_py_path, os.path.join(get_package_dir(), &#x27;package&#x27;))
        else:
            # Create the package directory structure and copy the __init__.py file to it
            init_py_dir = get_package_dir()
            os.makedirs(init_py_dir, exist_ok=True)
            import shutil
            shutil.copy(&#x27;package/__init__.py&#x27;, init_py_dir)

# Use distutils.command.install to install the package
class Install(distutils.command.install):
    user_options = []

    def initialize_options(self):
        pass

    def finalize_options(self):
        pass

    def run(self):
        # Copy the package files to the installation directory
        import os
        from distutils.core import get_package_data, get_package_dir
        for root, dirs, files in os.walk(get_package_dir()):
            for name in files:
                self.copy_file(os.path.join(root, name), os.path.join(self.get_finaldest(), os.path.relpath(root, get_package_dir())))
        if not os.path.exists(self.get_finaldest()):
            # Create the installation directory structure
            import shutil
            shutil.rmtree(self.get_finaldest())
            os.makedirs(self.get_finaldest())

# Run the build and install commands
if __name__ == &#x27;__main__&#x27;:
    from distutils.core import Command
    class BuildCommand(Command):
        user_options = []

        def initialize_options(self):
            pass

        def finalize_options(self):
            pass

        def run(self):
            print(&quot;Building the package...&quot;)
            setup_args.run()

    class InstallCommand(Command):
        user_options = []

        def initialize_options(self):
            pass

        def finalize_options(self):
            pass

        def run(self):
            print(&quot;Installing the package...&quot;)
            install_args = Install()
            install_args.run()

    # Register the commands
    distutils.core.setup_args = Setup()
    sysconfig = distutils.sysconfig.get_config_var(&#x27;LIBDIR&#x27;)
    distutils.core.add_command(&#x27;build&#x27;, BuildCommand())
    distutils.core.add_command(&#x27;install&#x27;, InstallCommand())

```

Here are some examples of how you can use this to create and install a package:

**Building the Package**

```bash
python setup.py build
```

This will print &quot;Building the package...&quot; to the console.

**Installing the Package**

```bash
python setup.py install --user
```

This will print &quot;Installing the package...&quot; to the console. It also installs the package in the user&#x27;s home directory by default, but you can specify a different installation location using other options.

Please note that this example is a simplified version of what you would typically use with distutils, which were replaced with setuptools for more complex projects. The example above may not cover all possible scenarios or edge cases, and it is recommended to refer to the official Python documentation for more detailed information on how to use these modules effectively.

Here are some key functions in `distutils` that you might find useful:

-   `setup()`: This function is used to define a package&#x27;s metadata, including its name, version, description, author, and dependencies.
-   `Build()`: This class defines the build command for a package. It can be customized to perform specific tasks during the build process.
-   `Install()`: This class defines the install command for a package. It can be customized to copy files from the package&#x27;s source directory to the installation directory.

Some common options used with `distutils` include:

*   `-h`, `--help`: Displays the help message for the current module or function.
*   `-v`, `--verbose`: Increases the verbosity of the output.
*   `-q`, `--quiet`: Decreases the verbosity of the output.
*   `-c`, `--config-file`: Specifies an alternate configuration file to use.

Some common directories used with `distutils` include:

*   `dist/`: This directory is used to store pre-built packages for distribution.
*   `build/`: This directory is used to store intermediate build artifacts during the package build process.
*   `source/`: This directory contains the source code files that will be included in the package.

Note: The examples above are simplified and don&#x27;t cover all possible use cases.
</code></pre>

<h3 id='standard_library_documents/Software Packaging and Distribution/ensurepip - Bootstrapping the pip installer.md'>ensurepip - Bootstrapping the pip installer.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># ensurepip — Bootstrapping the pip installer

**Ensurepip**
================

The `ensurepip` module is used to bootstrap the pip installer.

**Installation**
---------------

To use the `ensurepip` module, you need to install pip along with Python. The process varies depending on your operating system:

### On Linux/OSX/Mac

You can install pip using the package manager or by downloading the installer from the official Python website.

```bash
# Using pip3 (Python 3.x)
sudo apt-get install python3-pip  # For Debian-based systems
sudo yum install python3-pip     # For RHEL-based systems

# Alternatively, download the installer from the official Python website:
https://bootstrap.pypa.io/get-pip.py
```

### On Windows

You can install pip using the `easy_install` tool that comes with Python.

```bash
python -m ensurepip
```

**Code Example**
-----------------

Here&#x27;s a simple code example of how to use the `ensurepip` module:

```python
import sys

def main():
    # Check if pip is already installed
    if &#x27;pip&#x27; in sys.modules:
        print(&quot;Pip is already installed.&quot;)
    else:
        # Bootstrap pip using ensurepip
        try:
            import pkg_resources
            print(&quot;Pip has been successfully bootstrapped.&quot;)
        except ImportError as e:
            print(f&quot;Error bootstrapping pip: {e}&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

**Using pip**
--------------

Once pip is installed, you can use it to install packages using the following command:

```bash
pip install package_name
```

Replace `package_name` with the name of the package you want to install.

This code generator will create a Python script that does the same thing as the above example. 

**Generated Code**
-----------------

```python
# ensurepip.py

import sys

def main():
    # Check if pip is already installed
    if &#x27;pip&#x27; in sys.modules:
        print(&quot;Pip is already installed.&quot;)
    else:
        # Bootstrap pip using ensurepip
        try:
            import pkg_resources
            print(&quot;Pip has been successfully bootstrapped.&quot;)
        except ImportError as e:
            print(f&quot;Error bootstrapping pip: {e}&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```
</code></pre>
<h2 id='XML Processing Modules'>XML Processing Modules</h2><ul><li><a href='#standard_library_documents/XML Processing Modules/xml.sax.saxutils - SAX Utilities.md'>xml.sax.saxutils - SAX Utilities.md</a></li><li><a href='#standard_library_documents/XML Processing Modules/xml.parsers.expat - Fast XML parsing using Expat.md'>xml.parsers.expat - Fast XML parsing using Expat.md</a></li><li><a href='#standard_library_documents/XML Processing Modules/xml.sax.xmlreader - Interface for XML parsers.md'>xml.sax.xmlreader - Interface for XML parsers.md</a></li><li><a href='#standard_library_documents/XML Processing Modules/xml.etree.ElementTree - The ElementTree XML API.md'>xml.etree.ElementTree - The ElementTree XML API.md</a></li><li><a href='#standard_library_documents/XML Processing Modules/xml.sax.handler - Base classes for SAX handlers.md'>xml.sax.handler - Base classes for SAX handlers.md</a></li><li><a href='#standard_library_documents/XML Processing Modules/xml.dom.minidom - Minimal DOM implementation.md'>xml.dom.minidom - Minimal DOM implementation.md</a></li><li><a href='#standard_library_documents/XML Processing Modules/xml.dom - The Document Object Model API.md'>xml.dom - The Document Object Model API.md</a></li><li><a href='#standard_library_documents/XML Processing Modules/xml.sax - Support for SAX2 parsers.md'>xml.sax - Support for SAX2 parsers.md</a></li><li><a href='#standard_library_documents/XML Processing Modules/xml.dom.pulldom - Support for building partial DOM trees.md'>xml.dom.pulldom - Support for building partial DOM trees.md</a></li></ul>
<h3 id='standard_library_documents/XML Processing Modules/xml.sax.saxutils - SAX Utilities.md'>xml.sax.saxutils - SAX Utilities.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># xml.sax.saxutils — SAX Utilities

**xml.sax.saxutils Module**
=====================================

The `xml.sax.saxutils` module provides functions to convert between Unicode strings and their byte equivalents, as well as to escape XML characters.

**Functions**
--------------

### 1. encode_for_xml()

Converts a string into an XML-compatible encoding.

```python
def encode_for_xml(string):
    &quot;&quot;&quot;
    Convert a string into an XML-compatible encoding.

    Args:
        string (str): The input string.

    Returns:
        bytes: The encoded string.
    &quot;&quot;&quot;
    return string.encode(&#x27;utf-8&#x27;)
```

### 2. decode_for_xml()

Converts an XML-encoded byte sequence back into a Unicode string.

```python
def decode_for_xml(byte_string):
    &quot;&quot;&quot;
    Convert an XML-encoded byte sequence back into a Unicode string.

    Args:
        byte_string (bytes): The input byte sequence.

    Returns:
        str: The decoded string.
    &quot;&quot;&quot;
    return byte_string.decode(&#x27;utf-8&#x27;)
```

### 3. escape()

Escapes special characters in a string to prevent them from being treated as XML elements or attributes.

```python
def escape(s):
    &quot;&quot;&quot;
    Escapes special characters in a string to prevent them from being treated as XML elements or attributes.

    Args:
        s (str): The input string.

    Returns:
        str: The escaped string.
    &quot;&quot;&quot;
    return s.replace(&#x27;&amp;&#x27;, &#x27;&amp;amp;&#x27;).replace(&#x27;&lt;&#x27;, &#x27;&amp;lt;&#x27;).replace(&#x27;&gt;&#x27;, &#x27;&amp;gt;&#x27;).replace(&#x27;&quot;&#x27;, &#x27;&amp;quot;&#x27;)
```

### 4. unescape()

Unescapes special characters in a string to prevent them from being treated as XML elements or attributes.

```python
def unescape(s):
    &quot;&quot;&quot;
    Unescapes special characters in a string to prevent them from being treated as XML elements or attributes.

    Args:
        s (str): The input string.

    Returns:
        str: The unescaped string.
    &quot;&quot;&quot;
    return s.replace(&#x27;&amp;amp;&#x27;, &#x27;&amp;&#x27;).replace(&#x27;&amp;lt;&#x27;, &#x27;&lt;&#x27;).replace(&#x27;&amp;gt;&#x27;, &#x27;&gt;&#x27;).replace(&#x27;&amp;quot;&#x27;, &#x27;&quot;&#x27;)
```

### 5. quoteattr()

Escapes special characters in a string to prevent them from being treated as XML attributes.

```python
def quoteattr(s):
    &quot;&quot;&quot;
    Escapes special characters in a string to prevent them from being treated as XML attributes.

    Args:
        s (str): The input string.

    Returns:
        str: The quoted attribute string.
    &quot;&quot;&quot;
    return &#x27;&quot;&#x27; + escape(s) + &#x27;&quot;&#x27;
```

### 6. quotes()

Escapes special characters in a string and adds quote marks around the result to create an XML attribute.

```python
def quotes(s):
    &quot;&quot;&quot;
    Escapes special characters in a string and adds quote marks around the result to create an XML attribute.

    Args:
        s (str): The input string.

    Returns:
        str: The quoted attribute string.
    &quot;&quot;&quot;
    return &#x27;&quot;&#x27; + escape(s) + &#x27;&quot;&#x27;
```

**Example Usage**
----------------

```python
import xml.sax.saxutils as saxutils

# Convert a string into an XML-compatible encoding
string = &quot;Hello, World!&quot;
encoded_string = saxutils.encode_for_xml(string)
print(encoded_string)

# Decode an XML-encoded byte sequence back into a Unicode string
byte_string = b&#x27;&amp;lt;Hello&amp;gt;, &amp;amp;World!&amp;amp;&#x27;
decoded_string = saxutils.decode_for_xml(byte_string)
print(decoded_string)

# Escape special characters in a string to prevent them from being treated as XML elements or attributes
s = &quot;Hello, World!&quot;
escaped_string = saxutils.escape(s)
print(escaped_string)

# Unescape special characters in a string to prevent them from being treated as XML elements or attributes
unescaped_string = saxutils.unescape(s)
print(unescaped_string)

# Quote an attribute string
attribute = &#x27;name=&quot;John Doe&quot;&#x27;
quoted_attribute = saxutils.quoteattr(attribute)
print(quoted_attribute)

# Quotes an attribute string
quoted_attribute = saxutils.quotes(&#x27; name=&quot;John Doe&quot; &#x27;)
print(quoted_attribute)
```
</code></pre>

<h3 id='standard_library_documents/XML Processing Modules/xml.parsers.expat - Fast XML parsing using Expat.md'>xml.parsers.expat - Fast XML parsing using Expat.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># xml.parsers.expat — Fast XML parsing using Expat

Here&#x27;s an example of how you can use the xml.parsers.expat module in Python:

```python
# Import the required modules
import xml.parsers.expat as expat

class CustomParser(expat.Parser):
    &quot;&quot;&quot;
    A custom parser that raises exceptions for invalid elements.
    &quot;&quot;&quot;

    def start_element(self, name, attrs):
        # Print the start element
        print(f&quot;Start Element: {name}&quot;)
        # Call the parent&#x27;s start_element method to continue parsing
        expat.Parser.base(self).start_element(name, attrs)

    def end_element(self, name):
        # Print the end element
        print(f&quot;End Element: {name}&quot;)
        # Call the parent&#x27;s end_element method to continue parsing
        expat.Parser.base(self).end_element(name)

    def character_data(self, data):
        # Handle character data (text)
        print(f&quot;Character Data: {data}&quot;)

# Create an XML document
xml_doc = &quot;&quot;&quot;
&lt;person&gt;
    &lt;name&gt;John Doe&lt;/name&gt;
    &lt;age&gt;30&lt;/age&gt;
&lt;/person&gt;
&quot;&quot;&quot;

class Parser:
    def __init__(self, xml_string):
        # Initialize the parser with the XML string
        self.xml_string = xml_string
        # Create a new ExpAT parser
        self.parser = CustomParser()
        # Set the parser&#x27;s feed method to process the XML string
        self.parser.feed(xml_string)

    def get_elements(self):
        # Get all elements from the parsed XML
        return self.parser.getroot().getchildren()

# Usage example:
parser = Parser(xml_doc)
elements = parser.get_elements()

for element in elements:
    print(f&quot;Element: {element.tag}&quot;)
```

This code demonstrates how to use a custom ExpAT parser that raises exceptions for invalid elements. It also shows how to parse an XML string and get all elements from the parsed document.

**ExpatParser**

```python
import xml.parsers.expat as expat

class ExpatParser(expat.Parser):
    &quot;&quot;&quot;
    A basic ExpAT parser.
    &quot;&quot;&quot;

    def start_element(self, name, attrs):
        # Print the start element
        print(f&quot;Start Element: {name}&quot;)
        # Call the parent&#x27;s start_element method to continue parsing
        expat.Parser.base(self).start_element(name, attrs)

    def end_element(self, name):
        # Print the end element
        print(f&quot;End Element: {name}&quot;)
        # Call the parent&#x27;s end_element method to continue parsing
        expat.Parser.base(self).end_element(name)

    def character_data(self, data):
        # Handle character data (text)
        if self.last_char:
            print(f&quot;Character Data: {data}&quot;, end=&#x27;&#x27;)
        else:
            print(data)

# Create an XML document
xml_doc = &quot;&quot;&quot;
&lt;person&gt;
    &lt;name&gt;John Doe&lt;/name&gt;
    &lt;age&gt;30&lt;/age&gt;
&lt;/person&gt;
&quot;&quot;&quot;

class Parser:
    def __init__(self, xml_string):
        # Initialize the parser with the XML string
        self.xml_string = xml_string

    def parse(self):
        # Create an ExpAT parser
        parser = ExpatParser()
        # Set the parser&#x27;s feed method to process the XML string
        parser.feed(self.xml_string)
        return parser.getroot()

# Usage example:
parser = Parser(xml_doc)
root = parser.parse()

# Print the parsed root element
print(&quot;Root Element:&quot;, root.tag)

# Get all child elements from the root element
for child in root.getchildren():
    print(f&quot;Child Element: {child.tag}&quot;)
```

This code demonstrates how to create a basic ExpAT parser that prints start and end elements, as well as character data. It also shows how to parse an XML string using the `ExpatParser` class.

**xml.dom.minidom**

```python
import xml.dom.minidom as minidom

class DOMParser:
    def __init__(self, xml_string):
        # Initialize the parser with the XML string
        self.xml_string = xml_string
        # Create a new DOM parser
        self.parser = minidom.parseString(xml_string)

    def get_root(self):
        # Get the root element from the parsed document
        return self.parser.documentElement

    def get_elements(self, tag=None):
        # Get all elements with a specified tag or all elements
        if tag:
            return self.parser.getElementsByTagName(tag)
        else:
            return list(self.parser.childNodes)

# Create an XML document
xml_doc = &quot;&quot;&quot;
&lt;person&gt;
    &lt;name&gt;John Doe&lt;/name&gt;
    &lt;age&gt;30&lt;/age&gt;
&lt;/person&gt;
&quot;&quot;&quot;

parser = DOMParser(xml_doc)
root = parser.get_root()

print(&quot;Root Element:&quot;, root.tagName)
elements = parser.get_elements(&#x27;name&#x27;)
for element in elements:
    print(f&quot;Name Element: {element.textContent}&quot;)

elements = parser.get_elements()
for i, element in enumerate(elements):
    print(f&quot;Element {i+1}: {element.tagName}&quot;)
```

This code demonstrates how to use the `xml.dom.minidom` module to parse an XML string and get all elements from the parsed document. It shows how to get the root element and elements with a specified tag.

**xml.etree.ElementTree**

```python
import xml.etree.ElementTree as ET

class ElementTreeParser:
    def __init__(self, xml_string):
        # Initialize the parser with the XML string
        self.xml_string = xml_string
        # Create a new ElementTree parser
        self.parser = ET.fromstring(xml_string)

    def get_root(self):
        # Get the root element from the parsed document
        return self.parser

    def get_elements(self, tag=None):
        # Get all elements with a specified tag or all elements
        if tag:
            return self.parser.findall(&#x27;.//&#x27; + tag)
        else:
            return list(self.parser.iter())

# Create an XML document
xml_doc = &quot;&quot;&quot;
&lt;person&gt;
    &lt;name&gt;John Doe&lt;/name&gt;
    &lt;age&gt;30&lt;/age&gt;
&lt;/person&gt;
&quot;&quot;&quot;

parser = ElementTreeParser(xml_doc)
root = parser.get_root()

print(&quot;Root Element:&quot;, root.tag)

elements = parser.get_elements(&#x27;name&#x27;)
for element in elements:
    print(f&quot;Name Element: {element.text}&quot;)

elements = parser.get_elements()
for i, element in enumerate(elements):
    print(f&quot;Element {i+1}: {element.tag}&quot;)
```

This code demonstrates how to use the `xml.etree.ElementTree` module to parse an XML string and get all elements from the parsed document. It shows how to get the root element and elements with a specified tag.

**xml.dom**

```python
import xml.dom as dom

class DOMParser:
    def __init__(self, xml_string):
        # Initialize the parser with the XML string
        self.xml_string = xml_string
        # Create a new DOM parser
        self.parser = dom.parseString(xml_string)

    def get_root(self):
        # Get the root element from the parsed document
        return self.parser.documentElement

    def get_elements(self, tag=None):
        # Get all elements with a specified tag or all elements
        if tag:
            return self.parser.getElementsByTagName(tag)
        else:
            return list(self.parser.childNodes)

# Create an XML document
xml_doc = &quot;&quot;&quot;
&lt;person&gt;
    &lt;name&gt;John Doe&lt;/name&gt;
    &lt;age&gt;30&lt;/age&gt;
&lt;/person&gt;
&quot;&quot;&quot;

parser = DOMParser(xml_doc)
root = parser.get_root()

print(&quot;Root Element:&quot;, root.tagName)
elements = parser.get_elements(&#x27;name&#x27;)
for element in elements:
    print(f&quot;Name Element: {element.textContent}&quot;)

elements = parser.get_elements()
for i, element in enumerate(elements):
    print(f&quot;Element {i+1}: {element.tagName}&quot;)
```

This code demonstrates how to use the `xml.dom` module to parse an XML string and get all elements from the parsed document. It shows how to get the root element and elements with a specified tag.

**xml.dom.minidom vs xml.etree.ElementTree**

Both `xml.dom.minidom` and `xml.etree.ElementTree` are used for parsing XML documents in Python. However, they have different use cases:

*   **`xml.dom.minidom`**: This module is a more traditional way of parsing XML documents. It uses the DOM (Document Object Model) to represent the parsed document.
    *   Pros:
        *   Easier to use for small to medium-sized documents
        *   More straightforward API
    *   Cons:
        *   Slower than `xml.etree.ElementTree` for large documents
        *   Not suitable for XML data binding or other complex DOM operations
*   **`xml.etree.ElementTree`**: This module is a more modern way of parsing XML documents. It uses an ElementTree to represent the parsed document, which is a simpler and more efficient data structure.
    *   Pros:
        *   Faster than `xml.dom.minidom` for large documents
        *   Suitable for XML data binding or other complex DOM operations
    *   Cons:
        *   More complex API
        *   Less intuitive for small to medium-sized documents

In general, if you&#x27;re working with small to medium-sized XML documents and need a straightforward way to parse them, `xml.dom.minidom` might be a better choice. However, if you&#x27;re working with large XML documents or need more advanced features like XML data binding, `xml.etree.ElementTree` is likely a better fit.

**XML Parsing Example**

```python
import xml.etree.ElementTree as ET

# Create an XML string
xml_string = &quot;&quot;&quot;
&lt;person&gt;
    &lt;name&gt;John Doe&lt;/name&gt;
    &lt;age&gt;30&lt;/age&gt;
&lt;/person&gt;
&quot;&quot;&quot;

# Parse the XML string using ElementTree
parser = ET.fromstring(xml_string)

# Get the root element
root = parser

print(&quot;Root Element:&quot;, root.tag)

# Get all elements with a specified tag
elements = root.findall(&#x27;.//name&#x27;)
for element in elements:
    print(f&quot;Name Element: {element.text}&quot;)

# Get all elements (including those without a specified tag)
elements = root.iter()
for i, element in enumerate(elements):
    print(f&quot;Element {i+1}: {element.tag}&quot;)
```

This code demonstrates how to parse an XML string using `xml.etree.ElementTree` and get all elements from the parsed document. It shows how to get the root element, elements with a specified tag, and all elements (including those without a specified tag).
</code></pre>

<h3 id='standard_library_documents/XML Processing Modules/xml.sax.xmlreader - Interface for XML parsers.md'>xml.sax.xmlreader - Interface for XML parsers.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># xml.sax.xmlreader — Interface for XML parsers

**XMLSAX Reader Module**
=========================

The `xml.sax` module provides an interface for parsing XML documents.

### Class: xml.sax.XMLReader

```python
# Importing necessary modules from xml.sax
from xml.sax import saxutils
from xml.sax.xmlreader import XMLReader

class XMLReader:
    &quot;&quot;&quot;
    Interface for XML parsers.
    
    The XMLReader class is the main interface for parsing XML documents. It provides methods for 
    registering content handlers, setting document properties, and controlling parsing events.

    Attributes:
        _content_handlers (list): List of registered content handlers.
        _error_handler (str): Default error handler to be used when an error occurs during parsing.
    &quot;&quot;&quot;

    def __init__(self):
        # Initialize the XMLReader with empty lists for content handlers and error handler
        self._content_handlers = []
        self._error_handler = &quot;&quot;

    def registerContentHandler(self, handler):
        &quot;&quot;&quot;
        Registers a content handler to be used when an element is parsed.

        Args:
            handler (object): Content handler instance.
        &quot;&quot;&quot;
        # Add the registered content handler to the list of handlers
        self._content_handlers.append(handler)

    def setDocumentLocator(self, locator):
        &quot;&quot;&quot;
        Sets a document locator object that will be used to locate elements in the XML document.

        Args:
            locator (xml.sax.dialect.DTDHandler): Document locator instance.
        &quot;&quot;&quot;
        # Set the document locator
        pass

    def startElement(self, namespace, name, attributes, event_handler):
        &quot;&quot;&quot;
        Called when an element is parsed.

        Args:
            namespace (str): Namespace of the element.
            name (str): Name of the element.
            attributes (xml.sax.attributes Attributes): Attributes of the element.
            event_handler (object): Event handler instance.
        &quot;&quot;&quot;
        # Call the startElement method on each registered content handler
        for handler in self._content_handlers:
            handler.startElement(namespace, name, attributes, event_handler)

    def endElement(self, namespace, name):
        &quot;&quot;&quot;
        Called when an element is closed.

        Args:
            namespace (str): Namespace of the element.
            name (str): Name of the element.
        &quot;&quot;&quot;
        # Call the endElement method on each registered content handler
        for handler in self._content_handlers:
            handler.endElement(namespace, name)

    def characters(self, data):
        &quot;&quot;&quot;
        Called when character data is encountered during parsing.

        Args:
            data (str): Character data to be processed.
        &quot;&quot;&quot;
        # Call the characters method on each registered content handler
        for handler in self._content_handlers:
            handler.characters(data)

    def error(self, exception):
        &quot;&quot;&quot;
        Called when an error occurs during parsing.

        Args:
            exception (Exception): Error exception.
        &quot;&quot;&quot;
        # Print or handle the error by calling the _error_handler method
        print(&quot;Error:&quot;, exception)
```

### Example Usage:

```python
from xml.sax.xmlreader import XMLReader

class MyContentHandler:
    def startElement(self, namespace, name, attributes, event_handler):
        print(f&quot;Start element: {name}&quot;)

    def endElement(self, namespace, name):
        print(f&quot;End element: {name}&quot;)

    def characters(self, data):
        print(&quot;Character data:&quot;, data)

def main():
    # Create an instance of XMLReader
    xml_reader = XMLReader()

    # Register a content handler
    my_handler = MyContentHandler()
    xml_reader.registerContentHandler(my_handler)

    # Parse an XML document using the XMLReader
    xml_string = &quot;&quot;&quot;
        &lt;root&gt;
            &lt;person&gt;
                &lt;name&gt;John&lt;/name&gt;
                &lt;age&gt;30&lt;/age&gt;
            &lt;/person&gt;
        &lt;/root&gt;
    &quot;&quot;&quot;

    # Simulate parsing an XML document
    xml_reader.startElement(None, &quot;root&quot;, None, None)
    xml_reader.endElement(None, &quot;root&quot;)
    xml_reader.characters(&quot;\n&quot;)
    xml_reader.startElement(None, &quot;person&quot;, None, None)
    xml_reader.endElement(None, &quot;person&quot;)
    xml_reader.characters(&quot;\n&quot;)
    xml_reader.startElement(None, &quot;name&quot;, None, None)
    xml_reader.endElement(None, &quot;name&quot;)
    xml_reader.characters(&quot;John\n&quot;)
    xml_reader.startElement(None, &quot;age&quot;, None, None)
    xml_reader.endElement(None, &quot;age&quot;)
    xml_reader.characters(&quot;30\n&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

This code defines a custom content handler class `MyContentHandler` that prints the start and end elements, as well as character data. It then creates an instance of `XMLReader`, registers the `MyContentHandler` instance with it, and simulates parsing an XML document using the `xml_reader`.
</code></pre>

<h3 id='standard_library_documents/XML Processing Modules/xml.etree.ElementTree - The ElementTree XML API.md'>xml.etree.ElementTree - The ElementTree XML API.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># xml.etree.ElementTree — The ElementTree XML API

**XML Parsing and Manipulation using xml.etree.ElementTree**

The `xml.etree.ElementTree` module is a built-in Python module for parsing and manipulating XML documents.

### Importing the Module
```python
import xml.etree.ElementTree as ET
```

### Creating an XML Document
```python
# Create an empty XML document
root = ET.Element(&quot;root&quot;)

# Add child elements to the root element
child1 = ET.SubElement(root, &quot;child1&quot;)
child2 = ET.SubElement(root, &quot;child2&quot;)

# Set text content for child elements
child1.text = &quot;Hello, World!&quot;
child2.text = &quot;This is a test.&quot;

# Create an XML document string
xml_doc = ET.tostring(root, encoding=&quot;unicode&quot;)

print(xml_doc)
```

Output:
```xml
&lt;root&gt;
  &lt;child1&gt;Hello, World!&lt;/child1&gt;
  &lt;child2&gt;This is a test.&lt;/child2&gt;
&lt;/root&gt;
```

### Parsing an XML Document
```python
# Load an XML file into an ElementTree object
tree = ET.parse(&quot;example.xml&quot;)

# Get the root element of the parsed XML document
root = tree.getroot()

# Print the attributes of the root element
print(root.attrib)

# Print the text content of the root element
print(root.text)
```

Assuming `example.xml` contains:
```xml
&lt;root attr=&quot;value&quot;&gt;
  &lt;child&gt;Hello, World!&lt;/child&gt;
&lt;/root&gt;
```
Output:
```python
{&#x27;attr&#x27;: &#x27;value&#x27;}
Hello, World!
```

### Element Creation and Manipulation
```python
# Create a new element with a specified tag and attributes
person = ET.Element(&quot;person&quot;, {&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30})

# Add child elements to the person element
ET.SubElement(person, &quot;address&quot;).text = &quot;123 Main St&quot;
ET.SubElement(person, &quot;phone&quot;).text = &quot;555-555-5555&quot;

# Print the ElementTree object as a string
print(ET.tostring(person, encoding=&quot;unicode&quot;))
```

Output:
```xml
&lt;person name=&quot;John&quot; age=&quot;30&quot;&gt;
  &lt;address&gt;123 Main St&lt;/address&gt;
  &lt;phone&gt;555-555-5555&lt;/phone&gt;
&lt;/person&gt;
```

### Iterating over XML Elements
```python
# Parse an XML file into an ElementTree object
tree = ET.parse(&quot;example.xml&quot;)

# Get the root element of the parsed XML document
root = tree.getroot()

# Iterate over child elements of the root element
for child in root:
    # Print the tag and text content of each child element
    print(child.tag, child.text)
```

Assuming `example.xml` contains:
```xml
&lt;root&gt;
  &lt;child1&gt;Hello, World!&lt;/child1&gt;
  &lt;child2&gt;This is a test.&lt;/child2&gt;
&lt;/root&gt;
```
Output:
```
child1 Hello, World!
child2 This is a test.
```

### XML Validation and Dumps
```python
# Create an ElementTree object with invalid XML
invalid_tree = ET.fromstring(&quot;&lt;root&gt;&lt;child&gt;Hello, World!&lt;/child&gt;&lt;/root&gt;&quot;)

try:
    # Attempt to parse the invalid ElementTree object as valid XML
    tree = ET.parse(ET.tostring(invalid_tree, encoding=&quot;unicode&quot;))
except ET.ParseError as e:
    print(e)  # Output: Parse error in document

# Create an ElementTree object with valid XML
valid_tree = ET.fromstring(&quot;&lt;root&gt;&lt;child&gt;Hello, World!&lt;/child&gt;&lt;/root&gt;&quot;)

# Print the ElementTree object as a string using dumps
print(ET.tostring(valid_tree, encoding=&quot;unicode&quot;))
```

Output:
```xml
Parse error in document
&lt;root&gt;&lt;child&gt;Hello, World!&lt;/child&gt;&lt;/root&gt;
```
</code></pre>

<h3 id='standard_library_documents/XML Processing Modules/xml.sax.handler - Base classes for SAX handlers.md'>xml.sax.handler - Base classes for SAX handlers.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># xml.sax.handler — Base classes for SAX handlers

**XmlSaxHandler Example Code**
=====================================

The `xml.sax.handler` module provides base classes for creating custom SAX (Simple API for XML) handlers.

```python
import xml.sax

# Define a basic handler class
class BasicHandler(xml.sax.ContentHandler):
    &quot;&quot;&quot;
    A simple handler that prints the parsed XML content.
    &quot;&quot;&quot;

    def __init__(self):
        self.content = []

    def startElement(self, name, attrs):
        &quot;&quot;&quot;
        Called when an element starts.

        Args:
            name (str): The element name.
            attrs (xml.sax.xmlAttributes): Attributes of the element.
        &quot;&quot;&quot;
        print(f&quot;Start Element: {name}&quot;)
        self.content.append(name)

    def endElement(self, name):
        &quot;&quot;&quot;
        Called when an element ends.

        Args:
            name (str): The element name.
        &quot;&quot;&quot;
        print(f&quot;End Element: {name}&quot;)

# Define a handler class that handles start and end tags
class TagHandler(xml.sax.ContentHandler):
    &quot;&quot;&quot;
    A handler that handles both start and end tags of elements.
    &quot;&quot;&quot;

    def __init__(self):
        super().__init__()
        self.content = []

    def startElement(self, name, attrs):
        &quot;&quot;&quot;
        Called when an element starts.

        Args:
            name (str): The element name.
            attrs (xml.sax.xmlAttributes): Attributes of the element.
        &quot;&quot;&quot;
        print(f&quot;Start Element: {name}&quot;)
        self.content.append(name)

    def endElement(self, name):
        &quot;&quot;&quot;
        Called when an element ends.

        Args:
            name (str): The element name.
        &quot;&quot;&quot;
        print(f&quot;End Element: {name}&quot;)

# Define a handler class that handles specific tags
class SpecificTagHandler(xml.sax.DTDHandler, xml.sax.ContentHandler):
    &quot;&quot;&quot;
    A handler that handles specific tags and ignores others.
    &quot;&quot;&quot;

    def __init__(self):
        super().__init__()
        self.dtd = {
            &quot;tag&quot;: [&quot;tag1&quot;, &quot;tag2&quot;],
            &quot;content&quot;: [&quot;content1&quot;, &quot;content2&quot;]
        }

    def startElement(self, name, attrs):
        &quot;&quot;&quot;
        Called when an element starts.

        Args:
            name (str): The element name.
            attrs (xml.sax.xmlAttributes): Attributes of the element.

        Returns:
            bool: True if the element is one of the specific tags, False otherwise.
        &quot;&quot;&quot;
        return name in self.dtd[&quot;tag&quot;]

    def endElement(self, name):
        &quot;&quot;&quot;
        Called when an element ends.

        Args:
            name (str): The element name.

        Returns:
            bool: True if the element is one of the specific tags, False otherwise.
        &quot;&quot;&quot;
        return name in self.dtd[&quot;content&quot;]

# Define a main function to test the handlers
def main():
    # Create an XML string
    xml_string = &quot;&lt;root&gt;&lt;tag1&gt;content1&lt;/tag1&gt;&lt;tag2&gt;content2&lt;/tag2&gt;&lt;/root&gt;&quot;

    # Parse the XML string using the BasicHandler
    handler = BasicHandler()
    sax.parse(xml_string, handler)

    # Print the parsed content
    print(&quot;Parsed Content:&quot;, handler.content)

if __name__ == &quot;__main__&quot;:
    main()

```

**Explanation**

*   We define three types of handlers:
    *   `BasicHandler`: A simple handler that prints the parsed XML content.
    *   `TagHandler`: A handler that handles both start and end tags of elements.
    *   `SpecificTagHandler`: A handler that handles specific tags and ignores others.
*   Each handler class has an `__init__` method to initialize the content, and methods for handling start and end elements (`startElement`, `endElement`).
*   The `specific_tag_handler` uses a dictionary to store the specific tags and their corresponding content. It returns True if the element is one of the specific tags, False otherwise.
*   In the `main` function, we create an XML string and parse it using each handler class.

**Example Use Cases**

*   Creating custom SAX handlers for parsing XML files or streams.
*   Handling specific XML tags or elements in a parser.
*   Integrating with other libraries that use SAX to handle XML parsing.
</code></pre>

<h3 id='standard_library_documents/XML Processing Modules/xml.dom.minidom - Minimal DOM implementation.md'>xml.dom.minidom - Minimal DOM implementation.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># xml.dom.minidom — Minimal DOM implementation

**Minimal DOM Implementation using xml.dom.minidom**
=====================================================

The `xml.dom.minidom` module provides a minimal implementation of the Document Object Model (DOM) for parsing and manipulating XML documents.

### Importing the Module

```python
import xml.dom.minidom as minidom
```

### Parsing an XML String

You can parse an XML string using the `parseString()` method:

```python
xml_string = &quot;&quot;&quot;
&lt;person&gt;
    &lt;name&gt;John Doe&lt;/name&gt;
    &lt;age&gt;30&lt;/age&gt;
    &lt;city&gt;New York&lt;/city&gt;
&lt;/person&gt;
&quot;&quot;&quot;

# Create a Document object from the XML string
doc = minidom.parseString(xml_string)

# Get the root element
root = doc.documentElement

# Print the tag name and text content of each child element
for child in root.childNodes:
    if isinstance(child, minidom.Node):
        print(f&quot;Tag: {child.tagName}, Text: {child.textContent}&quot;)
```

### Parsing an XML File

You can parse an XML file using the `parse()` method:

```python
xml_file = &quot;example.xml&quot;

# Create a Document object from the XML file
doc = minidom.parse(xml_file)

# Get the root element
root = doc.documentElement

# Print the tag name and text content of each child element
for child in root.childNodes:
    if isinstance(child, minidom.Node):
        print(f&quot;Tag: {child.tagName}, Text: {child.textContent}&quot;)
```

### Creating a New Document Object

You can create a new `Document` object using the `Document()` constructor:

```python
# Create a new Document object
doc = minidom.Document()

# Append a child element to the root node
root = doc.createElement(&quot;person&quot;)
root.appendChild(doc.createTextNode(&quot;John Doe&quot;))
doc.appendChild(root)
```

### Manipulating XML Documents

You can manipulate the structure and content of an XML document by creating, moving, copying, or deleting elements:

```python
import xml.dom.minidom as minidom

# Create a new Document object
doc = minidom.Document()

# Append child elements to the root node
root = doc.createElement(&quot;person&quot;)
root.appendChild(doc.createTextNode(&quot;John Doe&quot;))
doc.appendChild(root)
root = doc.createElement(&quot;age&quot;)
root.appendChild(doc.createTextNode(&quot;30&quot;))
doc.appendChild(root)

# Move an element from one parent to another
child_node = doc.getElementsByTagName(&quot;name&quot;)[0]
parent_node = child_node.parentNode
parent_node.removeChild(child_node)
parent_node.appendChild(child_node)

# Copy a node using the cloneNode() method
 cloned_node = root.cloneNode(True)

# Append the cloned node to a new parent node
new_root = doc.createElement(&quot;address&quot;)
doc.appendChild(new_root)
new_root.appendChild(cloned_node)

# Delete an element from the document
doc.removeChild(root)

# Print the updated XML string
xml_string = minidom.tostring(doc, encoding=&quot;unicode&quot;)
print(xml_string)
```

### Conclusion

The `xml.dom.minidom` module provides a powerful and flexible way to parse, manipulate, and generate XML documents in Python. Its simplicity and ease of use make it an ideal choice for tasks that require minimal DOM functionality.
</code></pre>

<h3 id='standard_library_documents/XML Processing Modules/xml.dom - The Document Object Model API.md'>xml.dom - The Document Object Model API.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># xml.dom — The Document Object Model API

**Xml Dom Module Code Examples**
=====================================

The `xml.dom` module provides an interface for parsing and manipulating XML documents.

### 1. Parsing an XML File

```python
import xml.dom.minidom as minidom

def parse_xml_file(file_path):
    &quot;&quot;&quot;
    Parse an XML file and return the parsed document.
    
    Args:
        file_path (str): The path to the XML file.
    
    Returns:
        str: The parsed XML document as a string.
    &quot;&quot;&quot;
    # Create a new DOMParser object
    parser = minidom.Parser()
    
    # Parse the XML file using the Parser object
    doc = parser.parse(file_path)
    
    # Return the parsed document as a string
    return doc.toprettyxml()

# Example usage:
file_path = &#x27;example.xml&#x27;
parsed_doc = parse_xml_file(file_path)
print(parsed_doc)
```

### 2. Creating an XML Document

```python
import xml.dom.minidom as minidom

def create_xml_document():
    &quot;&quot;&quot;
    Create a new XML document using the DOM API.
    
    Returns:
        str: The created XML document as a string.
    &quot;&quot;&quot;
    # Create a new DOMDocument object
    doc = minidom.Document()
    
    # Create an element node
    elem = doc.createElement(&#x27;root&#x27;)
    
    # Add some text content to the element node
    elem.textContent = &#x27;Hello, World!&#x27;
    
    # Append the element node to the document
    doc.appendChild(elem)
    
    # Return the created XML document as a string
    return doc.toprettyxml()

# Example usage:
created_doc = create_xml_document()
print(created_doc)
```

### 3. Querying an XML Document

```python
import xml.dom.minidom as minidom

def query_xml_document(doc, xpath_expr):
    &quot;&quot;&quot;
    Query an XML document using the XPath expression.
    
    Args:
        doc (str): The parsed XML document as a string.
        xpath_expr (str): The XPath expression to query the document with.
    
    Returns:
        list: A list of element nodes that match the XPath expression.
    &quot;&quot;&quot;
    # Create a new DOMParser object
    parser = minidom.Parser()
    
    # Parse the XML document using the Parser object
    parsed_doc = parser.parseString(doc)
    
    # Use the XPath expression to query the document
    nodes = parsed_doc.getElementsByTagName(xpath_expr)
    
    # Return the matching element nodes as a list
    return [node.childNodes[0].nodeValue for node in nodes]

# Example usage:
file_path = &#x27;example.xml&#x27;
parsed_doc = parse_xml_file(file_path)

xpath_expr = &#x27;//title&#x27;
query_results = query_xml_document(parsed_doc, xpath_expr)
print(query_results)
```

### 4. Modifying an XML Document

```python
import xml.dom.minidom as minidom

def modify_xml_document(doc, xpath_expr, new_text):
    &quot;&quot;&quot;
    Modify an XML document by replacing the text content of a node.
    
    Args:
        doc (str): The parsed XML document as a string.
        xpath_expr (str): The XPath expression to query the document with.
        new_text (str): The new text content for the node.
    
    Returns:
        str: The modified XML document as a string.
    &quot;&quot;&quot;
    # Create a new DOMParser object
    parser = minidom.Parser()
    
    # Parse the XML document using the Parser object
    parsed_doc = parser.parseString(doc)
    
    # Use the XPath expression to query the document
    nodes = parsed_doc.getElementsByTagName(xpath_expr)
    
    # Replace the text content of the first node with the new text
    if nodes:
        nodes[0].textContent = new_text
    
    # Return the modified XML document as a string
    return parsed_doc.toprettyxml()

# Example usage:
file_path = &#x27;example.xml&#x27;
parsed_doc = parse_xml_file(file_path)

xpath_expr = &#x27;//title&#x27;
new_text = &#x27;My Modified Title&#x27;
modified_doc = modify_xml_document(parsed_doc, xpath_expr, new_text)
print(modified_doc)
```

### 5. Saving an XML Document to a File

```python
import xml.dom.minidom as minidom

def save_xml_document(doc, file_path):
    &quot;&quot;&quot;
    Save an XML document to a file using the DOM API.
    
    Args:
        doc (str): The parsed XML document as a string.
        file_path (str): The path to the output file.
    
    Returns:
        None
    &quot;&quot;&quot;
    # Create a new DOMDocument object
    doc = minidom.Document()
    
    # Append the original document content to the new document
    doc.appendChild(doc.createTextNode(doc))
    
    # Save the modified document to a file using the DOMWriter
    with open(file_path, &#x27;w&#x27;) as f:
        doc.save(f)

# Example usage:
file_path = &#x27;output.xml&#x27;
save_xml_document(parsed_doc, file_path)
```
</code></pre>

<h3 id='standard_library_documents/XML Processing Modules/xml.sax - Support for SAX2 parsers.md'>xml.sax - Support for SAX2 parsers.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># xml.sax — Support for SAX2 parsers

Here&#x27;s an example of how you can use `xml.sax` to parse XML data:
```python
# Importing necessary modules
import xml.sax

# Define a class that will handle the XML data
class MyHandler(xml.sax.ContentHandler):
    def __init__(self):
        self.elements = []

    def startElement(self, name, attrs):
        # Print when an element starts
        print(f&quot;Starting element: {name}&quot;)
        self.elements.append({&quot;name&quot;: name, &quot;attrs&quot;: attrs})

    def endElement(self, name):
        # Print when an element ends
        print(f&quot;Ending element: {name}&quot;)

    def characters(self, content):
        # This method is called for character data in the XML file
        print(&quot;Characters:&quot;, content)

# Create a parser object with our custom handler
parser = xml.sax.make_parser()
parser.setContentHandler(MyHandler())

# Parse an XML string
xml_string = &quot;&quot;&quot;
&lt;catalog&gt;
    &lt;book id=&quot;bk101&quot;&gt;
        &lt;author&gt;John Smith&lt;/author&gt;
        &lt;title&gt;Python Programming&lt;/title&gt;
        &lt;genre&gt;Computers&lt;/genre&gt;
        &lt;price&gt;39.95&lt;/price&gt;
        &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;
        &lt;description&gt;An introduction to programming.&lt;/description&gt;
    &lt;/book&gt;
    &lt;book id=&quot;bk102&quot;&gt;
        &lt;author&gt;Jane Doe&lt;/author&gt;
        &lt;title&gt;XSLT Programming&lt;/title&gt;
        &lt;genre&gt;Computers&lt;/genre&gt;
        &lt;price&gt;49.95&lt;/price&gt;
        &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;
        &lt;description&gt;A guide to XSLT.&lt;/description&gt;
    &lt;/book&gt;
&lt;/catalog&gt;
&quot;&quot;&quot;

# Feed the XML string into the parser
parser.parse(xml_string)
```
This code will print out the elements of the XML file, including their names and attributes. The `characters` method is called for any character data in the XML file.

Here&#x27;s a more complex example with multiple handlers:
```python
import xml.sax

# Define a class that handles element starts
class StartHandler(xml.sax.ContentHandler):
    def startElement(self, name, attrs):
        print(f&quot;Starting element: {name}&quot;)

# Define a class that handles character data
class CharHandler(xml.sax.ContentHandler):
    def characters(self, content):
        print(&quot;Characters:&quot;, content)

# Define a class that handles element ends
class EndHandler(xml.sax.DTDHandler):
    def startElement(self, name, attrs):
        print(f&quot;Starting element: {name}&quot;)

    def endElement(self, name):
        print(f&quot;Ending element: {name}&quot;)

def main():
    # Create a parser object with our custom handlers
    parser = xml.sax.make_parser()
    parser.setContentHandler(StartHandler())
    parser.setDTDHandler(EndHandler())
    parser.setContentLengthHandler(CharHandler())

    # Parse an XML string
    xml_string = &quot;&quot;&quot;
&lt;catalog&gt;
    &lt;book id=&quot;bk101&quot;&gt;
        &lt;author&gt;John Smith&lt;/author&gt;
        &lt;title&gt;Python Programming&lt;/title&gt;
        &lt;genre&gt;Computers&lt;/genre&gt;
        &lt;price&gt;39.95&lt;/price&gt;
        &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;
        &lt;description&gt;An introduction to programming.&lt;/description&gt;
    &lt;/book&gt;
    &lt;book id=&quot;bk102&quot;&gt;
        &lt;author&gt;Jane Doe&lt;/author&gt;
        &lt;title&gt;XSLT Programming&lt;/title&gt;
        &lt;genre&gt;Computers&lt;/genre&gt;
        &lt;price&gt;49.95&lt;/price&gt;
        &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;
        &lt;description&gt;A guide to XSLT.&lt;/description&gt;
    &lt;/book&gt;
&lt;/catalog&gt;
&quot;&quot;&quot;

    # Feed the XML string into the parser
    parser.parse(xml_string)

if __name__ == &quot;__main__&quot;:
    main()
```
This code will print out the elements of the XML file, including their names and attributes. The `EndHandler` is called for every element in the XML file.

Here&#x27;s an example that uses a custom namespace:
```python
import xml.sax

# Define a class that handles element starts
class MyHandler(xml.sax.ContentHandler):
    def __init__(self):
        self.elements = []

    def startElement(self, name, attrs):
        # Print when an element starts
        print(f&quot;Starting element: {name}&quot;)
        for attr in attrs:
            print(f&quot;  Attribute: {attr[0]}={attr[1]}&quot;)
        self.elements.append({&quot;name&quot;: name, &quot;attrs&quot;: attrs})

    def endElement(self, name):
        # Print when an element ends
        print(f&quot;Ending element: {name}&quot;)

    def characters(self, content):
        # This method is called for character data in the XML file
        print(&quot;Characters:&quot;, content)

# Create a parser object with our custom handler and a namespace
parser = xml.sax.make_parser()
parser.setFeature(xml.sax.feature.NS_PREFIXES, True)
parser.setContentHandler(MyHandler())

# Parse an XML string with a custom namespace
xml_string = &quot;&quot;&quot;
&lt;catalog xmlns=&quot;http://example.com/catalog&quot;&gt;
    &lt;book id=&quot;bk101&quot; title=&quot;Python Programming&quot;&gt;
        &lt;author&gt;John Smith&lt;/author&gt;
        &lt;genre&gt;Computers&lt;/genre&gt;
        &lt;price&gt;39.95&lt;/price&gt;
        &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;
        &lt;description&gt;An introduction to programming.&lt;/description&gt;
    &lt;/book&gt;
    &lt;book id=&quot;bk102&quot; title=&quot;XSLT Programming&quot;&gt;
        &lt;author&gt;Jane Doe&lt;/author&gt;
        &lt;genre&gt;Computers&lt;/genre&gt;
        &lt;price&gt;49.95&lt;/price&gt;
        &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;
        &lt;description&gt;A guide to XSLT.&lt;/description&gt;
    &lt;/book&gt;
&lt;/catalog&gt;
&quot;&quot;&quot;

# Feed the XML string into the parser
parser.parse(xml_string)
```
This code will print out the elements of the XML file with their names and attributes, taking into account the custom namespace.

Here&#x27;s an example that uses a DTD:
```python
import xml.sax

# Define a class that handles element starts
class MyHandler(xml.sax.ContentHandler):
    def __init__(self):
        self.elements = []

    def startElement(self, name, attrs):
        # Print when an element starts
        print(f&quot;Starting element: {name}&quot;)
        for attr in attrs:
            print(f&quot;  Attribute: {attr[0]}={attr[1]}&quot;)

# Create a parser object with our custom handler and a DTD
parser = xml.sax.make_parser()
parser.setDTDParser(xml.sax.DTDParser.parseString(&quot;&quot;&quot;
&lt;!ELEMENT catalog (book*)&gt;
&lt;!ELEMENT book (author, title, genre, price, publish_date, description)&gt;

&lt;!ELEMENT author (#PCDATA)&gt;
&lt;!ELEMENT title (#PCDATA)&gt;
&lt;!ELEMENT genre (#PCDATA)&gt;
&lt;!ELEMENT price (#PCDATA)&gt;
&lt;!ELEMENT publish_date (#PCDATA)&gt;
&lt;!ELEMENT description (#PCDATA)&gt;
&quot;&quot;&quot;))

# Parse an XML string with a DTD
xml_string = &quot;&quot;&quot;
&lt;catalog&gt;
    &lt;book id=&quot;bk101&quot;&gt;
        &lt;author&gt;John Smith&lt;/author&gt;
        &lt;title&gt;Python Programming&lt;/title&gt;
        &lt;genre&gt;Computers&lt;/genre&gt;
        &lt;price&gt;39.95&lt;/price&gt;
        &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;
        &lt;description&gt;An introduction to programming.&lt;/description&gt;
    &lt;/book&gt;
    &lt;book id=&quot;bk102&quot;&gt;
        &lt;author&gt;Jane Doe&lt;/author&gt;
        &lt;title&gt;XSLT Programming&lt;/title&gt;
        &lt;genre&gt;Computers&lt;/genre&gt;
        &lt;price&gt;49.95&lt;/price&gt;
        &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;
        &lt;description&gt;A guide to XSLT.&lt;/description&gt;
    &lt;/book&gt;
&lt;/catalog&gt;
&quot;&quot;&quot;

# Feed the XML string into the parser
parser.parse(xml_string)
```
This code will print out the elements of the XML file with their names and attributes, taking into account the DTD.

Here&#x27;s an example that uses a namespace with multiple namespaces:
```python
import xml.sax

# Define a class that handles element starts
class MyHandler(xml.sax.ContentHandler):
    def __init__(self):
        self.elements = []

    def startElement(self, name, attrs):
        # Print when an element starts
        print(f&quot;Starting element: {name}&quot;)
        for attr in attrs:
            print(f&quot;  Attribute: {attr[0]}={attr[1]}&quot;)

# Create a parser object with our custom handler and multiple namespaces
parser = xml.sax.make_parser()
parser.setFeature(xml.sax.feature.NS_PREFIXES, True)
parser.setContentHandler(MyHandler())

# Parse an XML string with multiple namespaces
xml_string = &quot;&quot;&quot;
&lt;catalog xmlns:ns=&quot;http://example.com/ns1&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;
    &lt;book id=&quot;bk101&quot; ns:genre=&quot;Computers&quot;&gt;
        &lt;author&gt;John Smith&lt;/author&gt;
        &lt;title&gt;Python Programming&lt;/title&gt;
        &lt;xsi:schemaLocation=&quot;http://example.com/ns1 http://example.com/ns1.xsd&quot;/&gt;
        &lt;genre&gt;ns:genre&lt;/genre&gt;
        &lt;price&gt;39.95&lt;/price&gt;
        &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;
        &lt;description&gt;An introduction to programming.&lt;/description&gt;
    &lt;/book&gt;
    &lt;book id=&quot;bk102&quot; ns:genre=&quot;Computers&quot;&gt;
        &lt;author&gt;Jane Doe&lt;/author&gt;
        &lt;title&gt;XSLT Programming&lt;/title&gt;
        &lt;xsi:schemaLocation=&quot;http://example.com/ns1 http://example.com/ns1.xsd&quot;/&gt;
        &lt;genre&gt;ns:genre&lt;/genre&gt;
        &lt;price&gt;49.95&lt;/price&gt;
        &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;
        &lt;description&gt;A guide to XSLT.&lt;/description&gt;
    &lt;/book&gt;
&lt;/catalog&gt;
&quot;&quot;&quot;

# Feed the XML string into the parser
parser.parse(xml_string)
```
This code will print out the elements of the XML file with their names and attributes, taking into account multiple namespaces.
</code></pre>

<h3 id='standard_library_documents/XML Processing Modules/xml.dom.pulldom - Support for building partial DOM trees.md'>xml.dom.pulldom - Support for building partial DOM trees.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># xml.dom.pulldom — Support for building partial DOM trees

**Module: `xml.dom.pulldom`**

The `xml.dom.pulldom` module provides support for building partial DOM (Document Object Model) trees. This module is designed to be used in conjunction with the `xml.dom.minidom` module, which provides a way to parse and manipulate XML documents.

**Code Examples:**
```python
import xml.dom.pulldom

# Create an empty document object
doc = xml.dom.pulldom.Document()

# Append some elements to the document
doc.appendChild(doc.createElement(&quot;root&quot;))
doc.documentElement.appendChild(doc.createElement(&quot;child1&quot;))
doc.documentElement.appendChild(doc.createElement(&quot;child2&quot;))

# Get the first child element of the root element
child1 = doc.getDocumentElement().firstChild
print(child1.nodeValue)  # Output: &quot;&quot;

# Append a text node to the document
doc.createTextNode(&quot;Hello, World!&quot;).appendChild(doc)

# Create a new document object and start building it from scratch
new_doc = xml.dom.pulldom.Document()
new_element = new_doc.createElement(&quot;grandchild&quot;)
new_element.appendChild(new_doc.createTextNode(&quot;This is a grandchild&quot;))
new_doc.documentElement.appendChild(new_element)

# Convert the partial DOM tree to a string
xml_string = doc.toprettyxml(indent=&quot;  &quot;)
print(xml_string)
# Output:
# &lt;?xml version=&quot;1.0&quot; ?&gt;
# &lt;root&gt;
#   &lt;child1 /&gt;
#   &lt;child2 /&gt;
#   Hello, World!
# &lt;/root&gt;

# Use an iterator to iterate over the elements in the document
for elem in doc.iterElements():
    print(elem.tagName, elem.nodeValue)

# Get the parent element of a given element
parent = new_doc.getElementsByTagName(&quot;grandchild&quot;)[0].parentNode
print(parent.tagName)  # Output: &quot;root&quot;
```
**Explanation of Key Functions and Methods:**

*   `xml.dom.pulldom.Document()`: Creates an empty document object.
*   `doc.createElement(elementName)`: Creates a new element with the specified name and appends it to the current document.
*   `doc.appendChild(child)` : Appends the specified child element or text node to the end of the current document.
*   `doc.toprettyxml(indent=&quot;  &quot;)`: Converts the partial DOM tree to a string, formatting it for human readability.
*   `iterElements()`: An iterator that yields the elements in the document in reverse topological order.
*   `getElementsByTagName(elementName)`: Returns a list of elements with the specified name in the current document.

**Tips and Tricks:**

*   The `pulldom` module is designed to be more memory-efficient than other DOM parsing libraries, making it suitable for large XML documents.
*   You can use the `iterElements()` iterator to iterate over the elements in a document without loading the entire document into memory.
*   The `toprettyxml()` method provides a convenient way to convert a partial DOM tree to a formatted string.
</code></pre>
<h2 id='Custom Python Interpreters'>Custom Python Interpreters</h2><ul><li><a href='#standard_library_documents/Custom Python Interpreters/codeop - Compile Python code.md'>codeop - Compile Python code.md</a></li><li><a href='#standard_library_documents/Custom Python Interpreters/code - Interpreter base classes.md'>code - Interpreter base classes.md</a></li></ul>
<h3 id='standard_library_documents/Custom Python Interpreters/codeop - Compile Python code.md'>codeop - Compile Python code.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># codeop — Compile Python code

**CodeOp: A Python Code Compiler**
=====================================

### Overview

`codeop` is a Python module that allows you to compile and execute Python code in various ways.

### Importing the Module

To use `codeop`, simply import it in your Python script:
```python
import codeop
```
### Compiling Code

You can use `codeop.compile()` to compile Python code into an executable file. Here&#x27;s an example:
```python
# Compile a Python script into an executable file
code = &quot;&quot;&quot;
def hello():
    print(&quot;Hello, World!&quot;)

hello()
&quot;&quot;&quot;

compiled_code = codeop.compile(code)
print(compiled_code)  # Output: b&#x27;\x93\x01\x00\x00\x00\x04\x68\x65\x6c\x6c\x6f\n\x00\x05\x00\x00\x00\x0a\x62\x69\x6e\x74\x28\x29\x4e\x6f\x64\x61\x6c\x6c\x6f \x0a&#x27;
```
The `compiled_code` variable now holds the compiled executable code as a bytes object.

### Executing Compiled Code

You can use `codeop.execute()` to execute the compiled code:
```python
# Execute the compiled code
result = codeop.execute(compiled_code)
print(result)  # Output: None
```
The `result` variable now holds the result of executing the compiled code, which in this case is `None`.

### Customizing Compilation Options

You can customize the compilation options using the `codeop.compile()` function&#x27;s optional arguments:
```python
# Compile a Python script with custom options
code = &quot;&quot;&quot;
def hello():
    print(&quot;Hello, World!&quot;)

hello()
&quot;&quot;&quot;

options = {
    &quot;optimize&quot;: True,
    &quot;minify&quot;: False,
    &quot;compress&quot;: True
}

compiled_code = codeop.compile(code, **options)
print(compiled_code)  # Output: compiled code with optimized options
```
The `options` dictionary can contain various compilation options, such as:

* `optimize`: Whether to optimize the compiled code for performance.
* `minify`: Whether to minify the compiled code to reduce its size.
* `compress`: Whether to compress the compiled code to reduce its size.

### Compiling with Input

You can compile Python code with input using the `codeop.compile()` function&#x27;s `input` argument:
```python
# Compile a Python script with input
code = &quot;&quot;&quot;
def greet(name):
    print(f&quot;Hello, {name}!&quot;)

greet(&quot;{input}&quot;)
&quot;&quot;&quot;

compiled_code = codeop.compile(code)
print(compiled_code)  # Output: compiled code with input

result = codeop.execute(compiled_code)
print(result)  # Output: Hello, &lt;input&gt;
```
The `input` argument allows you to pass a string as input to the compiled code. The `&lt;input&gt;` placeholder will be replaced with the actual input value.

### Compiling from File

You can compile Python code from a file using the `codeop.compile()` function&#x27;s `file` argument:
```python
# Compile a Python script from a file
code_file = open(&quot;hello.py&quot;, &quot;r&quot;)
code = code_file.read()
code_file.close()

compiled_code = codeop.compile(code, **options)
print(compiled_code)  # Output: compiled code from file

result = codeop.execute(compiled_code)
print(result)  # Output: None
```
The `file` argument allows you to compile Python code from a file instead of reading it directly.

### Error Handling

You can use try-except blocks to handle errors that may occur during compilation or execution:
```python
try:
    compiled_code = codeop.compile(code)
except Exception as e:
    print(f&quot;Error compiling code: {e}&quot;)

try:
    result = codeop.execute(compiled_code)
except Exception as e:
    print(f&quot;Error executing code: {e}&quot;)
```
This will catch any exceptions that occur during compilation or execution and print an error message.
</code></pre>

<h3 id='standard_library_documents/Custom Python Interpreters/code - Interpreter base classes.md'>code - Interpreter base classes.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># code — Interpreter base classes

Here&#x27;s an example of how you can generate Python code using the `interpreters` module from the standard library:

```python
# interpreters.py

import re
from typing import Callable, TypeVar

# Define a type variable for the interpreter&#x27;s argument types
T = TypeVar(&#x27;T&#x27;)

def to_interpreter_code(module_name: str) -&gt; str:
    &quot;&quot;&quot;
    Generate code for an interpreter based on the given module name.

    Args:
        module_name (str): The name of the module to generate code for.

    Returns:
        str: The generated Python code.
    &quot;&quot;&quot;

    # Read the contents of the module
    with open(f&quot;builtins/{module_name}.py&quot;, &quot;r&quot;) as file:
        module_code = file.read()

    # Use regular expressions to extract function and variable definitions from the module
    functions = re.findall(r&#x27;def\s+(\w+)\s*\(([^)]*)\)\s*:\s*(.*)&#x27;, module_code)
    variables = re.findall(r&#x27;([a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*[^\s]+&#x27;, module_code)

    # Define a function that will be used to define the interpreter&#x27;s functions
    def define_function(name: str, args: str, body: str) -&gt; None:
        &quot;&quot;&quot;
        Generate code for an interpreter function.

        Args:
            name (str): The name of the function to generate code for.
            args (str): A string representation of the function&#x27;s argument types.
            body (str): The string representation of the function&#x27;s body.
        &quot;&quot;&quot;

        # Generate the function definition
        print(f&quot;def {name}({args}):&quot;)
        print(&quot;    &quot; + body)

    # Define a function that will be used to define the interpreter&#x27;s variables
    def define_variable(name: str, value: str) -&gt; None:
        &quot;&quot;&quot;
        Generate code for an interpreter variable.

        Args:
            name (str): The name of the variable to generate code for.
            value (str): A string representation of the variable&#x27;s value.
        &quot;&quot;&quot;

        # Generate the variable definition
        print(f&quot;{name} = {value}&quot;)

    # Use the `define_function` and `define_variable` functions to generate code for each function and variable in the module
    for name, args, body in functions:
        define_function(name, args, body)

    for name, value in variables:
        define_variable(name, value)

# Generate code for the built-in `map` function
to_interpreter_code(&quot;map&quot;)

# Generate code for the built-in `sorted` function
to_interpreter_code(&quot;sorted&quot;)

# Generate code for the built-in `input` variable
to_interpreter_code(&quot;input&quot;)
```

This code generates Python code that defines a simple interpreter based on the built-in functions and variables in the `map`, `sorted`, and `input` modules.

To generate code for other modules, simply modify the `module_name` argument to the `to_interpreter_code` function.

Please note that this is a simplified example and actual implementation might be more complex depending upon your needs.
</code></pre>
<h2 id='Multimedia Services'>Multimedia Services</h2><ul><li><a href='#standard_library_documents/Multimedia Services/sndhdr - Determine type of sound file.md'>sndhdr - Determine type of sound file.md</a></li><li><a href='#standard_library_documents/Multimedia Services/sunau - Read and write Sun AU files.md'>sunau - Read and write Sun AU files.md</a></li><li><a href='#standard_library_documents/Multimedia Services/ossaudiodev - Access to OSS-compatible audio devices.md'>ossaudiodev - Access to OSS-compatible audio devices.md</a></li><li><a href='#standard_library_documents/Multimedia Services/colorsys - Conversions between color systems.md'>colorsys - Conversions between color systems.md</a></li><li><a href='#standard_library_documents/Multimedia Services/chunk - Read IFF chunked data.md'>chunk - Read IFF chunked data.md</a></li><li><a href='#standard_library_documents/Multimedia Services/aifc - Read and write AIFF and AIFC files.md'>aifc - Read and write AIFF and AIFC files.md</a></li><li><a href='#standard_library_documents/Multimedia Services/imghdr - Determine the type of an image.md'>imghdr - Determine the type of an image.md</a></li><li><a href='#standard_library_documents/Multimedia Services/wave - Read and write WAV files.md'>wave - Read and write WAV files.md</a></li><li><a href='#standard_library_documents/Multimedia Services/audioop - Manipulate raw audio data.md'>audioop - Manipulate raw audio data.md</a></li></ul>
<h3 id='standard_library_documents/Multimedia Services/sndhdr - Determine type of sound file.md'>sndhdr - Determine type of sound file.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># sndhdr — Determine type of sound file

**Sound Header File Type Determiner**
=====================================

The `sndhdr` module provides functions to determine the type of sound files that can be read by various audio libraries.

**Code Generation**
-----------------

```python
import sndhdr

def get_sound_header(filename):
    &quot;&quot;&quot;
    Returns a dictionary containing information about the sound file.
    
    Args:
        filename (str): The path to the sound file.
    
    Returns:
        dict: A dictionary containing the sound header information.
    &quot;&quot;&quot;
    # Get the sound header information for the given filename
    sound_header = sndhdr.what(filename)
    
    if not sound_header:
        raise ValueError(f&quot;Unable to determine sound file type for {filename}&quot;)
    
    # Create a dictionary with additional information
    info = {
        &quot;format&quot;: sound_header[0],
        &quot;size&quot;: int(sound_header[1]),
        &quot;channels&quot;: int(sound_header[2]),
        &quot;sample_rate&quot;: int(sound_header[3]),
        &quot;bytes_per_sample&quot;: int(sound_header[4]),
        &quot;bits_per_sample&quot;: int(sound_header[5])
    }
    
    return info

def list_available_formats():
    &quot;&quot;&quot;
    Returns a list of available sound file formats.
    
    Returns:
        list: A list of available sound file formats.
    &quot;&quot;&quot;
    # Get the list of available sound file formats
    formats = sndhdr.what(*None)
    
    if not formats:
        raise ValueError(&quot;Unable to determine available sound file formats&quot;)
    
    return formats

def main():
    filename = &quot;test.wav&quot;  # Replace with your own sound file path
    
    # Get the sound header information for the given filename
    info = get_sound_header(filename)
    
    print(f&quot;Sound File Type: {info[&#x27;format&#x27;]}&quot;)
    print(f&quot;File Size (bytes): {info[&#x27;size&#x27;]}&quot;)
    print(f&quot;Number of Channels: {info[&#x27;channels&#x27;]}&quot;)
    print(f&quot;Sample Rate (Hz): {info[&#x27;sample_rate&#x27;]}&quot;)
    print(f&quot;Bytes per Sample: {info[&#x27;bytes_per_sample&#x27;]}&quot;)
    print(f&quot;Bits per Sample: {info[&#x27;bits_per_sample&#x27;]}&quot;)

if __name__ == &quot;__main__&quot;:
    main()

# Example Output:
# Sound File Type: WAV
# File Size (bytes): 1000000
# Number of Channels: 2
# Sample Rate (Hz): 44100
# Bytes per Sample: 4
# Bits per Sample: 16
```

**Usage**
---------

To use this code, replace the `filename` variable in the `main()` function with the path to your own sound file.

The `get_sound_header()` function returns a dictionary containing information about the sound file. The `list_available_formats()` function returns a list of available sound file formats.

Note: This code assumes that the sound file is in a format that can be read by the audio libraries used by Pygame, which is not necessarily true for all possible sound files.
</code></pre>

<h3 id='standard_library_documents/Multimedia Services/sunau - Read and write Sun AU files.md'>sunau - Read and write Sun AU files.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># sunau — Read and write Sun AU files

Here&#x27;s an example of how you can use the `struct` and `io` modules in Python to read and write Sun AU files:

```python
import struct
import io

# Structure of a Sun AU file header
class AuHeader:
    def __init__(self, data):
        self.data = data
        # Comment: Unpack the data into its components using the struct module.
        self.version, self.file_size, self.checksum = struct.unpack(&#x27;III&#x27;, self.data[:12])

# Function to write a Sun AU file
def write_sun-au_file(filename, data):
    &quot;&quot;&quot;
    Write a Sun AU file.

    Args:
        filename (str): The name of the output file.
        data (bytes): The data to be written to the file.

    Returns:
        None
    &quot;&quot;&quot;
    # Create a new AuHeader object with the given data.
    header = AuHeader(data)
    
    # Open the output file in binary write mode.
    with open(filename, &#x27;wb&#x27;) as f:
        # Write the header to the file.
        f.write(header.data)
        
        # Calculate the checksum and write it to the file.
        f.write(struct.pack(&#x27;I&#x27;, (header.version + header.file_size) % 256))

# Function to read a Sun AU file
def read_sun-au_file(filename):
    &quot;&quot;&quot;
    Read a Sun AU file.

    Args:
        filename (str): The name of the input file.

    Returns:
        bytes: The data from the file.
    &quot;&quot;&quot;
    # Open the input file in binary read mode.
    with open(filename, &#x27;rb&#x27;) as f:
        # Read the header from the file.
        header = AuHeader(f.read(12))
        
        # Calculate the checksum and verify it.
        calculated_checksum = (header.version + header.file_size) % 256
        if struct.unpack(&#x27;I&#x27;, f.read(4))[0] != calculated_checksum:
            raise ValueError(&quot;Checksum mismatch&quot;)
        
        # Read the rest of the data from the file.
        return f.read()

# Example usage:
if __name__ == &quot;__main__&quot;:
    # Write a Sun AU file.
    data = b&#x27;SUN AU File&#x27;  # Replace with your desired data
    write_sun-au_file(&#x27;example.au&#x27;, data)
    
    # Read a Sun AU file and print its contents.
    read_data = read_sun-au_file(&#x27;example.au&#x27;)
    print(read_data)
```

This code provides functions to create, modify, and manipulate Sun AU files. The `AuHeader` class represents the header of a Sun AU file, and the `write_sun-au_file` function writes data to an output file in Sun AU format. The `read_sun-au_file` function reads data from an input file in Sun AU format.

You can use these functions to read and write Sun AU files as shown in the example usage section at the end of the code.

**Note:** This is a simplified example and might not cover all edge cases, but it should give you a good starting point for working with Sun AU files.
</code></pre>

<h3 id='standard_library_documents/Multimedia Services/ossaudiodev - Access to OSS-compatible audio devices.md'>ossaudiodev - Access to OSS-compatible audio devices.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># ossaudiodev — Access to OSS-compatible audio devices

**OSS Audio Device Module**
==========================

The `osaudiodev` module provides access to OSS-compatible audio devices.

### Importing Modules

To use the `osaudiodev` module, you need to import it in your Python script:
```python
import osaudiodev
```

### Creating an Audio Stream

You can create an audio stream using the `open` function from the `osaudiodev` module:
```python
# Open a new file descriptor for reading and writing audio data
fd = open(&#x27;/dev/dsp&#x27;, &#x27;rb&#x27;)

# Create an audio stream with 1 channel, 16-bit samples, and 44100 Hz sampling rate
stream = osaudiodev.open(fd, format=osaudiodev.NI8P2)

# Get the audio format of the stream
format = stream.get_format()
print(format)  # Output: NI8P2
```

### Setting Audio Parameters

You can set various audio parameters using the `set_parameters` function:
```python
# Set the sampling rate to 48000 Hz
stream.set_parameters({&#x27;rate&#x27;: 48000})

# Set the volume level to 50%
stream.set_volume(0.5)
```

### Recording Audio

To record audio, you can use the `read` function from the `osaudiodev` module:
```python
# Record 10 seconds of audio into a buffer
buffer = osaudiodev.read(stream, 10)

# Print the recorded audio data
print(buffer)  # Output: A list of audio samples
```

### Playing Audio

To play audio, you can use the `write` function from the `osaudiodev` module:
```python
# Create a new file descriptor for writing audio data
fd = open(&#x27;/dev/dsp&#x27;, &#x27;wb&#x27;)

# Open an existing file descriptor for reading audio data
stream = osaudiodev.open(fd, format=osaudiodev.NI8P2)

# Write some audio data to the stream
osaudiodev.write(stream, [1, 2, 3])  # Output: A list of audio samples

# Close the file descriptors
fd.close()
stream.close()
```

### Example Use Case

Here&#x27;s an example use case that demonstrates how to record and play back audio using the `osaudiodev` module:
```python
import osaudiodev
import time

# Open a new file descriptor for recording audio data
fd = open(&#x27;/dev/dsp&#x27;, &#x27;wb&#x27;)

# Create an audio stream with 1 channel, 16-bit samples, and 44100 Hz sampling rate
stream = osaudiodev.open(fd, format=osaudiodev.NI8P2)

# Set the volume level to 50%
stream.set_volume(0.5)

# Record 10 seconds of audio into a buffer
buffer = osaudiodev.read(stream, 10)

# Print the recorded audio data
print(buffer)  # Output: A list of audio samples

# Open an existing file descriptor for playing audio data
fd = open(&#x27;/dev/dsp&#x27;, &#x27;rb&#x27;)
stream = osaudiodev.open(fd, format=osaudiodev.NI8P2)

# Play back the recorded audio using a loopback device
osaudiodev.write(stream, buffer)
time.sleep(5)  # Wait for 5 seconds

# Close the file descriptors
fd.close()
stream.close()

print(&quot;Done!&quot;)
```
Note that this is just one example use case, and you can explore other features of the `osaudiodev` module by consulting its documentation.
</code></pre>

<h3 id='standard_library_documents/Multimedia Services/colorsys - Conversions between color systems.md'>colorsys - Conversions between color systems.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># colorsys — Conversions between color systems

**Colorsys Module Documentation**
=====================================

The `colorsys` module provides functions to convert between different color spaces.

**Functions**
--------------

### 1. HSB to RGB Conversion

```python
import colorsys

def hsb_to_rgb(h, s, v):
    &quot;&quot;&quot;
    Convert HSV (Hue-Saturation-Value) color to RGB (Red-Green-Blue).

    Parameters:
        h (float): Hue value in the range [0, 1].
        s (float): Saturation value in the range [0, 1].
        v (float): Value (brightness) value in the range [0, 1].

    Returns:
        tuple: RGB values as a tuple of three floats in the range [0, 1].
    &quot;&quot;&quot;
    # Convert HSV to RGB using colorsys.hsv_to_rgb function
    r, g, b = colorsys.hsv_to_rgb(h, s, v)
    return (r, g, b)

# Example usage:
h, s, v = 0.5, 0.7, 0.9
rgb_values = hsb_to_rgb(h, s, v)
print(&quot;RGB Values:&quot;, rgb_values)
```

### 2. RGB to HSV Conversion

```python
import colorsys

def rgb_to_hsv(r, g, b):
    &quot;&quot;&quot;
    Convert RGB (Red-Green-Blue) color to HSV (Hue-Saturation-Value).

    Parameters:
        r (float): Red component value in the range [0, 1].
        g (float): Green component value in the range [0, 1].
        b (float): Blue component value in the range [0, 1].

    Returns:
        tuple: HSV values as a tuple of three floats in the range [0, 1].
    &quot;&quot;&quot;
    # Convert RGB to HSV using colorsys.rgb_to_hsv function
    h, s, v = colorsys.rgb_to_hsv(r, g, b)
    return (h, s, v)

# Example usage:
r, g, b = 0.2, 0.4, 0.6
hsv_values = rgb_to_hsv(r, g, b)
print(&quot;HSV Values:&quot;, hsv_values)
```

### 3. RGB to YUV Conversion

```python
import colorsys

def rgb_to_yuv(r, g, b):
    &quot;&quot;&quot;
    Convert RGB (Red-Green-Blue) color to YUV (Luminance-Chrominance).

    Parameters:
        r (float): Red component value in the range [0, 1].
        g (float): Green component value in the range [0, 1].
        b (float): Blue component value in the range [0, 1].

    Returns:
        tuple: YUV values as a tuple of three floats in the range [-128, 127].
    &quot;&quot;&quot;
    # Convert RGB to YUV using colorsys.rgb_to_yuv function
    y, u, v = colorsys.rgb_to_yuv(r, g, b)
    return (y, u, v)

# Example usage:
r, g, b = 0.1, 0.3, 0.5
yuv_values = rgb_to_yuv(r, g, b)
print(&quot;YUV Values:&quot;, yuv_values)
```

### 4. YUV to RGB Conversion

```python
import colorsys

def yuv_to_rgb(y, u, v):
    &quot;&quot;&quot;
    Convert YUV (Luminance-Chrominance) color to RGB (Red-Green-Blue).

    Parameters:
        y (float): Luminance component value in the range [-128, 127].
        u (float): Chrominance (blue) component value in the range [-128, 127].
        v (float): Chrominance (red) component value in the range [-128, 127].

    Returns:
        tuple: RGB values as a tuple of three floats in the range [0, 1].
    &quot;&quot;&quot;
    # Convert YUV to RGB using colorsys.yuv_to_rgb function
    r, g, b = colorsys.yuv_to_rgb(y, u, v)
    return (r, g, b)

# Example usage:
y, u, v = 100, -50, 75
rgb_values = yuv_to_rgb(y, u, v)
print(&quot;RGB Values:&quot;, rgb_values)
```

### 5. HSL to RGB Conversion

```python
import colorsys

def hsl_to_rgb(h, s, l):
    &quot;&quot;&quot;
    Convert HSL (Hue-Saturation-Lightness) color to RGB (Red-Green-Blue).

    Parameters:
        h (float): Hue value in the range [0, 1].
        s (float): Saturation value in the range [0, 1].
        l (float): Lightness value in the range [0, 1].

    Returns:
        tuple: RGB values as a tuple of three floats in the range [0, 1].
    &quot;&quot;&quot;
    # Convert HSL to RGB using colorsys.hsl_to_rgb function
    r, g, b = colorsys.hsl_to_rgb(h, s, l)
    return (r, g, b)

# Example usage:
h, s, l = 0.6, 0.8, 0.9
rgb_values = hsl_to_rgb(h, s, l)
print(&quot;RGB Values:&quot;, rgb_values)
```

### 6. RGB to HSL Conversion

```python
import colorsys

def rgb_to_hsl(r, g, b):
    &quot;&quot;&quot;
    Convert RGB (Red-Green-Blue) color to HSL (Hue-Saturation-Lightness).

    Parameters:
        r (float): Red component value in the range [0, 1].
        g (float): Green component value in the range [0, 1].
        b (float): Blue component value in the range [0, 1].

    Returns:
        tuple: HSL values as a tuple of three floats in the range [0, 1].
    &quot;&quot;&quot;
    # Convert RGB to HSL using colorsys.rgb_to_hsl function
    h, s, l = colorsys.rgb_to_hsl(r, g, b)
    return (h, s, l)

# Example usage:
r, g, b = 0.2, 0.4, 0.6
hsl_values = rgb_to_hsl(r, g, b)
print(&quot;HSL Values:&quot;, hsl_values)
```

### 7. YUV to HSL Conversion

```python
import colorsys

def yuv_to_hsl(y, u, v):
    &quot;&quot;&quot;
    Convert YUV (Luminance-Chrominance) color to HSL (Hue-Saturation-Lightness).

    Parameters:
        y (float): Luminance component value in the range [-128, 127].
        u (float): Chrominance (blue) component value in the range [-128, 127].
        v (float): Chrominance (red) component value in the range [-128, 127].

    Returns:
        tuple: HSL values as a tuple of three floats in the range [0, 1].
    &quot;&quot;&quot;
    # Convert YUV to HSL using colorsys.yuv_to_hsl function
    h, s, l = colorsys.yuv_to_hsl(y, u, v)
    return (h, s, l)

# Example usage:
y, u, v = 100, -50, 75
hsl_values = yuv_to_hsl(y, u, v)
print(&quot;HSL Values:&quot;, hsl_values)
```

### 8. HSL to YUV Conversion

```python
import colorsys

def hsl_to_yuv(h, s, l):
    &quot;&quot;&quot;
    Convert HSL (Hue-Saturation-Lightness) color to YUV (Luminance-Chrominance).

    Parameters:
        h (float): Hue value in the range [0, 1].
        s (float): Saturation value in the range [0, 1].
        l (float): Lightness value in the range [0, 1].

    Returns:
        tuple: YUV values as a tuple of three floats in the range [-128, 127].
    &quot;&quot;&quot;
    # Convert HSL to YUV using colorsys.hsl_to_yuv function
    y, u, v = colorsys.hsl_to_yuv(h, s, l)
    return (y, u, v)

# Example usage:
h, s, l = 0.7, 0.9, 1.0
yuv_values = hsl_to_yuv(h, s, l)
print(&quot;YUV Values:&quot;, yuv_values)
```
</code></pre>

<h3 id='standard_library_documents/Multimedia Services/chunk - Read IFF chunked data.md'>chunk - Read IFF chunked data.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># chunk — Read IFF chunked data

**Chunk Module Code Generator**

### Overview
The `chunk` module provides a simple way to read IFF (Image File Format) chunked data.

### Code Examples
```python
import chunk

# Create an instance of the Chunk class
chunk_instance = chunk.Chunk()

# Initialize the chunk instance with some data
chunk_data = b&quot;Hello, World!&quot;
chunk_instance.load(chunk_data)

# Print the chunk contents as a string
print(chunk_instance.get_contents())

# Get the chunk size
print(f&quot;Chunk size: {len(chunk_data)}&quot;)

# Load more chunk data and append it to the existing data
more_chunk_data = b&quot;This is some additional data.&quot;
chunk_instance.append(more_chunk_data)

# Print the updated chunk contents as a string
print(chunk_instance.get_contents())

# Get the updated chunk size
print(f&quot;Updated chunk size: {len(chunk_data) + len(more_chunk_data)}&quot;)

# Save the chunk instance to a file
with open(&quot;chunk.bin&quot;, &quot;wb&quot;) as f:
    chunk_instance.save(f)

# Load a chunk instance from a file
loaded_chunk = chunk.Chunk()
loaded_chunk.load_from_file(&quot;chunk.bin&quot;)
```

### Chunk Class Methods

#### `load(data)`
Loads data into the chunk instance.

*   `data`: The data to load into the chunk instance.
*   Returns: None

```python
def load(self, data):
    &quot;&quot;&quot;
    Loads data into the chunk instance.

    :param data: The data to load into the chunk instance.
    &quot;&quot;&quot;
    self.data = data
```

#### `append(data)`
Appends data to the existing data in the chunk instance.

*   `data`: The data to append to the existing data.
*   Returns: None

```python
def append(self, data):
    &quot;&quot;&quot;
    Appends data to the existing data in the chunk instance.

    :param data: The data to append to the existing data.
    &quot;&quot;&quot;
    self.data += data
```

#### `save(file)`
Saves the chunk instance to a file.

*   `file`: The file to save the chunk instance to.
*   Returns: None

```python
def save(self, file):
    &quot;&quot;&quot;
    Saves the chunk instance to a file.

    :param file: The file to save the chunk instance to.
    &quot;&quot;&quot;
    with open(file, &quot;wb&quot;) as f:
        f.write(self.data)
```

#### `load_from_file(file)`
Loads a chunk instance from a file.

*   `file`: The file to load the chunk instance from.
*   Returns: A new Chunk instance containing the loaded data.
*   Raises: FileNotFoundError if the file does not exist, ValueError if the file is empty.

```python
@staticmethod
def load_from_file(file):
    &quot;&quot;&quot;
    Loads a chunk instance from a file.

    :param file: The file to load the chunk instance from.
    :return: A new Chunk instance containing the loaded data.
    :raises FileNotFoundError: If the file does not exist.
    :raises ValueError: If the file is empty.
    &quot;&quot;&quot;
    try:
        with open(file, &quot;rb&quot;) as f:
            data = f.read()
            if not data:
                raise ValueError(&quot;File is empty&quot;)
            return Chunk(data)
    except FileNotFoundError:
        raise
```

#### `get_contents()`
Gets the contents of the chunk instance as a string.

*   Returns: A string containing the chunk data.
*   Raises: AttributeError if the chunk instance does not contain any data.

```python
def get_contents(self):
    &quot;&quot;&quot;
    Gets the contents of the chunk instance as a string.

    :return: A string containing the chunk data.
    :raises AttributeError: If the chunk instance does not contain any data.
    &quot;&quot;&quot;
    return self.data.decode(&quot;utf-8&quot;) if self.data else None
```

#### `get_size()`
Gets the size of the chunk instance in bytes.

*   Returns: An integer representing the chunk size.
*   Raises: AttributeError if the chunk instance does not contain any data.

```python
def get_size(self):
    &quot;&quot;&quot;
    Gets the size of the chunk instance in bytes.

    :return: An integer representing the chunk size.
    :raises AttributeError: If the chunk instance does not contain any data.
    &quot;&quot;&quot;
    return len(self.data)
```

### Chunk Class Attributes

*   `data`: The chunk data as a byte string.
</code></pre>

<h3 id='standard_library_documents/Multimedia Services/aifc - Read and write AIFF and AIFC files.md'>aifc - Read and write AIFF and AIFC files.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># aifc — Read and write AIFF and AIFC files

**aifc Module Example Code**
=====================================

The `aifc` module provides an interface for reading and writing Audio Interchange File Format (AIFF) and AIFC audio files.

### Importing the aifc Module
```python
import aifc
```

### Reading AIFF/AIFC Files
-----------------------------

You can use the `read()` function to read an entire AIFF or AIFC file into memory.
```python
def read_aiff_file(file_path):
    &quot;&quot;&quot;
    Reads an entire AIFF or AIFC file into memory.

    Args:
        file_path (str): The path to the AIFF or AIFC file.

    Returns:
        bytes: The contents of the AIFF/AIFC file.
    &quot;&quot;&quot;
    with aifc.AiffFile(file_path) as file:
        data = file.read()
    return data
```

### Writing AIFF/AIFC Files
---------------------------

You can use the `write()` function to write data to an existing AIFF or AIFC file.
```python
def write_aiff_file(file_path, data):
    &quot;&quot;&quot;
    Writes data to an existing AIFF or AIFC file.

    Args:
        file_path (str): The path to the AIFF or AIFC file.
        data (bytes): The data to be written to the file.
    &quot;&quot;&quot;
    with aifc.AiffFile(file_path, mode=&#x27;w&#x27;) as file:
        file.write(data)
```

### Converting Between Wave and AIFC Formats
--------------------------------------------

You can use the `AiffFile` class to convert between wave and AIFC formats.
```python
def convert_between_formats(input_file_path, output_file_path):
    &quot;&quot;&quot;
    Converts an AIFF or AIFC file to a WAV file.

    Args:
        input_file_path (str): The path to the AIFF or AIFC file.
        output_file_path (str): The path to the output WAV file.
    &quot;&quot;&quot;
    with aifc.AiffFile(input_file_path) as file:
        # Read the audio data from the AIFC file
        data = file.read()
    
    # Convert the data to WAV format
    wav_data = data
    
    # Write the converted data to the output WAV file
    with open(output_file_path, &#x27;wb&#x27;) as output_file:
        output_file.write(wav_data)
```

### Example Usage
```python
# Read an AIFF file into memory
data = read_aiff_file(&#x27;example.aif&#x27;)

# Write data to an AIFC file
write_aiff_file(&#x27;output.aifc&#x27;, b&#x27;Hello, World!&#x27;)

# Convert an AIFC file to a WAV file
convert_between_formats(&#x27;input.aifc&#x27;, &#x27;output.wav&#x27;)
```
Note: This is just a basic example of what can be done with the `aifc` module. The actual usage may vary depending on your specific requirements and the Python version you are using.
</code></pre>

<h3 id='standard_library_documents/Multimedia Services/imghdr - Determine the type of an image.md'>imghdr - Determine the type of an image.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># imghdr — Determine the type of an image

**Image Header Module**
======================

The `imghdr` module is used to determine the type of an image.

### Code Examples

#### 1. Checking the Image Type
```python
import imghdr

# Open an image file
with open(&#x27;image.jpg&#x27;, &#x27;rb&#x27;) as f:
    # Read the first 4 bytes of the file (header)
    header = f.read(4)

# Check if the image is a JPEG
if imghdr.what(header):
    print(&quot;Image type: JPEG&quot;)
else:
    print(&quot;Unknown image type&quot;)
```

#### 2. Checking Other Image Types
```python
import imghdr

image_types = {
    &#x27;JPEG&#x27;: imghdr.JPEG,
    &#x27;GIF&#x27;: imghdr.GIF,
    &#x27;PNG&#x27;: imghdr.PNG,
}

# Check the type of an image file
for extension, type in image_types.items():
    if imghdr.what(open(&#x27;image.&#x27; + extension, &#x27;rb&#x27;).read(4)) == type:
        print(f&quot;Image type: {extension}&quot;)
```

#### 3. Handling Unknown Image Types
```python
import imghdr

try:
    # Open an image file
    with open(&#x27;unknown.png&#x27;, &#x27;rb&#x27;) as f:
        # Read the first 4 bytes of the file (header)
        header = f.read(4)

    # Check if the image type is unknown
    image_type = imghdr.what(header)
    if image_type == imghdr.UNKNOWN:
        print(&quot;Unknown image type&quot;)
except FileNotFoundError:
    print(&quot;File not found&quot;)
```

#### 4. Using `img HDR` for Multiple Image Files
```python
import imghdr

image_files = [&#x27;image1.jpg&#x27;, &#x27;image2.png&#x27;, &#x27;unknown.png&#x27;]

for file in image_files:
    try:
        # Open an image file
        with open(file, &#x27;rb&#x27;) as f:
            # Read the first 4 bytes of the file (header)
            header = f.read(4)

        # Check if the image type is known
        image_type = imghdr.what(header)
        print(f&quot;Image type: {image_type}&quot;)
    except FileNotFoundError:
        print(&quot;File not found&quot;)
```

### Explanation

*   The `imghdr` module uses the first 4 bytes of an image file to determine its type.
*   The `what()` function returns an integer representing the image type, which can be one of:
    *   `JPEG` (for JPEG images)
    *   `GIF` (for GIF images)
    *   `PNG` (for PNG images)
    *   `UNKNOWN` (for unknown or unsupported image types)
*   By checking the first 4 bytes of an image file, you can determine its type without needing to read or parse the entire file.

**Note:** The above examples are for illustration purposes only. In real-world applications, consider using established libraries and frameworks for handling images, such as Pillow (PIL) or OpenCV, which provide more comprehensive functionality and better performance than the `imghdr` module alone.
</code></pre>

<h3 id='standard_library_documents/Multimedia Services/wave - Read and write WAV files.md'>wave - Read and write WAV files.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># wave — Read and write WAV files

**Wave Module Code Examples**
=====================================

The `wave` module provides functions to read and write WAV (Waveform Audio File Format) files.

### Importing the Wave Module
```python
import wave
```

### Creating a New WAV File
```python
# Open a new file in write binary mode
with open(&#x27;new_file.wav&#x27;, &#x27;wb&#x27;) as wav_file:
    # Create a WAV header with specific parameters
    wav_header = b&#x27;RIFF&#x27;
    wav_header += len(wav_file).to_bytes(4, byteorder=&#x27;little&#x27;)
    wav_header += b&#x27;WAVE&#x27;
    wav_header += b-format
    wav_header += b&#x27;data&#x27;
    
    # Write the header to the file
    wav_file.write(wav_header)
    
    # Create a sample audio data block
    for i in range(1000):
        data = (i * 10).to_bytes(2, byteorder=&#x27;little&#x27;)
        # Write the data to the file
        wav_file.write(data)
```

### Reading a WAV File
```python
# Open an existing file in read binary mode
with open(&#x27;existing_file.wav&#x27;, &#x27;rb&#x27;) as wav_file:
    # Read the header from the file
    wav_header = wav_file.read(36)
    
    # Check if it&#x27;s a valid WAV header
    if len(wav_header) &lt; 36 or wav_header[:4] != b&#x27;RIFF&#x27;:
        raise ValueError(&#x27;Invalid WAV header&#x27;)
    
    # Extract audio data parameters from the header
    format = wav_header[6:10].decode()
    num_channels = int.from_bytes(wav_header[10:14], byteorder=&#x27;little&#x27;)
    sample_width = int.from_bytes(wav_header[14:18], byteorder=&#x27;little&#x27;)
    frame_rate = int.from_bytes(wav_header[18:24], byteorder=&#x27;little&#x27;)
    num_frames = int.from_bytes(wav_header[24:28], byteorder=&#x27;little&#x27;)
    
    # Read audio data from the file
    wav_data = wav_file.read()
```

### Playing a WAV File
```python
import pyaudio

# Open a new file in read binary mode
wav_file = open(&#x27;file.wav&#x27;, &#x27;rb&#x27;)

# Create a PyAudio object
p = pyaudio.PyAudio()

# Open a stream for playback
stream = p.open(format=pyaudio.paInt16,
                channels=1,
                rate=44100,
                output=True)

# Read audio data from the file and write it to the stream
data = wav_file.read()
while len(data) &gt; 0:
    # Write the audio data to the stream
    stream.write(data)
    
    # Clear the buffer for the next frame
    data = b&#x27;&#x27;

# Close the stream and PyAudio object
stream.stop_stream()
stream.close()
p.terminate()

# Close the WAV file
wav_file.close()
```

### Writing a Multi-Channel WAV File
```python
import numpy as np

# Create a sample audio data block with multiple channels
data = np.random.rand(1000, 3).astype(np.int16)

# Open a new file in write binary mode
with open(&#x27;multi_channel_file.wav&#x27;, &#x27;wb&#x27;) as wav_file:
    # Write the header to the file
    wav_header = b&#x27;RIFF&#x27;
    wav_header += len(wav_file).to_bytes(4, byteorder=&#x27;little&#x27;)
    wav_header += b&#x27;WAVE&#x27;
    wav_header += b&#x27;fmt &#x27;
    wav_header += &#x27;36&#x27;.encode()
    wav_header += b&#x27;data&#x27;
    
    # Write the header to the file
    wav_file.write(wav_header)
    
    # Write audio data to the file for each channel
    for channel in range(3):
        # Calculate sample width based on the number of channels
        if channel == 0:
            sample_width = 2
        elif channel == 1:
            sample_width = 4
        else:
            sample_width = 8
        
        # Write audio data to the file for this channel
        wav_data = data.channel(channel).tobytes()
        wav_file.write(wav_data)
```

Note: The above examples are just a selection of the many things you can do with the `wave` module. This module provides functions for reading and writing WAV files, including support for multiple channels, stereo audio, and other features.
</code></pre>

<h3 id='standard_library_documents/Multimedia Services/audioop - Manipulate raw audio data.md'>audioop - Manipulate raw audio data.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># audioop — Manipulate raw audio data

**Audioop Module**
=================

The `audioop` module provides functions for manipulating raw audio data.

### Functions

#### 1. `audioop.add(a, b)` : Add two signed 8-bit integers.

```python
def add(a: int, b: int) -&gt; int:
    &quot;&quot;&quot;
    Adds two signed 8-bit integers.
    
    Args:
        a (int): The first integer to add.
        b (int): The second integer to add.
    
    Returns:
        int: The sum of the two integers.
    &quot;&quot;&quot;
    # Ensure the result is within the range of 8-bit signed integers
    return min(max(a + b, -128), 127)
```

#### 2. `audioop.sub(a, b)` : Subtract two signed 8-bit integers.

```python
def sub(a: int, b: int) -&gt; int:
    &quot;&quot;&quot;
    Subtracts two signed 8-bit integers.
    
    Args:
        a (int): The first integer to subtract from.
        b (int): The second integer to subtract.
    
    Returns:
        int: The difference of the two integers.
    &quot;&quot;&quot;
    # Ensure the result is within the range of 8-bit signed integers
    return min(max(a - b, -127), 127)
```

#### 3. `audioop.mul(a, b)` : Multiply two unsigned 16-bit integers.

```python
def mul(a: int, b: int) -&gt; int:
    &quot;&quot;&quot;
    Multiplies two unsigned 16-bit integers.
    
    Args:
        a (int): The first integer to multiply.
        b (int): The second integer to multiply.
    
    Returns:
        int: The product of the two integers.
    &quot;&quot;&quot;
    # Ensure the result is within the range of 16-bit unsigned integers
    return min(max(a * b, 0), 65535)
```

#### 4. `audioop.imul(a, b)` : Multiply two signed 8-bit integers.

```python
def imul(a: int, b: int) -&gt; int:
    &quot;&quot;&quot;
    Multiplies two signed 8-bit integers.
    
    Args:
        a (int): The first integer to multiply.
        b (int): The second integer to multiply.
    
    Returns:
        int: The product of the two integers.
    &quot;&quot;&quot;
    # Handle sign and overflow
    if b &lt; 0:
        return -mul(a, -b)
    elif a &amp; 1 and b &amp; 1:
        return add(add(a &gt;&gt; 1, b &gt;&gt; 1), mul((a ^ b) &gt;&gt; 1))
    else:
        return (a * b) &gt;&gt; 1
```

#### 5. `audioop.iadd(a, b)` : Add two signed 8-bit integers.

```python
def iadd(a: int, b: int) -&gt; int:
    &quot;&quot;&quot;
    Adds two signed 8-bit integers.
    
    Args:
        a (int): The first integer to add.
        b (int): The second integer to add.
    
    Returns:
        int: The sum of the two integers.
    &quot;&quot;&quot;
    # Handle sign and overflow
    if a &lt; 0 and b &gt;= 0:
        return -sub(-a, b)
    elif a &gt;= 0 and b &lt; 0:
        return sub(a, -b)
    else:
        return add(a, b)
```

#### 6. `audioop.isub(a, b)` : Subtract two signed 8-bit integers.

```python
def isub(a: int, b: int) -&gt; int:
    &quot;&quot;&quot;
    Subtracts two signed 8-bit integers.
    
    Args:
        a (int): The first integer to subtract from.
        b (int): The second integer to subtract.
    
    Returns:
        int: The difference of the two integers.
    &quot;&quot;&quot;
    # Handle sign and overflow
    if a &lt; 0 and b &gt;= 0:
        return -iadd(-a, b)
    elif a &gt;= 0 and b &lt; 0:
        return iadd(a, -b)
    else:
        return sub(a, b)
```

#### 7. `audioop.imul2(a, b)` : Multiply two signed 16-bit integers.

```python
def imul2(a: int, b: int) -&gt; int:
    &quot;&quot;&quot;
    Multiplies two signed 16-bit integers.
    
    Args:
        a (int): The first integer to multiply.
        b (int): The second integer to multiply.
    
    Returns:
        int: The product of the two integers.
    &quot;&quot;&quot;
    # Handle sign and overflow
    if a &lt; 0 and b &lt; 0:
        return mul(a, b)
    elif a &gt;= 0 and b &gt;= 0:
        return mul(a, b)
    else:
        # Special case for (a ^ b) &gt;&gt; 1
        return add(add((abs(a) &amp; ~a) * b &gt;&gt; 1, abs(b) &amp; ~b), ((a - b + 128) | -128))
```

#### 8. `audioop.iadd2(a, b)` : Add two signed 16-bit integers.

```python
def iadd2(a: int, b: int) -&gt; int:
    &quot;&quot;&quot;
    Adds two signed 16-bit integers.
    
    Args:
        a (int): The first integer to add.
        b (int): The second integer to add.
    
    Returns:
        int: The sum of the two integers.
    &quot;&quot;&quot;
    # Handle sign and overflow
    if a &lt; 0 and b &gt;= 0:
        return -iadd(-a, b)
    elif a &gt;= 0 and b &lt; 0:
        return iadd(a, -b)
    else:
        return add(a, b)
```

#### 9. `audioop.isub2(a, b)` : Subtract two signed 16-bit integers.

```python
def isub2(a: int, b: int) -&gt; int:
    &quot;&quot;&quot;
    Subtracts two signed 16-bit integers.
    
    Args:
        a (int): The first integer to subtract from.
        b (int): The second integer to subtract.
    
    Returns:
        int: The difference of the two integers.
    &quot;&quot;&quot;
    # Handle sign and overflow
    if a &lt; 0 and b &gt;= 0:
        return -iadd2(-a, b)
    elif a &gt;= 0 and b &lt; 0:
        return iadd2(a, -b)
    else:
        return sub(a, b)
```

### Example Usage

```python
import audioop

# Signed 8-bit integers
a = 5
b = 10
print(audioop.add(a, b))  # Output: 15

# Unsigned 16-bit integers
x = 32768
y = 1280
print(audioop.mul(x, y))  # Output: 131072

# Signed 8-bit integer and unsigned 16-bit integer
a = -10
b = 5
print(audioop.iadd(a, b))  # Output: -5

# Signed 16-bit integers
a = 65535
b = 12345
print(audioop.isub2(a, b))  # Output: -53190
```
</code></pre>
<h2 id='Cryptographic Services'>Cryptographic Services</h2><ul><li><a href='#standard_library_documents/Cryptographic Services/hashlib_Secure_hashes_and_message_digests.md'>hashlib_Secure_hashes_and_message_digests.md</a></li><li><a href='#standard_library_documents/Cryptographic Services/hmac - Keyed-Hashing for Message Authentication.md'>hmac - Keyed-Hashing for Message Authentication.md</a></li><li><a href='#standard_library_documents/Cryptographic Services/secrets - Generate secure random numbers for managing secrets.md'>secrets - Generate secure random numbers for managing secrets.md</a></li><li><a href='#standard_library_documents/Cryptographic Services/hashlib - Secure hashes and message digests.md'>hashlib - Secure hashes and message digests.md</a></li><li><a href='#standard_library_documents/Cryptographic Services/hmac_Keyed_Hashing_for_Message_Authentication.md'>hmac_Keyed_Hashing_for_Message_Authentication.md</a></li><li><a href='#standard_library_documents/Cryptographic Services/secrets_Generate_secure_random_numbers_for_managing_secrets.md'>secrets_Generate_secure_random_numbers_for_managing_secrets.md</a></li></ul>
<h3 id='standard_library_documents/Cryptographic Services/hashlib_Secure_hashes_and_message_digests.md'>hashlib_Secure_hashes_and_message_digests.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># hashlib — Secure hashes and message digests

**Hashing and Message Digester Module**
=====================================

The `hashlib` module provides a way to create cryptographic hash values for data.

### Installing the Required Modules

Before we begin, make sure you have installed the required modules. The `hashlib` module comes pre-installed with Python, so you don&#x27;t need to install anything.

### Creating a Hash Object

To use the `hashlib` module, you first need to create a hash object using the desired hashing algorithm.

```python
import hashlib

# Create a new SHA-256 hash object
sha256_hash = hashlib.sha256()

# Update the hash object with some data (e.g., a string)
data_to_hash = b&quot;Hello, World!&quot;
sha256_hash.update(data_to_hash)

# Get the hexadecimal representation of the hash value
hex_dig = sha256_hash.hexdigest()
print(hex_dig)
```

### Supported Hashing Algorithms

The `hashlib` module supports various hashing algorithms, including:

*   SHA-224
*   SHA-256
*   SHA-384
*   SHA-512
*   MD5
*   RIPEMD-160
*   BLAKE2b
*   BLAKE2s

Each algorithm has its own strengths and weaknesses.

```python
import hashlib

# Create a new hash object using SHA-256
sha256_hash = hashlib.sha256()

# Update the hash object with some data (e.g., an integer)
data_to_hash = 12345
sha256_hash.update(str(data_to_hash).encode())

# Get the hexadecimal representation of the hash value
hex_dig_sha256 = sha256_hash.hexdigest()
print(hex_dig_sha256)

# Create a new SHA-512 hash object
sha512_hash = hashlib.sha512()

# Update the hash object with some data (e.g., bytes)
data_to_hash_bytes = b&quot;Hello, World!&quot;
sha512_hash.update(data_to_hash_bytes)

# Get the hexadecimal representation of the hash value
hex_dig_sha512 = sha512_hash.hexdigest()
print(hex_dig_sha512)
```

### Verifying Hash Integrity

To verify the integrity of a hash value, you can compare it with a new hash value generated from the same data.

```python
import hashlib

# Create a new SHA-256 hash object
sha256_hash = hashlib.sha256()

# Update the hash object with some data (e.g., bytes)
data_to_hash_bytes = b&quot;Hello, World!&quot;
sha256_hash.update(data_to_hash_bytes)

# Get the hexadecimal representation of the initial hash value
hex_dig_initial = sha256_hash.hexdigest()

# Close the hash object to ensure its integrity is preserved
sha256_hash.close()

# Create a new SHA-256 hash object and update it with the same data
new_sha256_hash = hashlib.sha256()
new_sha256_hash.update(data_to_hash_bytes)
new_hex_dig = new_sha256_hash.hexdigest()

# Compare the initial hash value with the new one to verify integrity
if hex_dig_initial == new_hex_dig:
    print(&quot;Hash values match&quot;)
else:
    print(&quot;Hash values do not match&quot;)
```

### Commonly Used Hashing Algorithms

Here are some commonly used hashing algorithms along with their typical use cases:

*   **SHA-256**: Secure for most applications, including data integrity verification and password storage.
*   **MD5**: Not recommended due to its low collision resistance and security vulnerabilities.
*   **BLAKE2b**: Suitable for high-speed cryptographic hash functions.
*   **RIPEMD-160**: Used in conjunction with other algorithms (e.g., SHA-256) for cryptographic purposes.

Remember to consider the specific needs of your project when choosing a hashing algorithm. Always prioritize data integrity and security over efficiency or convenience.
</code></pre>

<h3 id='standard_library_documents/Cryptographic Services/hmac - Keyed-Hashing for Message Authentication.md'>hmac - Keyed-Hashing for Message Authentication.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># hmac — Keyed-Hashing for Message Authentication

Here&#x27;s an example of how you can use the `hmac` module from Python&#x27;s standard library:

```python
# Import the hmac module from the standard library
import hmac

def generate_hmac(key, message):
    &quot;&quot;&quot;
    Generates a HMAC (Keyed-Hashing for Message Authentication) object.

    Args:
        key (bytes): The secret key used to authenticate the message.
        message (bytes): The message to be authenticated.

    Returns:
        hmac.HMAC: A HMAC object containing the authentication key and other metadata.
    &quot;&quot;&quot;
    return hmac.new(key, message, hashlib.sha256)

def verify_hmac(key, message, expected_hmac):
    &quot;&quot;&quot;
    Verifies a given HMAC against a secret key and expected HMAC value.

    Args:
        key (bytes): The secret key used to generate the expected HMAC.
        message (bytes): The message that was authenticated with the HMAC.
        expected_hmac (bytes): The expected HMAC value.

    Returns:
        bool: True if the provided HMAC matches the expected HMAC, False otherwise.
    &quot;&quot;&quot;
    try:
        hmac_object = hmac.new(key, message, hashlib.sha256)
        return hmac.compare_digest(hmac_object.hexdigest(), expected_hmac)
    except ValueError as e:
        print(f&quot;Error generating HMAC: {e}&quot;)
        return False

# Example usage
if __name__ == &quot;__main__&quot;:
    # Generate a random key and a message
    import secrets
    key = secrets.token_bytes(32)  # Use a secret key of length 32 bytes
    message = b&quot;Hello, World!&quot;  # The message to be authenticated

    # Generate an HMAC object using the generated key and message
    hmac_object = generate_hmac(key, message)

    # Get the authentication key from the HMAC object
    auth_key = hmac_object.digest()

    # Verify the HMAC against the secret key and expected HMAC value
    expected_hmac = &quot;1234567890abcdef&quot;  # Replace with your expected HMAC value
    print(&quot;Verification result:&quot;, verify_hmac(key, message, expected_hmac))
```

Here&#x27;s a breakdown of what each part of this example does:

1. **Generating an HMAC**: We create a new `hmac` object using the `generate_hmac` function. This takes our secret key and message as arguments.
2. **Verifying an HMAC**: The `verify_hmac` function checks whether a given HMAC matches our expected value. It uses the same secret key and provided HMAC value to compare them.

**Additional Functions in hmac**

1.  `hmac.new(key, msg=None, alg=None)` : Creates a new HMAC object with optional message and algorithm.
2.  `hmac.compare_digest(hmac_value1, hmac_value2)` : Compares two HMAC values for equality, considering the possibility of different byte orders.
3.  `hmac.new(key, msg=b&#x27;&#x27;, digestmod=hashlib.sha256)` : Creates a new HMAC object using an optional message and digest algorithm.
4.  `hmac.compare_digest(hmac_object.hexdigest(), expected_hmac)` : Compares two HMAC values for equality using hexadecimal representation.
</code></pre>

<h3 id='standard_library_documents/Cryptographic Services/secrets - Generate secure random numbers for managing secrets.md'>secrets - Generate secure random numbers for managing secrets.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># secrets — Generate secure random numbers for managing secrets

**Secrets Module Code Examples**
=====================================

### Overview

The `secrets` module provides an implementation of the cryptographically secure pseudo-random number generator (CSPRNG) as defined in RFC 4086.

### Example Use Cases

* Generating passwords
* Managing cryptographic keys
* Creating secure tokens

### Code Examples

#### 1. Generate a Random Integer

```python
import secrets

# Generate a random integer between 0 and 100
random_int = secrets.randbelow(101)
print(random_int)

# Generate a random float between 0 and 10
random_float = secrets.randbelow(11) / 10
print(random_float)
```

#### 2. Generate a Random Byte String

```python
import secrets

# Generate a random byte string of length 16 (128 bits)
random_bytes = secrets.token_bytes(16)
print(random_bytes.hex())  # Print the bytes as a hexadecimal string

# Generate a random byte string of length 32 (256 bits)
random_bytes_long = secrets.token_bytes(32)
print(random_bytes_long.hex())
```

#### 3. Generate a Random String

```python
import secrets
import string

# Set the character set for the random string
char_set = string.ascii_letters + string.digits

# Generate a random string of length 10
random_string = &#x27;&#x27;.join(secrets.choice(char_set) for _ in range(10))
print(random_string)

# Generate a random password of length 12 (using uppercase and lowercase letters, digits, and punctuation)
random_password = &#x27;&#x27;.join(
    secrets.choice(string.ascii_letters + string.digits + string.punctuation) 
    for _ in range(12)
)
print(random_password)
```

#### 4. Generate a URL-safe Random String

```python
import secrets
import string

# Set the character set for the random string (URL-safe)
char_set = string.ascii_letters + string.digits + &#x27;-_&#x27;

# Generate a random string of length 16
random_url_safe_string = &#x27;&#x27;.join(
    secrets.choice(char_set) 
    for _ in range(16)
)
print(random_url_safe_string)
```

#### 5. Generate a Random Token

```python
import secrets
import hashlib

# Set the token length (e.g., 32 characters)
token_length = 32

# Generate a random byte string of the specified length
random_bytes = secrets.token_bytes(token_length)

# Hash the byte string using SHA-256
token_hash = hashlib.sha256(random_bytes).hexdigest()
print(token_hash)

# Use the first token_length/2 characters as the final token
final_token = token_hash[:token_length // 2]
print(final_token)
```

### Notes

* The `secrets` module is designed to generate cryptographically secure random numbers, making it suitable for managing secrets and cryptographic keys.
* Always use the `secrets` module instead of `random` or other non-cryptographically secure modules when generating random numbers for security-sensitive applications.
</code></pre>

<h3 id='standard_library_documents/Cryptographic Services/hashlib - Secure hashes and message digests.md'>hashlib - Secure hashes and message digests.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># hashlib — Secure hashes and message digests

Here&#x27;s an example of how you can use the `hashlib` module from Python&#x27;s standard library:

```python
import hashlib

# Create a new SHA-256 hash object
sha256_hash = hashlib.sha256()

# Update the hash object with some data
data_to_hash = b&#x27;Hello, World!&#x27;
sha256_hash.update(data_to_hash)

# Get the hexadecimal representation of the hash
hash_hex = sha256_hash.hexdigest()
print(f&quot;SHA-256 Hash: {hash_hex}&quot;)

# Create a new SHA-512 hash object
sha512_hash = hashlib.sha512()

# Update the hash object with some data
data_to_hash = b&#x27;Hello, World!&#x27;
sha512_hash.update(data_to_hash)

# Get the hexadecimal representation of the hash
hash_hex = sha512_hash.hexdigest()
print(f&quot;SHA-512 Hash: {hash_hex}&quot;)

# Create a new MD5 hash object
md5_hash = hashlib.md5()

# Update the hash object with some data
data_to_hash = b&#x27;Hello, World!&#x27;
md5_hash.update(data_to_hash)

# Get the hexadecimal representation of the hash
hash_hex = md5_hash.hexdigest()
print(f&quot;MD5 Hash: {hash_hex}&quot;)

# Create a new RIPEMD-160 hash object
ripemd160_hash = hashlib.new(&#x27;ripemd160&#x27;)

# Update the hash object with some data
data_to_hash = b&#x27;Hello, World!&#x27;
ripemd160_hash.update(data_to_hash)

# Get the hexadecimal representation of the hash
hash_hex = ripemd160_hash.hexdigest()
print(f&quot;RIPEMD-160 Hash: {hash_hex}&quot;)

# Create a new SHA-3 (Keccak-256) hash object
keccak_256_hash = hashlib.sha3_256()

# Update the hash object with some data
data_to_hash = b&#x27;Hello, World!&#x27;
keccak_256_hash.update(data_to_hash)

# Get the hexadecimal representation of the hash
hash_hex = keccak_256_hash.hexdigest()
print(f&quot;SHA-3 (Keccak-256) Hash: {hash_hex}&quot;)
```

Here&#x27;s a more advanced example that demonstrates how to use the `hashlib` module with different types of data:

```python
import hashlib

# Create a dictionary and convert it to bytes
data_dict = {&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 30}
data_bytes = str(data_dict).encode(&#x27;utf-8&#x27;)

# Create a new SHA-256 hash object
sha256_hash = hashlib.sha256()

# Update the hash object with some data
sha256_hash.update(data_bytes)

# Get the hexadecimal representation of the hash
hash_hex = sha256_hash.hexdigest()
print(f&quot;SHA-256 Hash: {hash_hex}&quot;)

# Create an image file and convert it to bytes
image_data = open(&#x27;image.jpg&#x27;, &#x27;rb&#x27;).read()
sha512_hash = hashlib.sha512()

# Update the hash object with some data
sha512_hash.update(image_data)

# Get the hexadecimal representation of the hash
hash_hex = sha512_hash.hexdigest()
print(f&quot;SHA-512 Hash: {hash_hex}&quot;)

# Create a list and convert it to bytes
data_list = [1, 2, 3]
data_bytes_list = str(data_list).encode(&#x27;utf-8&#x27;)
md5_hash = hashlib.md5()

# Update the hash object with some data
md5_hash.update(data_bytes_list)

# Get the hexadecimal representation of the hash
hash_hex = md5_hash.hexdigest()
print(f&quot;MD5 Hash: {hash_hex}&quot;)
```

These examples show how you can use the `hashlib` module to create secure hashes and message digests for different types of data, including strings, bytes, dictionaries, images, and lists.
</code></pre>

<h3 id='standard_library_documents/Cryptographic Services/hmac_Keyed_Hashing_for_Message_Authentication.md'>hmac_Keyed_Hashing_for_Message_Authentication.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># hmac — Keyed-Hashing for Message Authentication

Here&#x27;s an example of how you can use the `hmac` module in Python:

```python
# Import the hmac module
import hmac

def generate_hmac(key, message):
    &quot;&quot;&quot;
    Generate a keyed-hash message authentication code (HMAC) using the HMAC algorithm.
    
    Args:
        key: The secret key used for HMAC. Must be bytes-like.
        message: The data to be authenticated. Can be either bytes or str.
        
    Returns:
        A tuple containing the digest and tag of the HMAC object.
    &quot;&quot;&quot;
    # Convert the message to bytes if it&#x27;s a string
    if isinstance(message, str):
        message = message.encode(&#x27;utf-8&#x27;)
    
    # Create an HMAC object using the provided key and algorithm (HMAC with SHA256 by default)
    hmac_object = hmac.new(key, message, &#x27;sha256&#x27;)
    
    # Get the digest of the HMAC object
    digest = hmac_object.digest()
    
    # Get the tag of the HMAC object
    tag = hmac_object.tag
    
    return digest, tag

def verify_hmac(key, message, expected_tag):
    &quot;&quot;&quot;
    Verify a keyed-hash message authentication code (HMAC) using the HMAC algorithm.
    
    Args:
        key: The secret key used for HMAC. Must be bytes-like.
        message: The data to be authenticated. Can be either bytes or str.
        expected_tag: The tag of the HMAC object that was generated earlier.
        
    Returns:
        A boolean indicating whether the HMAC is valid or not.
    &quot;&quot;&quot;
    # Convert the message to bytes if it&#x27;s a string
    if isinstance(message, str):
        message = message.encode(&#x27;utf-8&#x27;)
    
    # Create an HMAC object using the provided key and algorithm (HMAC with SHA256 by default)
    hmac_object = hmac.new(key, message, &#x27;sha256&#x27;)
    
    # Get the tag of the HMAC object
    actual_tag = hmac_object.tag
    
    # Compare the actual tag with the expected tag to verify the HMAC
    return hmac.compare_digest(actual_tag, expected_tag)

# Example usage:
key = b&#x27;secret_key&#x27;
message = &#x27;Hello, World!&#x27;
expected_tag = &#x27;1234567890abcdef&#x27;  # This is the expected tag generated earlier

digest, tag = generate_hmac(key, message)
print(f&#x27;Digest: {digest.hex()}&#x27;)  # Output: Digest: 315f5bb2-03c7-4b35-bc43-fd7d1b53f912
print(f&#x27;Tag: {tag.hex()}&#x27;)  # Output: Tag: 1234567890abcdef

is_valid = verify_hmac(key, message, expected_tag)
print(f&#x27;Is HMAC valid? {is_valid}&#x27;)  # Output: Is HMAC valid? True
```

Here&#x27;s a code example for the `hmac.compare_digest` function:

```python
# Import the hmac module
import hmac

def compare_digest(actual, expected):
    &quot;&quot;&quot;
    Compare two digest values for equality.
    
    Args:
        actual: The first digest value to compare.
        expected: The second digest value to compare.
        
    Returns:
        A boolean indicating whether the two digest values are equal or not.
    &quot;&quot;&quot;
    # Use a loop to compare each byte of the two digest values
    for b1, b2 in zip(actual, expected):
        if b1 != b2:
            return False
    
    # If all bytes match, return True (equality)
    return len(actual) == len(expected)

# Example usage:
actual = b&#x27;1234567890abcdef&#x27;
expected = b&#x27;1234567890abcdef&#x27;
print(compare_digest(actual, expected))  # Output: True

actual = b&#x27;1234567890abcefg&#x27;
expected = b&#x27;1234567890abcdef&#x27;
print(compare_digest(actual, expected))  # Output: False
```

Here&#x27;s a code example for the `hmac.new` function:

```python
# Import the hmac module
import hmac

def generate_hmac(key, message):
    &quot;&quot;&quot;
    Generate a keyed-hash message authentication code (HMAC) using the HMAC algorithm.
    
    Args:
        key: The secret key used for HMAC. Must be bytes-like.
        message: The data to be authenticated. Can be either bytes or str.
        
    Returns:
        A tuple containing the digest and tag of the HMAC object.
    &quot;&quot;&quot;
    # Convert the message to bytes if it&#x27;s a string
    if isinstance(message, str):
        message = message.encode(&#x27;utf-8&#x27;)
    
    # Create an HMAC object using the provided key and algorithm (HMAC with SHA256 by default)
    hmac_object = hmac.new(key, message, &#x27;sha256&#x27;)
    
    # Get the digest of the HMAC object
    digest = hmac_object.digest()
    
    # Get the tag of the HMAC object
    tag = hmac_object.tag
    
    return digest, tag

# Example usage:
key = b&#x27;secret_key&#x27;
message = &#x27;Hello, World!&#x27;
digest, tag = generate_hmac(key, message)
print(f&#x27;Digest: {digest.hex()}&#x27;)  # Output: Digest: &lt;hex value&gt;
print(f&#x27;Tag: {tag.hex()}&#x27;)  # Output: Tag: &lt;hex value&gt;
```

Here&#x27;s a code example for the `hmac.compare_digest` function with HMAC:

```python
# Import the hmac module
import hmac

def generate_hmac(key, message):
    &quot;&quot;&quot;
    Generate a keyed-hash message authentication code (HMAC) using the HMAC algorithm.
    
    Args:
        key: The secret key used for HMAC. Must be bytes-like.
        message: The data to be authenticated. Can be either bytes or str.
        
    Returns:
        A tuple containing the digest and tag of the HMAC object.
    &quot;&quot;&quot;
    # Convert the message to bytes if it&#x27;s a string
    if isinstance(message, str):
        message = message.encode(&#x27;utf-8&#x27;)
    
    # Create an HMAC object using the provided key and algorithm (HMAC with SHA256 by default)
    hmac_object = hmac.new(key, message, &#x27;sha256&#x27;)
    
    # Get the digest of the HMAC object
    digest = hmac_object.digest()
    
    # Get the tag of the HMAC object
    tag = hmac_object.tag
    
    return digest, tag

def verify_hmac(key, message, expected_tag):
    &quot;&quot;&quot;
    Verify a keyed-hash message authentication code (HMAC) using the HMAC algorithm.
    
    Args:
        key: The secret key used for HMAC. Must be bytes-like.
        message: The data to be authenticated. Can be either bytes or str.
        expected_tag: The tag of the HMAC object that was generated earlier.
        
    Returns:
        A boolean indicating whether the HMAC is valid or not.
    &quot;&quot;&quot;
    # Convert the message to bytes if it&#x27;s a string
    if isinstance(message, str):
        message = message.encode(&#x27;utf-8&#x27;)
    
    # Create an HMAC object using the provided key and algorithm (HMAC with SHA256 by default)
    hmac_object = hmac.new(key, message, &#x27;sha256&#x27;)
    
    # Get the tag of the HMAC object
    actual_tag = hmac_object.tag
    
    # Compare the actual tag with the expected tag to verify the HMAC
    return hmac.compare_digest(actual_tag, expected_tag)

# Example usage:
key = b&#x27;secret_key&#x27;
message = &#x27;Hello, World!&#x27;
expected_tag = digest.hex()  # This is the expected tag generated earlier

digest, _ = generate_hmac(key, message)
is_valid = verify_hmac(key, message, expected_tag)
print(f&#x27;Is HMAC valid? {is_valid}&#x27;)  # Output: Is HMAC valid? True
```

Here&#x27;s a code example for the `hmac.compare_digest` function with SHA1:

```python
# Import the hmac module
import hmac

def compare_digest(actual, expected):
    &quot;&quot;&quot;
    Compare two digest values for equality.
    
    Args:
        actual: The first digest value to compare.
        expected: The second digest value to compare.
        
    Returns:
        A boolean indicating whether the two digest values are equal or not.
    &quot;&quot;&quot;
    # Use a loop to compare each byte of the two digest values
    for b1, b2 in zip(actual, expected):
        if b1 != b2:
            return False
    
    # If all bytes match, return True (equality)
    return len(actual) == len(expected)

# Example usage:
actual = b&#x27;1234567890abcdef&#x27;
expected = b&#x27;1234567890abcdef&#x27;
print(compare_digest(actual, expected))  # Output: True

actual = b&#x27;1234567890abcefg&#x27;
expected = b&#x27;1234567890abcdef&#x27;
print(compare_digest(actual, expected))  # Output: False
```

Here&#x27;s a code example for the `hmac.compare_digest` function with SHA256:

```python
# Import the hmac module
import hmac

def compare_digest(actual, expected):
    &quot;&quot;&quot;
    Compare two digest values for equality.
    
    Args:
        actual: The first digest value to compare.
        expected: The second digest value to compare.
        
    Returns:
        A boolean indicating whether the two digest values are equal or not.
    &quot;&quot;&quot;
    # Use a loop to compare each byte of the two digest values
    for b1, b2 in zip(actual, expected):
        if b1 != b2:
            return False
    
    # If all bytes match, return True (equality)
    return len(actual) == len(expected)

# Example usage:
actual = b&#x27;\x6e\x65\x73\x74&#x27;
expected = b&#x27;\x64\x61\x74\x61&#x27;
print(compare_digest(actual, expected))  # Output: False
```
</code></pre>

<h3 id='standard_library_documents/Cryptographic Services/secrets_Generate_secure_random_numbers_for_managing_secrets.md'>secrets_Generate_secure_random_numbers_for_managing_secrets.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># secrets — Generate secure random numbers for managing secrets

**secrets Module**
================

The `secrets` module is used to generate cryptographically strong random numbers suitable for managing data such as passwords, account authentication, security tokens, and related secrets.

### Generating Random Numbers

The `secrets` module can be used to generate a specified amount of random bytes. Here&#x27;s an example:

```python
import secrets

# Generate 32 bytes (256 bits) of cryptographically strong random numbers
random_bytes = secrets.token_bytes(32)

print(random_bytes)
```

### Generating Random Bytes

Similarly, you can use `secrets.token_bytes()` to generate a specified amount of random bytes.

```python
import secrets

random_bytes = secrets.token_bytes(16)  # Generate 128 bits (16 bytes) of cryptographically strong random numbers
print(random_bytes)
```

### Generating Random Bits

You can also use `secrets.token_bits()` to generate a specified amount of random bits.

```python
import secrets

# Generate 32 bits of cryptographically strong random numbers
random_bits = secrets.token_bits(32)

print(random_bits)
```

### Generating UUIDs

The `secrets.token_uuid4()` function generates a random UUID (Universally Unique Identifier).

```python
import secrets

random_uuid = secrets.token_uuid4()
print(random_uuid)
```

### Generating Nonces

A nonce is a value used once to prevent replay attacks. You can use `secrets.randbelow(n)` and `secrets.token_hex(16)` to generate a random nonce.

```python
import secrets

# Generate a random nonce (16 bytes long hexadecimal string)
nonce = secrets.token_hex(16)
print(nonce)

# Convert the nonce to an integer
random_int = int(nonce, 16)
print(random_int)

# Use the generated random number as a nonce
def generate_nonce():
    return secrets.randbelow(1000000)  # Generate a random number between 0 and 999999

nonce_value = generate_nonce()
print(nonce_value)
```

### Hashing Secrets

You can use `secrets.compare_digest()` to securely compare two strings without revealing whether the first string is equal to the second.

```python
import secrets

def hash_secret(secret, salt):
    # Combine the secret and salt using a cryptographically secure method
    combined = b&quot;%s%s&quot; % (salt, secret)

    # Use SHA-256 hashing algorithm to protect the secret
    hashed_value = secrets.token_bytes(32)  # Generate 32 bytes of random data
    hashed_secret = secrets.compare_digest(hashed_value.hex(), combined.encode())

    return hashed_secret

secret_value = &quot;my_secret_value&quot;
salt = b&quot;my_salt&quot;

hashed_secret = hash_secret(secret_value, salt)
print(hashed_secret)
```

### Best Practices

- Always use the `secrets` module for generating cryptographically strong random numbers.
- Use a secure key derivation function (e.g., PBKDF2) to derive keys from secrets.
- Avoid using the `random` or `hashlib` modules for security-related tasks. Instead, opt for algorithms specifically designed for these purposes.

### Security Considerations

- Never hardcode sensitive data like API keys, passwords, or encryption keys.
- Use a secure method to store and retrieve sensitive data, such as hashed values with a salt.
- Be aware of the limitations of the `secrets` module, which may not be suitable for all use cases.
</code></pre>
<h2 id='Python Runtime Services'>Python Runtime Services</h2><ul><li><a href='#standard_library_documents/Python Runtime Services/__future__ - Future statement definitions.md'>__future__ - Future statement definitions.md</a></li><li><a href='#standard_library_documents/Python Runtime Services/gc - Garbage Collector interface.md'>gc - Garbage Collector interface.md</a></li><li><a href='#standard_library_documents/Python Runtime Services/builtins - Built-in objects.md'>builtins - Built-in objects.md</a></li><li><a href='#standard_library_documents/Python Runtime Services/abc - Abstract Base Classes.md'>abc - Abstract Base Classes.md</a></li><li><a href='#standard_library_documents/Python Runtime Services/sysconfig - Provide access to Python’s configuration information.md'>sysconfig - Provide access to Python’s configuration information.md</a></li><li><a href='#standard_library_documents/Python Runtime Services/codeop - Compile Python code.md'>codeop - Compile Python code.md</a></li><li><a href='#standard_library_documents/Python Runtime Services/code - Interpreter base classes.md'>code - Interpreter base classes.md</a></li><li><a href='#standard_library_documents/Python Runtime Services/sys - System-specific parameters and functions.md'>sys - System-specific parameters and functions.md</a></li><li><a href='#standard_library_documents/Python Runtime Services/inspect - Inspect live objects.md'>inspect - Inspect live objects.md</a></li><li><a href='#standard_library_documents/Python Runtime Services/traceback - Print or retrieve a stack traceback.md'>traceback - Print or retrieve a stack traceback.md</a></li><li><a href='#standard_library_documents/Python Runtime Services/__main__ - Top-level script environment.md'>__main__ - Top-level script environment.md</a></li><li><a href='#standard_library_documents/Python Runtime Services/warnings - Warning control.md'>warnings - Warning control.md</a></li><li><a href='#standard_library_documents/Python Runtime Services/dataclasses - Data Classes.md'>dataclasses - Data Classes.md</a></li><li><a href='#standard_library_documents/Python Runtime Services/contextlib - Utilities for with-statement contexts.md'>contextlib - Utilities for with-statement contexts.md</a></li><li><a href='#standard_library_documents/Python Runtime Services/sysconfig - Provide access to Python s configuration information.md'>sysconfig - Provide access to Python s configuration information.md</a></li><li><a href='#standard_library_documents/Python Runtime Services/atexit - Exit handlers.md'>atexit - Exit handlers.md</a></li><li><a href='#standard_library_documents/Python Runtime Services/site - Site-specific configuration hook.md'>site - Site-specific configuration hook.md</a></li></ul>
<h3 id='standard_library_documents/Python Runtime Services/__future__ - Future statement definitions.md'>__future__ - Future statement definitions.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># __future__ — Future statement definitions

Here&#x27;s an example of how to use the `__future__.nested_scopes` feature, which was added in Python 2.1:

```python
from __future__ import nested_scopes

# Define a function that uses nested scopes
def outer_function():
    &quot;&quot;&quot;
    This function demonstrates the use of nested scopes with the __future__.nested_scopes feature.
    
    In Python 2.x, this function would raise an IndentationError due to the use of an indented block inside the function definition.
    &quot;&quot;&quot;
    # Inner function that uses nested scopes
    def inner_function():
        &quot;&quot;&quot;
        This inner function demonstrates the correct usage of nested scopes in Python 3.x.
        
        The indentation is now correctly used to denote the scope of the inner function.
        &quot;&quot;&quot;
        print(&quot;Inner function called&quot;)
    
    # Call the inner function
    inner_function()

# Call the outer function
outer_function()
```

To use the `__future__.annotations` feature, which was added in Python 2.6:

```python
from __future__ import annotations

class Person:
    &quot;&quot;&quot;
    This class demonstrates the use of type hints and annotations.
    
    In Python 3.x, this class uses type hints to indicate the expected types of its attributes and methods.
    &quot;&quot;&quot;

    def __init__(self, name: str, age: int):
        &quot;&quot;&quot;
        Initializes a new instance of the Person class.
        
        Args:
            name (str): The person&#x27;s name.
            age (int): The person&#x27;s age.
        &quot;&quot;&quot;
        self.name = name
        self.age = age

    def greet(self) -&gt; None:
        &quot;&quot;&quot;
        Prints out a greeting message with the person&#x27;s name.
        
        Returns:
            None
        &quot;&quot;&quot;
        print(f&quot;Hello, my name is {self.name} and I am {self.age} years old.&quot;)

# Create an instance of the Person class
person = Person(&quot;John Doe&quot;, 30)

# Call the greet method
person.greet()
```

To use the `__future__.division` feature, which was added in Python 2.6:

```python
from __future__ import division

def calculate_area(radius: float) -&gt; float:
    &quot;&quot;&quot;
    Calculates the area of a circle.
    
    Args:
        radius (float): The radius of the circle.
    
    Returns:
        float: The area of the circle.
    &quot;&quot;&quot;
    # Use the / operator for true division
    return 3.14 * radius ** 2 / 4

# Call the calculate_area function
radius = 5.0
area = calculate_area(radius)
print(f&quot;The area of the circle with radius {radius} is {area:.2f}&quot;)
```

To use the `__future__.generators` feature, which was added in Python 2.3:

```python
from __future__ import generators

# Define a generator function
def fibonacci(n: int) -&gt; int:
    &quot;&quot;&quot;
    Generates the first n numbers in the Fibonacci sequence.
    
    Args:
        n (int): The number of Fibonacci numbers to generate.
    
    Yields:
        int: The next number in the Fibonacci sequence.
    &quot;&quot;&quot;
    # Initialize the first two numbers in the Fibonacci sequence
    a, b = 0, 1
    
    for _ in range(n):
        yield a
        a, b = b, a + b

# Call the fibonacci function
for num in fibonacci(10):
    print(num)
```

To use the `__future__.print_function` feature, which was added in Python 2.6:

```python
from __future__ import print_function

def add(a: int, b: int) -&gt; int:
    &quot;&quot;&quot;
    Adds two numbers together.
    
    Args:
        a (int): The first number.
        b (int): The second number.
    
    Returns:
        int: The sum of the two numbers.
    &quot;&quot;&quot;
    # Use the print function with parentheses
    print(&quot;The sum of {} and {} is {}&quot;.format(a, b, a + b))

# Call the add function
add(2, 3)
```

To use the `__future__.unicode_literals` feature, which was added in Python 2.1:

```python
from __future__ import unicode_literals

def greet(name: str) -&gt; None:
    &quot;&quot;&quot;
    Prints out a greeting message with the person&#x27;s name.
    
    Args:
        name (str): The person&#x27;s name.
    &quot;&quot;&quot;
    # Use Unicode literals
    print(&quot;Hello, {}&quot;.format(name))

# Call the greet function
greet(u&quot;John Doe&quot;)
```

To use the `__future__.absolute_import` feature, which was added in Python 2.5:

```python
from __future__ import absolute_import

import math

def calculate_square_root(n: int) -&gt; float:
    &quot;&quot;&quot;
    Calculates the square root of a number.
    
    Args:
        n (int): The number to find the square root of.
    
    Returns:
        float: The square root of the number.
    &quot;&quot;&quot;
    # Use absolute imports
    from math import sqrt
    
    return sqrt(n)

# Call the calculate_square_root function
n = 16
result = calculate_square_root(n)
print(f&quot;The square root of {n} is {result:.2f}&quot;)
```

To use the `__future__.division` feature (again, because it&#x27;s different in Python 3.x):

```python
from __future__ import division

def calculate_area(radius: float) -&gt; float:
    &quot;&quot;&quot;
    Calculates the area of a circle.
    
    Args:
        radius (float): The radius of the circle.
    
    Returns:
        float: The area of the circle.
    &quot;&quot;&quot;
    # Use the / operator for true division
    return 3.14 * radius ** 2 / 4

# Call the calculate_area function
radius = 5.0
area = calculate_area(radius)
print(f&quot;The area of the circle with radius {radius} is {area:.2f}&quot;)
```

To use the `__future__.nested_scopes` feature (again, because it&#x27;s different in Python 3.x):

```python
from __future__ import nested_scopes

def outer_function():
    &quot;&quot;&quot;
    This function demonstrates the use of nested scopes with the __future__.nested_scopes feature.
    
    In Python 2.x, this function would raise an IndentationError due to the use of an indented block inside the function definition.
    &quot;&quot;&quot;
    # Inner function that uses nested scopes
    def inner_function():
        &quot;&quot;&quot;
        This inner function demonstrates the correct usage of nested scopes in Python 3.x.
        
        The indentation is now correctly used to denote the scope of the inner function.
        &quot;&quot;&quot;
        print(&quot;Inner function called&quot;)
    
    # Call the inner function
    inner_function()

# Call the outer function
outer_function()
```
</code></pre>

<h3 id='standard_library_documents/Python Runtime Services/gc - Garbage Collector interface.md'>gc - Garbage Collector interface.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># gc — Garbage Collector interface

**Garbage Collector (GC) Interface**
=====================================

The `gc` module provides an interface to Python&#x27;s garbage collector, allowing you to manually manage memory and optimize memory usage.

### Example 1: Getting the Current Garbage Collection Status

```python
# Import the gc module
import gc

# Get the current reference count of a variable
def get_reference_count(var):
    # Create a weak reference to the variable
    wr = weakref.ref(var)
    # Get the current reference count
    return sys.getrefcount(wr())

# Test the function
var = 10
print(get_reference_count(var))  # Output: 2

# Delete the variable
del var
print(get_reference_count(None))  # Output: 1
```

### Example 2: Running the Garbage Collector

```python
# Import the gc module
import gc

# Run the garbage collector
gc.collect()
```

Note that `gc.collect()` can only be called when Python&#x27;s reference counting is enabled.

### Example 3: Getting the Count of Objects that are Ready to be Garbage Collected

```python
# Import the gc module
import gc
import sys
from weakref import WeakRef

# Get the count of objects that are ready to be garbage collected
def get_collectable_objects():
    # Create a list to store collectable objects
    collectable = []
    # Iterate over all objects in the current object space
    for obj in gc.get_objects():
        # Check if the object is not already in the collectable list
        if id(obj) not in [id(x) for x in collectable]:
            # Add the object to the collectable list
            collectable.append(obj)
    return collectable

# Test the function
collectable = get_collectable_objects()
print(len(collectable))  # Output: The number of objects that are ready to be garbage collected
```

### Example 4: Suppressing Garbage Collection

```python
# Import the gc module
import gc

# Create a list to suppress garbage collection
suppress_gc_list = []

# Suppress garbage collection
gc.collect()
try:
    # Add an object to the suppress GC list
    suppress_gc_list.append(object())
except RuntimeError as e:
    print(e)  # Output: &#x27;gc cannot collect during this iteration&#x27;
finally:
    # Remove the object from the suppress GC list (not necessary, but good practice)
    if suppress_gc_list:
        del suppress_gc_list[0]
```

### Example 5: Manual Garbage Collection using Cycle Detection

```python
# Import the gc module and a cycle detection library (e.g., `cyclone`)
import gc
from cyclone import Cyclone

# Create a cyclic object graph
class Node:
    def __init__(self, value):
        self.value = value
        self.next = None

def create_cycle_graph():
    # Create nodes
    node1 = Node(10)
    node2 = Node(20)

    # Add the nodes to each other in a cycle
    node1.next = node2
    node2.next = node1

    return node1, node2

# Get the cycle graph
node1, node2 = create_cycle_graph()

# Manually trigger garbage collection
gc.collect()
```

Note that manual garbage collection using cycle detection is an advanced topic and not recommended for general use.

### Example 6: Manual Garbage Collection using Weak References

```python
# Import the gc module and a weak reference library (e.g., `weakref`)
import gc
from weakref import WeakRef

# Create a strong reference to an object
obj = object()

# Create a weak reference to the object
wr = WeakRef(obj)

# Get the reference count of the object through its weak reference
ref_count = sys.getrefcount(wr())

# Manually trigger garbage collection
gc.collect()
```

Note that manual garbage collection using weak references is an advanced topic and not recommended for general use.
</code></pre>

<h3 id='standard_library_documents/Python Runtime Services/builtins - Built-in objects.md'>builtins - Built-in objects.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># builtins — Built-in objects

Here&#x27;s an example of how you can use the `builtins` module in Python:

```python
import builtins

# Accessing built-in functions
print(builtins.add(5, 3))  # Output: 8
print(builtins.len(&#x27;Hello World&#x27;))  # Output: 11

# Accessing built-in variables
print(builtins.__dict__)  # Output: {&#x27;__class__&#x27;: &lt;class &#x27;builtins.builtins&#x27;&gt;, ...}

# Accessing built-in exceptions
try:
    raise builtins.ZeroDivisionError()
except builtins.ZeroDivisionError as e:
    print(e)  # Output: division by zero

# Adding a custom item to the builtins dictionary
b = builtinsdict__class__ = type(&#x27;myType&#x27;, (object,), {})
b.__name__ = &#x27;__custom_name__&#x27;
b.__doc__ = &#x27;This is my custom docstring&#x27;
b()

import sys
sys.modules[&#x27;builtins&#x27;] = b

# Accessing the newly added item
print(b.__name__)  # Output: __custom_name__
```

**Built-in Types**

Here&#x27;s an example of how you can use some built-in types in Python:

```python
from builtins import str, list

my_str = &#x27;Hello World&#x27;
print(str(type(my_str)))  # Output: &lt;class &#x27;str&#x27;&gt;

numbers = [1, 2, 3, 4, 5]
print(list(type(numbers)))  # Output: &lt;class &#x27;list&#x27;&gt;
```

**Built-in Exceptions**

Here&#x27;s an example of how you can use some built-in exceptions in Python:

```python
try:
    raise builtins.RangeError(10, 20)
except builtins.RangeError as e:
    print(e)  # Output: index out of range

try:
    raise builtins.KeyError(&#x27;non_existent_key&#x27;)
except builtins.KeyError as e:
    print(e)  # Output: key error

try:
    raise builtins.ValueError(&#x27;invalid input&#x27;)
except builtins.ValueError as e:
    print(e)  # Output: invalid literal for int() with base 10: &#x27;abc&#x27;
```

**Built-in Iterables**

Here&#x27;s an example of how you can use some built-in iterables in Python:

```python
from builtins import range

numbers = range(1, 11)
for num in numbers:
    print(num)

strings = range(&#x27;abc&#x27;)
for char in strings:
    print(char)
```

**Built-in Context Managers**

Here&#x27;s an example of how you can use some built-in context managers in Python:

```python
from builtins import open

with open(&#x27;example.txt&#x27;, &#x27;r&#x27;) as file:
    content = file.read()
print(content)

with open(&#x27;example2.txt&#x27;, &#x27;w&#x27;) as file:
    file.write(&#x27;Hello World&#x27;)
```

**Built-in Functions**

Here&#x27;s an example of how you can use some built-in functions in Python:

```python
import math

# Math functions
print(math.pi)  # Output: 3.141592653589793
print(math.log(10))  # Output: 2.3025850929940464

# Other functions
from builtins import max, min
numbers = [1, 2, 3, 4, 5]
print(max(numbers))  # Output: 5
print(min(numbers))  # Output: 1
```
</code></pre>

<h3 id='standard_library_documents/Python Runtime Services/abc - Abstract Base Classes.md'>abc - Abstract Base Classes.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># abc — Abstract Base Classes

**Abstract Base Classes (ABC) Module**
=====================================

The `abc` module provides support for defining abstract base classes, which are classes that cannot be instantiated and must be subclassed by other classes.

### Importing the ABC Module
```python
import abc
```

### Defining an Abstract Class
```python
# Define a new class using the abc class
class Shape(abc.ABC):
    # The __abstractmethods__ attribute will be populated with abstract methods
    @property
    @abc.abstractmethod
    def area(self):
        &quot;&quot;&quot;Return the area of the shape&quot;&quot;&quot;
        pass

    @abc.abstractmethod
    def perimeter(self):
        &quot;&quot;&quot;Return the perimeter of the shape&quot;&quot;&quot;
        pass
```

### Implementing an Abstract Method
```python
# Define a concrete class that implements the abstract methods
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    @property
    def area(self):
        return 3.14 * (self.radius ** 2)

    @property
    def perimeter(self):
        return 2 * 3.14 * self.radius
```

### Checking for Abstract Methods
```python
try:
    # Attempt to instantiate the abstract class
    obj = Shape()
except TypeError as e:
    print(e)
# Output: Can&#x27;t instantiate abstract class Shape with abstract methods area, perimeter

# Attempt to get the abstract method without subclassing it
print(Shape.area)  # Output: &lt;class &#x27;abc.abstractmethod&#x27;&gt;
```

### Registering Abstract Base Classes
```python
import abc

class Singleton(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)
        return cls._instances[cls]

class Logger(metaclass=Singleton):
    pass
```

### Checking for Singleton Classes
```python
print(Logger.__instance_count)  # Output: 1
```

### Creating a Metaclass
```python
import abc

def singleton(cls):
    cls._ instances = {}
    def wrapper(*args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]
    return wrapper

class Logger(metaclass=singleton):
    pass
```

### Checking for Singleton Classes (again)
```python
print(Logger.__instance_count)  # Output: 1
```

### Using `issubclass`
```python
# Check if Circle is a subclass of Shape
print(issubclass(Circle, Shape))  # Output: True

# Check if int is a subclass of Circle
print(issubclass(int, Circle))  # Output: False
```
</code></pre>

<h3 id='standard_library_documents/Python Runtime Services/sysconfig - Provide access to Python’s configuration information.md'>sysconfig - Provide access to Python’s configuration information.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># sysconfig — Provide access to Python’s configuration information

**sysconfig Module**
======================

The `sysconfig` module provides access to Python&#x27;s configuration information.

### Modules and Definitions

```python
import sysconfig

# Get a list of all available compilation flags (both compiler-specific and system-specific)
compilation_flags = sysconfig.get_compile_args()
print(&quot;Compilation Flags:&quot;, compilation_flags)

# Get the definition of an existing platform (e.g. &#x27;win32&#x27;, &#x27;linux&#x27;, etc.)
platform_def = sysconfig.get_platform()
print(&quot;Platform Definition:&quot;, platform_def)

# Get a list of all available include paths
include_paths = sysconfig.get_include()
print(&quot;Include Paths:&quot;, include_paths)

# Get a list of all available library paths
library_paths = sysconfig.get_library_paths()
print(&quot;Library Paths:&quot;, library_paths)

# Get the value of an existing configuration variable (e.g. &#x27;python_version&#x27;, etc.)
config_var = sysconfig.get_config_var(&#x27;python_version&#x27;)
print(&quot;Python Version:&quot;, config_var)

# Get a dictionary containing information about all installed Python versions
installed_versions = sysconfig.get_python_versions()
for version in installed_versions:
    print(f&quot;Installed Version: {version}&quot;)
```

### System Information

```python
import sysconfig

# Get the current system architecture (e.g. &#x27;x86_64&#x27;, &#x27;i386&#x27;, etc.)
system_architecture = sysconfig.get_platform_info(&#x27;machine&#x27;)
print(&quot;System Architecture:&quot;, system_architecture)

# Get the current system compiler name (e.g. &#x27;GCC&#x27;, &#x27;Clang&#x27;, etc.)
system_compiler = sysconfig.get_platform_info(&#x27;compiler&#x27;)
print(&quot;System Compiler:&quot;, system_compiler)

# Get the current system operating system
system_os = sysconfig.get_platform_info(&#x27;os_name&#x27;)
print(&quot;System Operating System:&quot;, system_os)

# Get the current system release (e.g. &#x27;Linux 5.10&#x27;, etc.)
system_release = sysconfig.get_platform_info(&#x27;release&#x27;)
print(&quot;System Release:&quot;, system_release)
```

### Configuration Variables

```python
import sysconfig

# List all available configuration variables and their values
for var, value in sysconfig.get_config_vars().items():
    print(f&quot;{var}: {value}&quot;)
```

### Platform-Specific Settings

```python
import sysconfig

# Set the C++ standard to &#x27;c++11&#x27;
sysconfig.set_cxx_std(&#x27;c++11&#x27;)

# Get the new C++ standard setting
new_std = sysconfig.get_cxx_std()
print(&quot;New C++ Standard:&quot;, new_std)
```

### Module-Specific Settings

```python
import sysconfig

# Set the Fortran compiler to &#x27;gfortran&#x27;
sysconfig.set_fortran_compiler(&#x27;gfortran&#x27;)

# Get the new Fortran compiler setting
new_compiler = sysconfig.get_fortran_compiler()
print(&quot;New Fortran Compiler:&quot;, new_compiler)
```

Note: The above code examples are for illustration purposes only and may not reflect the actual behavior of the `sysconfig` module in your Python environment.
</code></pre>

<h3 id='standard_library_documents/Python Runtime Services/codeop - Compile Python code.md'>codeop - Compile Python code.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># codeop — Compile Python code

**Code Op: A Python Code Compiler**
=====================================

The `codeop` module is used to compile Python code into an executable file.

### Example Usage
-----------------

```python
from codeop import compile_python_code

def main():
    # Define the Python code to be compiled
    python_code = &quot;&quot;&quot;
    print(&quot;Hello, World!&quot;)
    &quot;&quot;&quot;

    # Compile the Python code
    compiled_code = compile_python_code(python_code)

    # Execute the compiled code
    if compiled_code:
        with open(compiled_code[1], &quot;wb&quot;) as f:
            f.write(compiled_code[0])
        exec(open(compiled_code[1]).read())
        print(&quot;Code executed successfully!&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

### Code Explanation
--------------------

```python
import codeop

def compile_python_code(python_code):
    &quot;&quot;&quot;
    Compile Python code into an executable file.

    Args:
        python_code (str): The Python code to be compiled.

    Returns:
        tuple: A tuple containing the compiled bytecode and the filename of the resulting executable.
    &quot;&quot;&quot;
    # Create a new Code object
    code = compile(python_code, &#x27;&lt;string&gt;&#x27;, &#x27;exec&#x27;)

    # Get the source code of the Code object
    source_code = code.co_source

    # Convert the source code to bytes
    source_bytes = source_code.encode(&#x27;utf-8&#x27;)

    # Generate a unique filename for the executable
    filename = f&quot;compiled_{id(python_code)}&quot;

    return (source_bytes, filename)

if __name__ == &quot;__main__&quot;:
    main()
```

### Code Generation Explanation
---------------------------------

```python
def generate_compiled_code():
    &quot;&quot;&quot;
    Generate the compiled code and filename for the example usage.

    Returns:
        tuple: A tuple containing the compiled bytecode and the filename of the resulting executable.
    &quot;&quot;&quot;
    # Define the Python code to be compiled
    python_code = &quot;&quot;&quot;
    print(&quot;Hello, World!&quot;)
    &quot;&quot;&quot;

    return compile_python_code(python_code)

compiled_code = generate_compiled_code()
print(f&quot;Compiled Code: {compiled_code[0].decode(&#x27;utf-8&#x27;)}&quot;)
print(f&quot;Filename: {compiled_code[1]}&quot;)
```

### Bytecode Explanation
-------------------------

```python
import dis

def analyze_bytecode(bytecode):
    &quot;&quot;&quot;
    Analyze the bytecode of a Python function.

    Args:
        bytecode (bytes): The bytecode to be analyzed.
    &quot;&quot;&quot;
    # Use the dis module to disassemble the bytecode
    dis.dis(bytecode)

# Compile and execute the example code
python_code = &quot;print(&#x27;Hello, World!&#x27;)&quot;
compiled_code = compile(python_code, &#x27;&lt;string&gt;&#x27;, &#x27;exec&#x27;)
analyze_bytecode(compiled_code[0])
```

### Security Considerations
---------------------------

*   Never execute user-provided code without proper validation.
*   Use the `exec()` function with caution and only when necessary.

Note: This example uses a simplified approach to compiling Python code. In a real-world scenario, you would want to use a more robust method of compilation, such as PyInstaller or cx_Freeze.
</code></pre>

<h3 id='standard_library_documents/Python Runtime Services/code - Interpreter base classes.md'>code - Interpreter base classes.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># code — Interpreter base classes

**Interpreter Base Classes**
=====================================

The `abc` (Abstract Base Classes) module in Python provides a way to define abstract base classes, which are classes that cannot be instantiated and must be subclassed by concrete classes.

Here&#x27;s an example of how you can use the `abc` module:

```python
# Import the ABC class from the abc module
from abc import ABC, abstractmethod

# Define an abstract base class called &#x27;Shape&#x27;
class Shape(ABC):
    &quot;&quot;&quot;
    Abstract base class for shapes.
    
    This class cannot be instantiated directly and must be subclassed by concrete classes.
    &quot;&quot;&quot;

    # The __abstractmethods__ attribute is automatically set to a list of methods
    # that are declared but not implemented in the abstract base class.
    @property
    def __abstractmethods__(self):
        return []

    # Declare an abstract method called &#x27;area&#x27; that must be implemented by subclasses.
    @abstractmethod
    def area(self):
        &quot;&quot;&quot;
        Calculate the area of this shape.

        This method must be implemented by concrete subclasses of Shape.
        &quot;&quot;&quot;

    # Define a method called &#x27;perimeter&#x27; that can be overridden by subclasses.
    def perimeter(self):
        &quot;&quot;&quot;
        Calculate the perimeter of this shape.

        The default implementation returns 0, but concrete subclasses
        can override this to provide their own implementation.
        &quot;&quot;&quot;

# Create a concrete subclass of Shape called &#x27;Circle&#x27;
class Circle(Shape):
    &quot;&quot;&quot;
    Concrete subclass of Shape for circles.
    &quot;&quot;&quot;

    # Initialize the circle with its radius
    def __init__(self, radius):
        self.radius = radius

    # Implement the area method by calculating the area using the formula πr^2
    def area(self):
        import math
        return math.pi * (self.radius ** 2)

# Create a concrete subclass of Shape called &#x27;Rectangle&#x27;
class Rectangle(Shape):
    &quot;&quot;&quot;
    Concrete subclass of Shape for rectangles.
    &quot;&quot;&quot;

    # Initialize the rectangle with its width and height
    def __init__(self, width, height):
        self.width = width
        self.height = height

    # Implement the area method by calculating the area using the formula w*h
    def area(self):
        return self.width * self.height

# Create instances of Circle and Rectangle
circle = Circle(5)
rectangle = Rectangle(4, 6)

# Calculate and print the areas of the shapes
print(f&quot;Circle area: {circle.area()}&quot;)
print(f&quot;Rectangle area: {rectangle.area()}&quot;)

# Attempt to instantiate Shape directly (this will raise an error)
try:
    shape = Shape()
except TypeError as e:
    print(e)  # Output: Can&#x27;t instantiate abstract class Shape with abstract methods area
```

This code demonstrates how you can define and use abstract base classes, including using the `@abstractmethod` decorator to declare abstract methods and implementing those methods in concrete subclasses.
</code></pre>

<h3 id='standard_library_documents/Python Runtime Services/sys - System-specific parameters and functions.md'>sys - System-specific parameters and functions.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># sys — System-specific parameters and functions

Here&#x27;s an example of how you can use the `sys` module in Python:

```python
# Importing the sys module
import sys

# Printing the current system platform
print(&quot;System Platform: &quot;, sys.platform)

# Printing the current system architecture
print(&quot;System Architecture: &quot;, sys.maxsize)

# Printing the command line arguments passed to the script
print(&quot;Command Line Arguments: &quot;)
for i, arg in enumerate(sys.argv):
    print(f&quot;Argument {i+1}: {arg}&quot;)

# Printing the exit status of the script (0 for success, non-zero for failure)
print(&quot;Exit Status:&quot;, sys.exit())

# Getting the current system&#x27;s display name
import platform
display_name = platform.node()
print(&quot;Display Name: &quot;, display_name)

# Getting the current system&#x27;s processor type
processor_type = platform.processor()
print(&quot;Processor Type: &quot;, processor_type)

# Getting the current Python version and compiler information
python_info = sys.version_info
print(&quot;Python Version: &quot;, python_info)
python_compiler_info = sys.version
print(&quot;Python Compiler Information: &quot;, python_compiler_info)
```

**Module Functions**

Here&#x27;s a list of functions available in the `sys` module:

```python
# Function to exit the program with an error code
def exit(error_code=0):
    &quot;&quot;&quot;Exit the program with the specified error code.&quot;&quot;&quot;
    sys.exit(error_code)

# Function to print the command line arguments passed to the script
def argv(*args, **kwargs):
    &quot;&quot;&quot;Return a list of command line arguments.&quot;&quot;&quot;
    return sys.argv

# Function to get the platform name
def platform():
    &quot;&quot;&quot;Return the platform name.&quot;&quot;&quot;
    import platform
    return platform.platform()

# Function to get the system&#x27;s display name
def node():
    &quot;&quot;&quot;Return the system&#x27;s display name.&quot;&quot;&quot;
    import platform
    return platform.node()

# Function to get the current Python version and compiler information
def version():
    &quot;&quot;&quot;Return a string containing the Python version and compilation information.&quot;&quot;&quot;
    return sys.version

# Function to get the maximum size of an integer on the system
def maxsize:
    &quot;&quot;&quot;Return the maximum size of an integer on the system.&quot;&quot;&quot;
    return sys.maxsize

# Function to get the current system&#x27;s architecture
def maxsize():
    &quot;&quot;&quot;Return the maximum size of an integer on the system.&quot;&quot;&quot;
    return sys.maxsize

# Function to set the Python interpreter for the current process
def exec_module(module):
    &quot;&quot;&quot;Set the Python interpreter for the current process.&quot;&quot;&quot;
    # Use importlib&#x27;s _execute_code object, which runs a module as Python code.
    import importlib._execute_code
    if not isinstance(module, str):
        raise TypeError(
            f&quot;Expected str, got {type(module).__name__}&quot;
        )
    importlib._execute_code(module)
```

**Module Constants**

Here&#x27;s a list of constants available in the `sys` module:

```python
# Constant for successful exit status (0)
EX IT Status = 0

# Constant for unsuccessful exit status (non-zero)
EXIT Status = 1

# Module constants
__file__ = &quot;&quot;

__loader__ = None

__name__ = &quot;sys&quot;

__package__ = None
```

Note: These are some of the most commonly used functions and variables in the `sys` module. This is not an exhaustive list, as the `sys` module provides many more functions and constants.
</code></pre>

<h3 id='standard_library_documents/Python Runtime Services/inspect - Inspect live objects.md'>inspect - Inspect live objects.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># inspect — Inspect live objects

**Module: `inspect`**
=====================================

The `inspect` module provides several useful functions to help get information about live objects, such as modules, classes, instances, and frames.

### Module Inspection

#### 1. `inspect.getmodule()`

Returns the module that contains the specified object.

```python
import inspect

def main():
    # Get the current frame
    current_frame = inspect.currentframe()

    # Get the module from the current frame
    current_module = inspect.getmodule(current_frame)

    print(&quot;Current Module:&quot;, current_module.__name__)

if __name__ == &quot;__main__&quot;:
    main()
```

#### 2. `inspect.getmro()`

Returns the method resolution order for a specified object.

```python
import inspect

class ParentClass:
    pass

class ChildClass(ParentClass):
    pass

def main():
    # Get the class hierarchy
    parent_class = ParentClass
    child_class = ChildClass
    mro = inspect.getmro(parent_class)

    print(&quot;Method Resolution Order:&quot;, mro)

if __name__ == &quot;__main__&quot;:
    main()
```

#### 3. `inspect.getmembers()`

Returns a list of tuples containing the names and values of specified object&#x27;s members.

```python
import inspect

def main():
    # Create an example class
    class ExampleClass:
        def method1(self):
            pass

        def method2(self, param):
            pass

    # Get all methods and attributes
    obj = ExampleClass()
    members = inspect.getmembers(obj)

    print(&quot;Members:&quot;)
    for name, value in members:
        print(f&quot;- {name}: {value.__self__}&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

#### 4. `inspect.getattr()`

Returns the attribute with the specified name.

```python
import inspect

def main():
    # Create an example class
    class ExampleClass:
        def method1(self):
            pass

        def method2(self, param):
            pass

    obj = ExampleClass()
    attr_name = &quot;method1&quot;

    attr_value = inspect.getattr(obj, attr_name)

    print(f&quot;Attribute &#x27;{attr_name}&#x27;: {attr_value}&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

#### 5. `inspect.getsource()`

Returns the source code for a specified object.

```python
import inspect

def main():
    # Create an example function
    def example_function():
        pass

    func_name = &quot;example_function&quot;
    source_code = inspect.getsource(func_name)

    print(f&quot;Source Code for &#x27;{func_name}&#x27;:\n{source_code}&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

### Class Inspection

#### 1. `inspect.getmembers()`

Returns a list of tuples containing the names and values of specified object&#x27;s attributes.

```python
import inspect

def main():
    # Create an example class
    class ExampleClass:
        def method1(self):
            pass

        def method2(self, param):
            pass

    obj = ExampleClass()
    members = inspect.getmembers(obj)

    print(&quot;Members:&quot;)
    for name, value in members:
        print(f&quot;- {name}: {value.__self__}&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

#### 2. `inspect.getclass()`

Returns the class of a specified object.

```python
import inspect

def main():
    # Create an example instance
    obj = &quot;hello&quot;

    class_name = type(obj).__name__

    print(f&quot;Class Name: {class_name}&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

### Frame Inspection

#### 1. `inspect.currentframe()`

Returns the current frame.

```python
import inspect

def main():
    # Get the current frame
    current_frame = inspect.currentframe()

    print(&quot;Current Frame:&quot;, current_frame)

if __name__ == &quot;__main__&quot;:
    main()
```

#### 2. `inspect.getouterframes()`

Returns a list of frames containing information about the caller&#x27;s stack.

```python
import inspect

def outer_function():
    inner_function()

def main():
    # Call the outer function
    outer_function()

if __name__ == &quot;__main__&quot;:
    main()
```

#### 3. `inspect.getframeinfo()`

Returns a frame object with additional information about a specified frame.

```python
import inspect

def main():
    # Create an example function
    def example_function():
        pass

    func_frame = inspect.getframeinfo(example_function)

    print(f&quot;Function Name: {func_frame.function}&quot;)
    print(f&quot;File Name: {func_frame.filename}&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

### Other Functions

#### 1. `inspect.isclass()`

Checks if the specified object is a class.

```python
import inspect

def main():
    # Create an example class
    class ExampleClass:
        pass

    obj = ExampleClass()

    is_class = inspect.isclass(obj)

    print(f&quot;Is Class: {is_class}&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

#### 2. `inspect.isfunction()`

Checks if the specified object is a function.

```python
import inspect

def main():
    # Create an example function
    def example_function():
        pass

    obj = example_function()

    is_func = inspect.isfunction(obj)

    print(f&quot;Is Function: {is_func}&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

#### 3. `inspect.ismethod()`

Checks if the specified object is a method.

```python
import inspect

def main():
    # Create an example class
    class ExampleClass:
        def method(self):
            pass

    obj = ExampleClass()

    is_method = inspect.ismethod(obj)

    print(f&quot;Is Method: {is_method}&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

#### 4. `inspect.ismodule()`

Checks if the specified object is a module.

```python
import inspect

def main():
    # Create an example module
    import example_module

    obj = example_module

    is_module = inspect.ismodule(obj)

    print(f&quot;Is Module: {is_module}&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

#### 5. `inspect.gettrace()`

Returns the frame of the caller.

```python
import inspect

def main():
    # Create an example function
    def example_function():
        pass

    # Get the trace frame
    trace_frame = inspect.gettrace()

    print(f&quot;Trace Frame: {trace_frame}&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

These are some of the most commonly used functions in the `inspect` module. The specific function you need may depend on your use case, but this should provide a good starting point for exploring what the `inspect` module has to offer.
</code></pre>

<h3 id='standard_library_documents/Python Runtime Services/traceback - Print or retrieve a stack traceback.md'>traceback - Print or retrieve a stack traceback.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># traceback — Print or retrieve a stack traceback

**Traceback Module**
====================
```python
import traceback
from traceback import format_exception

# Create a traceback object
tb = traceback.format_exception(*sys.exc_info())

# Print the traceback as a string
print(tb)

# Format the traceback with a custom style
formatted_tb = format_exception(*sys.exc_info(), limit=40)
print(formatted_tb)

# Extract the type, value, and traceback of an exception
exception_type, exception_value, tb = sys.exc_info()
print(f&quot;Exception Type: {exception_type.__name__}&quot;)
print(f&quot;Exception Value: {exception_value}&quot;)
print(f&quot;Traceback: {tb}&quot;)

# Print a formatted traceback with section headers
formatted_tb = traceback.format_exc(limit=20)
print(formatted_tb)

# Use the traceback module to format a custom exception message
class CustomError(Exception):
    def __init__(self, message):
        self.message = message

try:
    # Code that may raise an exception
    x = 1 / 0
except CustomError as e:
    print(traceback.format_exc(limit=40))  # Print the formatted traceback with custom error message
```

**Explanation:**

*   The `traceback` module provides functions to extract, format, and print stack traces.
*   The `format_exception` function returns a list of strings representing the formatted exception information. It takes three arguments: `exc_type`, `exc_value`, and `exc_traceback`.
*   The `format_exc` function returns a string representing the formatted traceback. It takes one argument: `limit`, which specifies the maximum number of frames to include in the traceback.
*   The `traceback.format_tb` function returns a list of strings representing the formatted traceback information for an exception object.
*   You can use the `traceback.format_exc` function to format the current exception, and the `traceback.format_exception` function to format any type of exception.

**Use Cases:**

*   Handling exceptions in your code and printing or logging the stack trace.
*   Displaying informative error messages to users with the help of the `traceback` module.
*   Using a custom exception class and formatting its traceback for display.
</code></pre>

<h3 id='standard_library_documents/Python Runtime Services/__main__ - Top-level script environment.md'>__main__ - Top-level script environment.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># __main__ — Top-level script environment

Here&#x27;s an example of how you can interact with the `__main__` module:
```python
# This is the main entry point for the script.

import __main__

# Accessing the __main__ module is not recommended, as it can lead to unexpected behavior.
# However, we can use it to access the command-line arguments passed to the script.
def main():
    # Getting the command-line arguments using sys.argv
    import sys
    print(sys.argv)

    # Accessing the __main__ module and getting its attributes (not recommended)
    try:
        # Accessing the __name__ attribute of the __main__ module
        print(__main__.__name__)
        # Accessing the builtins dictionary from the __main__ module
        import __builtin__
        print(__builtin__.builtins)
    except AttributeError:
        print(&quot;The __main__ module does not exist.&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

However, it&#x27;s worth noting that `__main__` is a reserved name in Python and should not be used as the name of any variable or module. If you try to use `__main__` as a variable or module name, Python will throw an error.

Here are some things you can do with the standard library in python when provided with `__main__`:

*   **Command-line arguments**: Use the `sys.argv` list to access command-line arguments passed to the script.
*   **Accessing modules and objects**: You can use the `globals()` or `locals()` functions to access variables, modules, and objects defined in the current scope.

Example code for accessing modules:
```python
import importlib

def load_module(module_name):
    # Try to load the module using importlib
    try:
        return importlib.import_module(module_name)
    except ImportError as e:
        print(f&quot;Failed to load module {module_name}: {e}&quot;)
        return None

# Load a module and access its attributes
if __name__ == &quot;__main__&quot;:
    # Load the math module
    math = load_module(&quot;math&quot;)

    # Access the sqrt function from the math module
    import math
    print(math.sqrt(4))
```

Example code for accessing modules using `globals()`:
```python
def access_global_variables():
    # Get a dictionary of global variables
    global_vars = globals()

    # Print the values of some global variables
    print(global_vars[&quot;__name__&quot;])
    print(global_vars[&quot;sys&quot;])
    print(global_vars[&quot;math&quot;])

if __name__ == &quot;__main__&quot;:
    access_global_variables()
```

Example code for accessing modules using `locals()`:
```python
def access_local_variables():
    # Get a dictionary of local variables
    local_vars = locals()

    # Print the values of some local variables
    print(local_vars[&quot;x&quot;])
    print(local_vars[&quot;y&quot;])

if __name__ == &quot;__main__&quot;:
    x = 5
    y = 10
    access_local_variables()
```

**Modules:** There are numerous modules available in Python, including:

*   **`math`**: Provides mathematical functions and constants.
*   **`sys`**: Provides functions and variables used to interact with the operating system.
*   **`os`**: Provides functions for interacting with the operating system.
*   **`re`**: Provides regular expression matching operations.
*   **`time`**: Provides various time-related functions.

Here&#x27;s an example of how you can use these modules:
```python
import math
import sys
import os
import re
import time

# Using the math module
print(math.pi)
print(math.sqrt(4))

# Using the sys module
print(sys.argv)
print(sys.version)

# Using the os module
os.system(&quot;ls -l&quot;)
os.mkdir(&quot;new_directory&quot;)

# Using the re module
pattern = r&quot;\d+&quot;
match = re.search(pattern, &quot;Hello123World!&quot;)
if match:
    print(match.group())
else:
    print(&quot;No match found.&quot;)

# Using the time module
print(time.time())
```

These are just a few examples of how you can interact with the `__main__` module and use modules from the standard library in Python.
</code></pre>

<h3 id='standard_library_documents/Python Runtime Services/warnings - Warning control.md'>warnings - Warning control.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># warnings — Warning control

Here&#x27;s an example of how you can use the warnings module in Python:

```python
# Importing the warnings module
import warnings

# Issues: These are issues that are considered to be errors or need special attention.

# Filter warnings: You can filter out specific types of warnings based on their category.
with warnings.catch_warnings():
    # Ignore specific categories of warnings
    warnings.filterwarnings(&quot;ignore&quot;, category=DeprecationWarning)
    warnings.filterwarnings(&quot;ignore&quot;, category=UserWarning)

    # Now, any new warnings will be raised
    import numpy as np

# New warnings are now being raised
try:
    import older_numpy  # This imports an older version of NumPy that has been deprecated.
except ImportError:
    print(&quot;Error: Older version of NumPy not found.&quot;)

# Category and message for a warning to be displayed:
warnings.warn(&quot;You&#x27;re running an old version of Python.&quot;, UserWarning)

# Suppressing warnings: You can also suppress specific warnings by passing their category directly into the warn function.

with warnings.catch_warnings():
    # Suppress specific warnings
    warnings.filterwarnings(&quot;error&quot;, category=DeprecationWarning)
    warnings.filterwarnings(&quot;ignore&quot;, category=FutureWarning)

    # Now, any new warnings will be suppressed and raise an error
    import os

# Suppressing warnings on the fly:
def do_something():
    with warnings.catch_warnings(record=True):
        # Warning that will not be raised
        1 / 0
        
        # A warning that will be raised
        import numpy as np

# Suppressing warnings for a function or block of code:
try:
    import older_numpy  # This imports an older version of NumPy that has been deprecated.
except ImportError:
    with warnings.catch_warnings():
        # Ignore specific categories of warnings
        warnings.filterwarnings(&quot;ignore&quot;, category=DeprecationWarning)
        
        # Now, any new warnings will be raised
        import numpy as np

# How to handle different warning types using a context manager:

with warnings.catch_warnings():
    # Suppress specific warnings
    warnings.filterwarnings(&quot;error&quot;, category=DeprecationWarning)

    try:
        # This is where you want to put your code.
        with warnings.catch_warnings(record=True):
            import numpy as np
    except Warning as w:
        print(w.message)
```

Here are some common usage scenarios for the warnings module:

1.  **Ignoring specific categories of warnings:** 

    ```python
warnings.filterwarnings(&quot;ignore&quot;, category=DeprecationWarning)
warnings.filterwarnings(&quot;ignore&quot;, category=UserWarning)
```

2.  **Suppressing warnings on a per-call basis:**

    ```python
with warnings.catch_warnings():
    warnings.simplefilter(&#x27;error&#x27;)
    with warnings.catch_warnings(record=True):
        import numpy as np
```

3.  **Ignoring all warnings in a function or block of code:**

    ```python
try:
    with warnings.catch_warnings():
        warnings.filterwarnings(&quot;ignore&quot;)
        import numpy as np
except Warning:
    print(&quot;Warning message&quot;)
```

4.  **Suppressing specific categories of warnings for an entire module:**

    You can use the `warnings.simplefilter()` function to suppress specific warning types in your own code, like so:

    ```python
import warnings

warnings.simplefilter(&#x27;ignore&#x27;, DeprecationWarning)

# Now you&#x27;re running on a modified version of Python with all deprecated features disabled.
```

5.  **Suppressing warnings for an entire file or module:**

    You can also use `warnings.catch_warnings()` to suppress specific warning types in your own code, like so:

    ```python
import warnings

try:
    import older_numpy  # This imports an older version of NumPy that has been deprecated.
except ImportError:
    with warnings.catch_warnings():
        warnings.filterwarnings(&quot;ignore&quot;, category=DeprecationWarning)
        
        import numpy as np
```

6.  **Suppressing warnings in a specific block of code:**

    You can also use `try`/`except` blocks to suppress specific warning types, like so:

    ```python
try:
    with warnings.catch_warnings():
        warnings.filterwarnings(&quot;ignore&quot;, category=FutureWarning)
        import os
except Warning as w:
    print(w.message)
```

7.  **Suppressing all warnings:**

    You can use the `warnings.simplefilter()` function to suppress specific warning types globally, like so:

    ```python
import warnings

warnings.simplefilter(&#x27;ignore&#x27;, DeprecationWarning)

# Now you&#x27;re running on a modified version of Python with all deprecated features disabled.
```
</code></pre>

<h3 id='standard_library_documents/Python Runtime Services/dataclasses - Data Classes.md'>dataclasses - Data Classes.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># dataclasses — Data Classes

**Data Classes**
================

The `dataclasses` module provides support for creating classes that mainly contain data and have minimal runtime overhead.

### Example Use Case:

Let&#x27;s create a simple `Person` class using data classes:
```python
from dataclasses import dataclass

# Define a data class with fields
@dataclass
class Person:
    &quot;&quot;&quot;A simple data class representing a person&quot;&quot;&quot;
    name: str  # Name of the person
    age: int   # Age of the person
    city: str  # City where the person lives

# Create an instance of the Person class
person = Person(
    name=&quot;John Doe&quot;,
    age=30,
    city=&quot;New York&quot;
)

# Print the data stored in the class
print(person)  # Output: Person(name=&#x27;John Doe&#x27;, age=30, city=&#x27;New York&#x27;)

# Accessing fields:
print(person.name)  # Output: John Doe
print(person.age)   # Output: 30
print(person.city)  # Output: New York

# Update values:
person.name = &quot;Jane Doe&quot;
print(person)  # Output: Person(name=&#x27;Jane Doe&#x27;, age=30, city=&#x27;New York&#x27;)

# You can also add a constructor using the __post_init__ method
@dataclass(post_init=True)
class Person2:
    &quot;&quot;&quot;A data class with a constructor&quot;&quot;&quot;
    name: str
    age: int

    def __post_init__(self):
        self.city = f&quot;{self.name}ville&quot;

person2 = Person2(
    name=&quot;John Doe&quot;,
    age=30
)

print(person2)  # Output: Person2(name=&#x27;John Doe&#x27;, age=30)
```
### Additional Methods:

Data classes also support additional methods such as `__str__` and `__repr__`. These methods allow you to customize how the data class is represented when it&#x27;s converted into a string.

```python
from dataclasses import dataclass

@dataclass
class Person:
    &quot;&quot;&quot;A simple data class representing a person&quot;&quot;&quot;
    name: str  # Name of the person
    age: int   # Age of the person
    city: str  # City where the person lives

# Define custom __str__ and __repr__ methods
    @staticmethod
    def _format_name(name):
        return f&quot;{name[0].upper()} {name.lower()[1:]}&quot;

    def __post_init__(self):
        self.city = f&quot;{self._format_name(self.name)}ville&quot;
        super().__post_init__()

# Create an instance of the Person class
person = Person(
    name=&quot;John Doe&quot;,
    age=30,
    city=&quot;New York&quot;
)

# Print the data stored in the class using custom __str__ and __repr__ methods
print(person)  # Output: Person(name=&#x27;JOHN doe&#x27;, age=30, city=&#x27;NYC&#x27;)
```

### Class Attributes:

Data classes can also support class attributes. These are useful when you need to store common values that apply to all instances of the class.

```python
from dataclasses import dataclass

@dataclass
class Person:
    &quot;&quot;&quot;A simple data class representing a person&quot;&quot;&quot;
    name: str  # Name of the person
    age: int   # Age of the person
    city: str  # City where the person lives

# Define class attributes
    class_name = &quot;Human&quot;
    species = &quot;Homo sapiens&quot;

# Create an instance of the Person class
person1 = Person(
    name=&quot;John Doe&quot;,
    age=30,
    city=&quot;New York&quot;
)

# Access class attributes:
print(Person.class_name)  # Output: Human
print(person1.species)   # Output: Homo sapiens

# You can also use class attributes in methods
class PersonMethods:
    def __init__(self):
        self._species = Person.species

    @property
    def species(self):
        return self._species

person2 = PersonMethods()

print(person2.species)  # Output: Homo sapiens
```

### Enumerations:

Data classes can also support enumerations. These are useful when you need to represent a fixed set of values.

```python
from dataclasses import dataclass, field
from enum import Enum

@dataclass
class Color(Enum):
    &quot;&quot;&quot;An enumeration representing different colors&quot;&quot;&quot;
    RED = &quot;red&quot;
    GREEN = &quot;green&quot;
    BLUE = &quot;blue&quot;

# Create an instance of the Color class
color = Color.RED

# Accessing values:
print(color.value)  # Output: red

# You can also use enum members as attributes
class ShapeDataclass:
    def __init__(self):
        self._shape = field(default=Color.GREEN)

    @property
    def shape(self):
        return self._shape

shape_dataclass = ShapeDataclass()

print(shape_dataclass.shape)  # Output: Color.GREEN
```

### Type Hints:

Finally, data classes support type hints. These are useful when you need to specify the types of attributes in your class.

```python
from dataclasses import dataclass

@dataclass
class Person:
    &quot;&quot;&quot;A simple data class representing a person&quot;&quot;&quot;
    name: str  # Name of the person (string)
    age: int   # Age of the person (integer)

# Create an instance of the Person class with type hints
person = Person(
    name=&quot;John Doe&quot;,  # string
    age=30           # integer
)

# Accessing attributes:
print(person.name)  # Output: John Doe (string)
print(person.age)   # Output: 30 (integer)

# You can also use type aliases
from dataclasses import dataclass

@dataclass
class Person:
    &quot;&quot;&quot;A simple data class representing a person&quot;&quot;&quot;
    name: str  # Name of the person (string)
    age: int   # Age of the person (integer)

    @staticmethod
    def get_age(age: int) -&gt; int:
        return age  # integer

person = Person(
    name=&quot;John Doe&quot;,  # string
    age=30           # integer
)

# Accessing attributes using type alias:
print(Person.get_age(person.age))  # Output: 30 (integer)
```
</code></pre>

<h3 id='standard_library_documents/Python Runtime Services/contextlib - Utilities for with-statement contexts.md'>contextlib - Utilities for with-statement contexts.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># contextlib — Utilities for with-statement contexts

Here&#x27;s an example of how you can use the `contextlib` module from Python&#x27;s standard library.

```python
import contextlib

# Define a function that uses contextlib to create a context manager
@contextlib.contextmanager
def my_context_manager():
    &quot;&quot;&quot;
    A simple context manager that prints a message before entering and after exiting the context.
    &quot;&quot;&quot;
    print(&quot;Entering the context&quot;)
    try:
        # Yield control to the caller within this block
        yield
    finally:
        print(&quot;Exiting the context&quot;)

# Example usage of the context manager
with my_context_manager():
    # Code that should be executed within the context
    print(&quot;Inside the context&quot;)

# Another example using the contextlib.suppress function
@contextlib.contextmanager
def suppress_warnings():
    &quot;&quot;&quot;
    A context manager that suppresses warnings during execution.
    &quot;&quot;&quot;
    import warnings
    warnings.simplefilter(&#x27;ignore&#x27;)
    try:
        # Yield control to the caller within this block
        yield
    finally:
        warnings.simplefilter(*warnings.defaultFilters())

with suppress_warnings():
    # Code that may produce warnings
    raise ValueError(&quot;This should not be a warning&quot;)
```

However, you can also create your own custom context manager using `contextlib.contextmanager`.

```python
import contextlib

@contextlib.contextmanager
def my_custom_context_manager(open_file):
    &quot;&quot;&quot;
    A custom context manager that opens a file and closes it when exiting the context.
    &quot;&quot;&quot;
    print(&quot;Opening the file&quot;)
    with open_file as f:
        # Yield control to the caller within this block
        yield
    print(&quot;Closing the file&quot;)

# Example usage of the custom context manager
with my_custom_context_manager(open(&#x27;example.txt&#x27;, &#x27;r&#x27;)) as f:
    # Code that should be executed within the context
    data = f.read()
```

Here&#x27;s a more complex example that combines multiple `contextlib` features.

```python
import contextlib
from contextlib import suppress, redirect_stdout

@contextlib.contextmanager
def with_output redirected():
    &quot;&quot;&quot;
    A context manager that redirects stdout during execution.
    &quot;&quot;&quot;
    with suppress(IOError):
        with open(&#x27;/dev/null&#x27;, &#x27;w&#x27;) as f:
            # Yield control to the caller within this block
            yield from redirect_stdout(f)

# Example usage of the context manager
with with_output_redirected():
    # Code that may produce output
    import math
    print(math.sqrt(-1))
```

Here&#x27;s a more complex example that uses `contextlib.suppress` and `redirect_stdout` to capture exceptions.

```python
import contextlib

@contextlib.contextmanager
def suppress_exceptions_and_capture_output():
    &quot;&quot;&quot;
    A context manager that captures exceptions and redirects stdout during execution.
    &quot;&quot;&quot;
    with suppress(Exception):
        with redirect_stdout(sys.stdout):
            # Yield control to the caller within this block
            yield

# Example usage of the context manager
with suppress_exceptions_and_capture_output():
    # Code that may raise an exception
    import math
    print(math.sqrt(-1))
```
</code></pre>

<h3 id='standard_library_documents/Python Runtime Services/sysconfig - Provide access to Python s configuration information.md'>sysconfig - Provide access to Python s configuration information.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># sysconfig - Provide access to Python’s configuration information

Here&#x27;s an example of how you can use the `sysconfig` module from Python&#x27;s standard library:

```python
# Import the sysconfig module
import sysconfig

# Get the compiler information
print(&quot;Compiler Information:&quot;)
for key, value in sysconfig.get_info():
    print(f&quot;{key}: {value}&quot;)

# Get the compiler flags
print(&quot;\nCompiler Flags:&quot;)
flags = sysconfig.get_info(&quot;CFLAGS&quot;)
if flags:
    print(flags)
else:
    print(&quot;No CFLAGS found&quot;)

# Get the library information
print(&quot;\nLibrary Information:&quot;)
for key, value in sysconfig.get_info():
    if key.startswith(&quot;LIB&quot;):
        print(f&quot;{key}: {value}&quot;)

# Get the compiler options
print(&quot;\nCompiler Options:&quot;)
options = sysconfig.get_info(&quot;CCOptions&quot;)
if options:
    print(options)
else:
    print(&quot;No CCOptions found&quot;)

# Print the build configuration variables
print(&quot;\nBuild Configuration Variables:&quot;)
for key, value in sysconfig.get_info():
    if key.startswith(&quot;_&quot;) and not key.startswith(&quot;_&quot; + sysconfig.PYTHON_BUILD):
        print(f&quot;{key}: {value}&quot;)
```

This code will output:

```python
Compiler Information:
CFLAGS: -m64 -O2 -fPIC -Wall -Wextra -pedantic 
CCOptions: -mmarch=core2 
LDFLAGS: -shared -fPIC 
CXXFLAGS: -std=c++11 -g 

Build Configuration Variables:
OPTIMIZATION_LEVEL: 2
PYTHON_API_VERSION: 0x00000312

```

The `sysconfig` module provides access to Python’s configuration information. It contains functions to get various pieces of configuration data.

- `get_info()`: Returns a dictionary containing key-value pairs of configuration variables.
- `_get_info()`: Similar to `get_info()` but excludes private variables that start with an underscore and are not related to the build process.
- `PYDEBUG`: A boolean indicating whether the Python interpreter is being run in debug mode.

Note: The actual output may vary depending on the system configuration.
</code></pre>

<h3 id='standard_library_documents/Python Runtime Services/atexit - Exit handlers.md'>atexit - Exit handlers.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># atexit — Exit handlers

**atexit Module Code Generator**
=====================================

The `atexit` module provides a way to register functions to be executed when the program exits.

### Example Use Cases

*   Registering functions to release system resources
*   Performing cleanup operations before exiting the program
*   Executing tasks that should only run once, such as sending a shutdown notification

### Code Generation

```python
import atexit
import os
import sys

def register_exit_handler(func):
    &quot;&quot;&quot;
    Registers a function to be executed when the program exits.
    
    Args:
        func (function): The function to register for exit execution.
    &quot;&quot;&quot;
    # Use atexit.register to register the function for exit execution
    atexit.register(func)

def print_exit_message(message):
    &quot;&quot;&quot;
    Prints a message before exiting the program.
    
    Args:
        message (str): The message to print.
    &quot;&quot;&quot;
    print(f&quot;Exiting program: {message}&quot;)

# Register the print_exit_message function to be executed when the program exits
register_exit_handler(print_exit_message)
print_exit_message(&quot;Exiting normally&quot;)

# Register a function that releases system resources before exiting
def release_resources():
    &quot;&quot;&quot;
    Releases system resources before exiting.
    &quot;&quot;&quot;
    # Release file descriptor 0 (stdin) on Unix-like systems
    if os.name == &quot;posix&quot;:
        import resource
        resource.release(0)

register_exit_handler(release_resources)
sys.exit()  # Simulate a program exit

# Register the release_resources function to be executed when the program exits via sys.exit()
import signal
def handler(signum, frame):
    &quot;&quot;&quot;
    Signals that the release_resources function should be called.
    
    Args:
        signum (int): The signal number.
        frame (frame): The current frame.
    &quot;&quot;&quot;
    signal.signal(signal.SIGTERM, signal.SIG_DFL)
    release_resources()

signal.signal(signal.SIGTERM, handler)
sys.exit()  # Simulate a program exit
```

### Explanation

The `atexit` module allows you to register functions to be executed when the program exits. In this example:

*   We define two functions: `print_exit_message` and `release_resources`. The first function prints a message before exiting, while the second function releases system resources before exiting.
*   We use the `register_exit_handler` function to register these functions for exit execution using `atexit.register`.
*   To simulate a program exit without actually running the registered functions, we use `sys.exit()`.
*   When the program exits via `sys.exit()`, the registered functions are executed.
</code></pre>

<h3 id='standard_library_documents/Python Runtime Services/site - Site-specific configuration hook.md'>site - Site-specific configuration hook.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># site — Site-specific configuration hook

**Site-Specific Configuration Hook: `site` Module**
=====================================================

The `site` module is a site-specific configuration hook that provides access to the current site&#x27;s metadata.

**Module Description**
--------------------

The `site` module allows you to register and retrieve information about the current site, including its name, title, and URL. It also provides hooks for customizing the behavior of the module.

**Example Code**
-------------

```python
import site

# Register a new site with its metadata
def register_site(name, url, title):
    &quot;&quot;&quot;Register a new site with its metadata&quot;&quot;&quot;
    # Create a new Site object
    site_obj = site.Site(name, url, title)
    # Register the site object with the current site&#x27;s registry
    site.register(site_obj)

# Retrieve information about the current site
def get_site_info():
    &quot;&quot;&quot;Retrieve information about the current site&quot;&quot;&quot;
    # Get the current site object from the registry
    current_site = site.get_currentSite()
    # Return a dictionary containing the site&#x27;s metadata
    return {
        &#x27;name&#x27;: current_site.name,
        &#x27;url&#x27;: current_site.url,
        &#x27;title&#x27;: current_site.title
    }

# Define a custom hook for the `site` module
def custom_hook(site):
    &quot;&quot;&quot;Customize the behavior of the `site` module&quot;&quot;&quot;
    # Print a message indicating that the site has been loaded
    print(&quot;Site loaded:&quot;, site.name)

# Register the custom hook with the current site&#x27;s registry
register_site(&#x27;My Site&#x27;, &#x27;https://example.com&#x27;, &#x27;My Awesome Site&#x27;)
site.register(custom_hook, &#x27;&#x27;)

# Retrieve information about the current site and print it to the console
print(get_site_info())

# Unregister the custom hook from the current site&#x27;s registry
site.unregister_hook(custom_hook)
```

**Usage**
-----

To use the `site` module, you can import it and access its functions and variables.

*   To register a new site with its metadata, call the `register_site()` function and pass in the site&#x27;s name, URL, and title as arguments.
*   To retrieve information about the current site, call the `get_site_info()` function and access the returned dictionary containing the site&#x27;s metadata.
*   To customize the behavior of the `site` module, define a custom hook function that takes a `Site` object as an argument and register it with the current site&#x27;s registry using the `register_hook()` function.

**Notes**
-----

The `site` module is used to provide access to information about the current site in Python-based applications. It allows you to customize its behavior by registering custom hooks, which can be useful for integrating third-party libraries or frameworks into your application.
</code></pre>
<h2 id='Networking and Interprocess Communication'>Networking and Interprocess Communication</h2><ul><li><a href='#standard_library_documents/Networking and Interprocess Communication/selectors - High-level I O multiplexing.md'>selectors - High-level I O multiplexing.md</a></li><li><a href='#standard_library_documents/Networking and Interprocess Communication/select - Waiting for I O completion.md'>select - Waiting for I O completion.md</a></li><li><a href='#standard_library_documents/Networking and Interprocess Communication/socket - Low-level networking interface.md'>socket - Low-level networking interface.md</a></li><li><a href='#standard_library_documents/Networking and Interprocess Communication/signal - Set handlers for asynchronous events.md'>signal - Set handlers for asynchronous events.md</a></li><li><a href='#standard_library_documents/Networking and Interprocess Communication/ssl - TLS SSL wrapper for socket objects.md'>ssl - TLS SSL wrapper for socket objects.md</a></li><li><a href='#standard_library_documents/Networking and Interprocess Communication/mmap - Memory-mapped file support.md'>mmap - Memory-mapped file support.md</a></li><li><a href='#standard_library_documents/Networking and Interprocess Communication/asyncio - Asynchronous I O.md'>asyncio - Asynchronous I O.md</a></li></ul>
<h3 id='standard_library_documents/Networking and Interprocess Communication/selectors - High-level I O multiplexing.md'>selectors - High-level I O multiplexing.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># selectors - High-level I/O multiplexing

**Selectors in Python**
=====================================

The `select` module in Python provides an interface to the Unix file descriptor selector, allowing you to wait for multiple file descriptors to become ready.

### Importing the Module

```python
import select
```

### Creating a Selector Object

To use the `select` module, you need to create a selector object, passing in three lists of file descriptors:

*   `rlist`: A list of file descriptors that can be read from.
*   `wlist`: A list of file descriptors that can be written to.
*   `xlist`: A list of file descriptors that have exceptional events (e.g., errors).

```python
import socket

# Create a socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# List of file descriptors for reading, writing, and exceptions
rlist = [sock]
wlist = []
xlist = []

# Create the selector object
s = select.select(rlist, wlist, xlist)
```

### Using the Selector Object

The `select` function takes three lists of file descriptors as input and returns a tuple containing:

*   A list of readable file descriptors.
*   A list of writable file descriptors.
*   A list of file descriptors with exceptional events.

You can use this information to perform I/O operations on the corresponding file descriptors.

```python
# Iterate over the selectors
for r, w, x in s:
    # Handle read operation
    data = sock.recv(1024)
    if data:
        print(&quot;Received:&quot;, data.decode())
    
    # Handle write operation
    sock.sendall(b&quot;Hello, world!&quot;)
```

### Example Use Case: Web Server

Here&#x27;s an example of using the `select` module in a simple web server:

```python
import socket
import select

# Create a socket and bind it to a port
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.bind((&quot;localhost&quot;, 8080))
sock.listen(5)

# List of file descriptors for reading, writing, and exceptions
rlist = [sock]
wlist = []
xlist = []

while True:
    # Wait for I/O operations to become ready
    s = select.select(rlist, wlist, xlist)
    
    # Handle read operation
    for r in s[0]:
        conn, addr = r.accept()
        print(&quot;New connection:&quot;, addr)
        
        # Add the new connection to the lists of file descriptors
        rlist.append(conn)
        wlist.append(None)
        xlist.append(None)

    # Handle write operations
    for w in s[1]:
        if w is not None:
            data = sock.recv(1024)
            if data:
                print(&quot;Sending:&quot;, data.decode())
```

This example demonstrates how the `select` module can be used to create a simple web server that handles multiple connections concurrently.

### Error Handling

When using the `select` module, you should always handle errors properly. Here&#x27;s an example of how to do this:

```python
try:
    # Wait for I/O operations to become ready
    s = select.select(rlist, wlist, xlist)
except KeyboardInterrupt:
    print(&quot;Exiting...&quot;)
except socket.error as e:
    print(&quot;Socket error:&quot;, e)
```

This code catches `KeyboardInterrupt` exceptions and `socket.error` exceptions, providing a better user experience.
</code></pre>

<h3 id='standard_library_documents/Networking and Interprocess Communication/select - Waiting for I O completion.md'>select - Waiting for I O completion.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># select - Waiting for I/O completion

**Select Method Example**
==========================

The `select` method is used to wait for I/O operations on multiple file descriptors.

### Code
```python
import os
import time

def main():
    # Create file descriptors
    fd1 = open(&#x27;file1.txt&#x27;, &#x27;w&#x27;)
    fd2 = open(&#x27;file2.txt&#x27;, &#x27;r&#x27;)
    fd3 = os.open(&#x27;file3.txt&#x27;, os.O_RDONLY)

    # Set timeout for select
    timeout = 5

    # Use select to wait for I/O operations
    readable, writable, errored = select(fd1.fileno(), fd2.fileno(), [], [], timeout)

    if readable:
        print(&quot;Readable: File is ready for reading&quot;)
        data = os.read(fd1.fileno(), 1024)
        print(f&quot;Received {len(data)} bytes from file1&quot;)

    if writable:
        print(&quot;Writable: File is ready for writing&quot;)
        data = b&#x27;Hello, World!&#x27;
        write_bytes = os.write(fd2.fileno(), data)
        print(f&quot;Wrote {write_bytes} bytes to file2&quot;)

    if errored:
        print(&quot;Errored: I/O operation has failed&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

### Explanation

*   We create three file descriptors `fd1`, `fd2`, and `fd3` for a write-only, read-only, and read-only files respectively.
*   We set a timeout of 5 seconds using the `select` function.
*   The first argument to `select` is a list of readable file descriptors. Since we are only interested in reading from `fd1`, we pass it as an empty list.
*   The second argument is a list of writable file descriptors, which is also empty since we are not writing to any files.
*   The third argument is a list of errored file descriptors, which will be populated if the I/O operation fails for any reason.
*   If there are readable or writable file descriptors, `select` will wait until the timeout is reached or an I/O operation completes.

### Example Use Cases

*   Wait for network responses
*   Wait for user input
*   Wait for keyboard events
*   Wait for disk I/O completion
</code></pre>

<h3 id='standard_library_documents/Networking and Interprocess Communication/socket - Low-level networking interface.md'>socket - Low-level networking interface.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># socket — Low-level networking interface

**Socket Module**
================

The `socket` module provides an interface to create network sockets, which can be used for communication between processes or threads.

### Creating a Socket

To create a socket, you need to import the `socket` module and use the `socket()`, `.AF_INET`, and `SOCK_STREAM` constants.

```python
import socket

# Create a new socket object
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

print(&quot;Socket created:&quot;, sock)
```

### Socket Methods

Here are some common methods used with sockets:

#### 1. Bind()

Bind the socket to a specific address and port.

```python
sock.bind((&quot;localhost&quot;, 8080))
print(&quot;Socket bound to localhost:8080&quot;)
```

#### 2. Listen()

Set up the socket to listen for incoming connections.

```python
sock.listen(5)
print(&quot;Socket listening on port 8080&quot;)
```

#### 3. Accept()

Accept an incoming connection and return a new socket object.

```python
conn, addr = sock.accept()
print(&quot;Connected by:&quot;, addr)
```

#### 4. Send() and Receive()

Send and receive data over the socket.

```python
sock.sendall(b&quot;Hello, client!&quot;)
data = conn.recv(1024)
print(data.decode())
```

### Socket Constants

Here are some common constants used with sockets:

#### 1. AF_INET (Address Family)

Used to specify the address family for the socket. For IPv4, use `AF_INET`. For IPv6, use `AF_INET6`.

```python
import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
```

#### 2. SOCK_STREAM (Socket Type)

Used to specify the type of socket. For TCP sockets, use `SOCK_STREAM`. For UDP sockets, use `SOCK_DGRAM`.

```python
import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
```

### Socket Exception Handling

Use try-except blocks to handle exceptions that may occur while using the socket.

```python
try:
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
except socket.error as e:
    print(&quot;Error creating socket:&quot;, e)
```

### Closing the Socket

Use `close()` to close the socket and free up system resources.

```python
sock.close()
print(&quot;Socket closed&quot;)
```

Example Use Case: Creating a Server-Client Communication System
-------------------------------------------------------------

Here&#x27;s an example of how you can create a simple server-client communication system using sockets:

**server.py**
```python
import socket

# Create a new socket object
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Bind the socket to a specific address and port
sock.bind((&quot;localhost&quot;, 8080))

# Listen for incoming connections
sock.listen(5)

print(&quot;Server listening on port 8080&quot;)

while True:
    conn, addr = sock.accept()
    print(&quot;Connected by:&quot;, addr)
    
    # Receive data from client
    data = conn.recv(1024)
    print(data.decode())
    
    # Send response back to client
    conn.sendall(b&quot;Hello, client!&quot;)
```

**client.py**
```python
import socket

# Create a new socket object
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Connect to the server
sock.connect((&quot;localhost&quot;, 8080))

print(&quot;Connected to server&quot;)

# Send data to server
sock.sendall(b&quot;Hello, server!&quot;)

# Receive response from server
data = sock.recv(1024)
print(data.decode())

# Close the socket
sock.close()
```

Run `server.py` in one terminal and `client.py` in another to see a simple client-server communication system in action.
</code></pre>

<h3 id='standard_library_documents/Networking and Interprocess Communication/signal - Set handlers for asynchronous events.md'>signal - Set handlers for asynchronous events.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># signal — Set handlers for asynchronous events

**Signal Module Code Generation**
=====================================

The `signal` module provides an interface for setting up signal handlers, which are functions that will be executed in response to specific system signals.

### Importing Signal Module
```python
import signal
```

### Setting Up a Default Handler for SIGINT (Interrupt)
--------------------------------------------------------

When the program receives a SIGINT signal, Python normally terminates. We can set a handler function to catch this signal and perform an alternative action.
```python
def default_handler(sig, frame):
    &quot;&quot;&quot;Default handler function for SIGINT signal.&quot;&quot;&quot;
    print(&quot;Caught SIGINT signal. Exiting...&quot;)
    # Add code here that you want to execute instead of exiting

# Register the default handler with Python&#x27;s signal module
signal.signal(signal.SIGINT, default_handler)
```

### Setting Up a Custom Handler for SIGALRM (Alarm)
----------------------------------------------------

We can also set a custom handler function to be executed when the alarm timer expires.
```python
import time

def alarm_handler(signum, frame):
    &quot;&quot;&quot;Custom handler function for SIGALRM signal.&quot;&quot;&quot;
    print(&quot;Alarm went off!&quot;)
    # Add code here that you want to execute when the alarm timer expires
    signal.alrm(0)  # Cancel the alarm

# Set up an alarm after 5 seconds
signal.alarm(5)

# Register the custom handler with Python&#x27;s signal module
signal.signal(signal.SIGALRM, alarm_handler)
```

### Deregistering a Signal Handler
---------------------------------

When we&#x27;re done with a signal handler, we should deregister it to prevent memory leaks.
```python
def clean_up():
    &quot;&quot;&quot;Deregister the default handler for SIGINT signal.&quot;&quot;&quot;
    signal.signal(signal.SIGINT, signal.SIG_DFL)  # Reset to default behavior

# Call the clean-up function when your program exits
import atexit
atexit.register(clean_up)
```

### Example Use Cases
---------------------

*   Handling system signals in a multithreaded application:
    ```python
import threading
import time

def signal_handler(sig, frame):
    print(&quot;Caught&quot;, sig.name, &quot;signal. Exiting...&quot;)

# Register the handler with Python&#x27;s signal module
signal.signal(signal.SIGINT, signal_handler)

def worker():
    while True:
        # Code that might raise a SIGINT signal
        time.sleep(1)

thread = threading.Thread(target=worker)
thread.start()
```

*   Implementing an alarm timer in a long-running task:
    ```python
import signal

def long_task():
    try:
        # Long-running task code here...
        while True:
            pass
    except KeyboardInterrupt:
        print(&quot;Caught SIGINT signal. Canceling...&quot;)
        return False

# Set up an alarm after 10 seconds
signal.alarm(10)

if not long_task():
    print(&quot;Task was interrupted by SIGINT signal&quot;)
```
</code></pre>

<h3 id='standard_library_documents/Networking and Interprocess Communication/ssl - TLS SSL wrapper for socket objects.md'>ssl - TLS SSL wrapper for socket objects.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># ssl - TLS/SSL wrapper for socket objects

**ssl Module Examples**
==========================

The `ssl` module provides a way to access SSL/TLS support in Python&#x27;s standard library.

### 1. Creating an SSL Context

An SSL context is used to specify the SSL/TLS parameters for a connection.
```python
import ssl

# Create a new SSL context
context = ssl.create_default_context()

# Get the default server certificate
print(context.check_hostname(&#x27;www.example.com&#x27;))  # Should print: True
print(context.verify_mode)  # Should print: SSL_VERIFIED

# Create an SSL connection
with ssl.wrap_socket(socket.socket(socket.AF_INET), server_side=True, cert_reqs=ssl.CERT_REQUIRED, ca_certs=None) as s:
    print(s.getpeercert())  # Should print the server&#x27;s certificate
```
### 2. Creating a Client-Side Connection

To create a client-side connection, you need to specify the SSL/TLS parameters and the server hostname.
```python
import ssl

# Create an SSL context with custom parameters
context = ssl.create_default_context()
context.check_hostname(&#x27;www.example.com&#x27;)  # Should print: True
context.verify_mode = ssl.CERT_REQUIRED
context.load_verify_locations(cafile=&#x27;path/to/ca.crt&#x27;)

# Create a client socket
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    # Wrap the socket with SSL/TLS
    with context.wrap_socket(s, server_hostname=&#x27;www.example.com&#x27;) as ssl_s:
        # Establish the connection
        ssl_s.connect((&#x27;www.example.com&#x27;, 443))
```
### 3. Creating a Server-Side Connection

To create a server-side connection, you need to specify the SSL/TLS parameters and handle incoming connections.
```python
import socket
import ssl

# Create a server socket
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    # Bind the socket to a address and port
    s.bind((&#x27;localhost&#x27;, 443))
    # Listen for incoming connections
    s.listen(1)

    while True:
        # Accept an incoming connection
        with ssl.wrap_socket(s.accept()[0], server_side=True, cert_reqs=ssl.CERT_REQUIRED) as ssl_s:
            print(&#x27;Connection accepted&#x27;)
            while True:
                # Receive data from the client
                data = ssl_s.recv(1024)
                if not data:
                    break
                print(data.decode())
```
### 4. Verifying Server Certificates

To verify a server&#x27;s certificate, you can use the `check_hostname` method or `verify_mode`.
```python
import ssl

# Create an SSL context with custom parameters
context = ssl.create_default_context()
context.check_hostname(&#x27;www.example.com&#x27;)  # Should print: True
context.verify_mode = ssl.CERT_REQUIRED
context.load_verify_locations(cafile=&#x27;path/to/ca.crt&#x27;)

try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        # Wrap the socket with SSL/TLS
        with context.wrap_socket(s, server_hostname=&#x27;www.example.com&#x27;) as ssl_s:
            # Establish the connection
            ssl_s.connect((&#x27;www.example.com&#x27;, 443))
except ssl.SSLError:
    print(&#x27;Server certificate is invalid&#x27;)
```
### 5. Using TLS Certificates

To use a custom TLS certificate, you can specify it when creating an SSL context.
```python
import ssl

# Create an SSL context with custom parameters
context = ssl.create_default_context()
context.load_cert_chain(certfile=&#x27;path/to/client.crt&#x27;, keyfile=&#x27;path/to/client.key&#x27;)

try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        # Wrap the socket with SSL/TLS
        with context.wrap_socket(s, server_hostname=&#x27;www.example.com&#x27;) as ssl_s:
            # Establish the connection
            ssl_s.connect((&#x27;www.example.com&#x27;, 443))
except ssl.SSLError:
    print(&#x27;Server certificate is invalid&#x27;)
```
### 6. Handling SSL/TLS Errors

To handle SSL/TLS errors, you can use try-except blocks.
```python
import ssl

try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        # Wrap the socket with SSL/TLS
        with context.wrap_socket(s, server_hostname=&#x27;www.example.com&#x27;) as ssl_s:
            # Establish the connection
            ssl_s.connect((&#x27;www.example.com&#x27;, 443))
except ssl.SSLError as e:
    print(f&#x27;SSL/TLS error: {e}&#x27;)
```
Note: The above examples are for illustration purposes only and should not be used in production without proper testing and validation.
</code></pre>

<h3 id='standard_library_documents/Networking and Interprocess Communication/mmap - Memory-mapped file support.md'>mmap - Memory-mapped file support.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># mmap — Memory-mapped file support

**Memory-Mapped File Support Module: mmap**
====================================================

### Overview

The `mmap` module provides an interface for mapping files into memory, allowing for efficient and flexible access to file contents.

### Functions

#### `mmap.mmap(file descriptor, length, offset, access, device=None)`

*   **file descriptor**: The file descriptor to be mapped.
*   **length**: The size of the area to be mapped (in bytes).
*   **offset**: The offset into the file where mapping begins.
*   **access**: A string specifying the access mode:
    *   &#x27;r&#x27; for read-only
    *   &#x27;w&#x27; for write-only
    *   &#x27;rw&#x27; for read-write
*   **device**: Optional device identifier (for Unix-based systems only)

**Example Usage:**
```python
import mmap

# Open a file in binary mode
with open(&#x27;example.bin&#x27;, &#x27;rb&#x27;) as file:
    # Create an mmap object mapping the entire file into memory
    mapped_file = mmap.mmap(file.fileno(), 0, access=&#x27;r&#x27;)

    # Map a specific region of the file into memory
    mapped_region = mmap.mmap(file.fileno(), 1024, offset=512, access=&#x27;rw&#x27;)

    # Access and manipulate the mapped data
    print(mapped_file.read(10))  # Read from the entire file
    print(mapped_region.readline())  # Read a line from the specified region

# Close the mmap object to release system resources
mapped_file.close()
```

#### `mmap.mmap.mmap(file descriptor, length, offset, access)`

*   This constructor is deprecated and should not be used directly.

### Classes

#### `mmap.MappedFile`

This class represents a mapped file in memory. It provides methods for accessing the mapped data.

**Example Usage:**
```python
import mmap

# Open a file in binary mode
with open(&#x27;example.bin&#x27;, &#x27;rb&#x27;) as file:
    # Create an MappedFile object mapping the entire file into memory
    with mmap.mmap(file.fileno(), 0, access=&#x27;r&#x27;) as mapped_file:
        print(mapped_file.read(10))  # Read from the entire file

# Access and manipulate the mapped data using methods provided by MappedFile
with open(&#x27;example.bin&#x27;, &#x27;rb&#x27;) as file:
    with mmap.MappedFile(file.fileno()) as mapped_file:
        mapped_data = mapped_file.read()
        print(mapped_data)  # Print the contents of the mapped file
```

### Constants

#### `mmap.ACCESS_READ` and `mmap.ACCESS_WRITE`

*   Define the access modes for `read-only` (0x0004) and `write-only` (0x0010), respectively.

```python
import mmap

ACCESS_READ = 0x0004  # Read-only access
ACCESS_WRITE = 0x0010  # Write-only access

# Usage:
with open(&#x27;example.bin&#x27;, &#x27;rb&#x27;) as file:
    with mmap.mmap(file.fileno(), 0, access=ACCESS_READ) as mapped_file:
        print(mapped_file.read(10))  # Read from the entire file
```

### Error Handling

#### `mmap.MAP_FAILED` and `mmap.ENOTFOUND`

*   Define error codes for mapping failures (0x12) and non-existent files (2).

```python
import mmap

MAP_FAILED = -12  # Mapping failed
ENOTFOUND = 2     # Non-existent file

# Usage:
try:
    with open(&#x27;nonexistent_file.bin&#x27;, &#x27;rb&#x27;) as file:
        with mmap.mmap(file.fileno(), 0, access=&#x27;r&#x27;) as mapped_file:
            print(mapped_file.read(10))
except OSError as e:
    if e.errno == ENOTFOUND:
        print(&quot;File not found:&quot;, e)
```

### Example Use Cases

*   **Binary Data Processing**: Map files into memory and process binary data using NumPy or Pandas.
*   **Large File Access**: Use `mmap` to access large files without loading the entire file into memory, reducing memory usage.
*   **Data Compression**: Compress data stored in a mapped file using libraries like gzip or zlib.

By leveraging the `mmap` module, developers can optimize memory usage and improve performance when working with files that contain large amounts of data.
</code></pre>

<h3 id='standard_library_documents/Networking and Interprocess Communication/asyncio - Asynchronous I O.md'>asyncio - Asynchronous I O.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># asyncio - Asynchronous I/O

Here&#x27;s an example of how you can use the `asyncio` module from Python&#x27;s standard library:

```python
import asyncio
import time

# Define a function that simulates an IO-bound task
async def read_file(file_path):
    &quot;&quot;&quot;
    Simulate reading a file.
    
    Args:
        file_path (str): The path to the file to be read.

    Returns:
        None
    &quot;&quot;&quot;
    # Simulate reading the file by sleeping for 2 seconds
    await asyncio.sleep(2)
    print(f&quot;Read {file_path}&quot;)

# Define a function that simulates an IO-bound task
async def write_file(file_path):
    &quot;&quot;&quot;
    Simulate writing to a file.
    
    Args:
        file_path (str): The path to the file to be written.

    Returns:
        None
    &quot;&quot;&quot;
    # Simulate writing to the file by sleeping for 2 seconds
    await asyncio.sleep(2)
    print(f&quot;Write {file_path}&quot;)

# Define an event loop
async def main():
    start_time = time.time()

    # Create two tasks that read and write files concurrently
    task1 = asyncio.create_task(read_file(&quot;file1.txt&quot;))
    task2 = asyncio.create_task(write_file(&quot;file2.txt&quot;))

    # Wait for both tasks to complete
    await asyncio.gather(task1, task2)

    end_time = time.time()
    print(f&quot;Time taken: {end_time - start_time} seconds&quot;)

# Run the main function
asyncio.run(main())
```

In this code example:

*   We define two functions `read_file` and `write_file` that simulate IO-bound tasks.
*   In the `main` function, we create an event loop using `asyncio.create_task`.
*   We use `asyncio.gather` to run both tasks concurrently.
*   The `asyncio.run(main())` call starts the event loop.

**How it works:**

1.  Create two tasks that read and write files concurrently.
2.  Use `asyncio.gather` to wait for both tasks to complete.
3.  Run the main function using `asyncio.run(main())`.

When you run this code, it will print:

```
Read file1.txt
Write file2.txt
Time taken: 4.001163 seconds
```

As expected, since the tasks are running concurrently, they should not take a total of 4 seconds.

### Best Practices

*   The `asyncio` module is used to write single-threaded concurrent code using coroutines.
*   The `create_task` function creates an asynchronous task that can be run concurrently with other tasks.
*   The `gather` function waits for multiple tasks to complete and returns a list of results.
</code></pre>
<h2 id='Program Frameworks'>Program Frameworks</h2><ul><li><a href='#standard_library_documents/Program Frameworks/cmd - Support for line-oriented command interpreters.md'>cmd - Support for line-oriented command interpreters.md</a></li><li><a href='#standard_library_documents/Program Frameworks/shlex - Simple lexical analysis.md'>shlex - Simple lexical analysis.md</a></li><li><a href='#standard_library_documents/Program Frameworks/turtle - Turtle graphics.md'>turtle - Turtle graphics.md</a></li></ul>
<h3 id='standard_library_documents/Program Frameworks/cmd - Support for line-oriented command interpreters.md'>cmd - Support for line-oriented command interpreters.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># cmd — Support for line-oriented command interpreters

**cmd.py**
```python
&quot;&quot;&quot;
Support for line-oriented command interpreters.
&quot;&quot;&quot;

import sys
from contextlib import contextmanager

class CommandError(Exception):
    &quot;&quot;&quot;Exception raised when a command error occurs.&quot;&quot;&quot;
    pass

class CommandInterpreter:
    &quot;&quot;&quot;
    A line-oriented command interpreter.

    Attributes:
        _lines (list): The lines of input to process.
        _current_line (str): The current line being processed.
    &quot;&quot;&quot;

    def __init__(self, *args):
        self._lines = args
        self._current_line = None

    @property
    def current_line(self):
        &quot;&quot;&quot;
        Get the current line being processed.

        Returns:
            str: The current line.
        &quot;&quot;&quot;
        return self._current_line

    @current_line.setter
    def current_line(self, value):
        &quot;&quot;&quot;
        Set the current line being processed.

        Args:
            value (str): The new current line.
        &quot;&quot;&quot;
        self._current_line = value

    @contextmanager
    def _process_line(self):
        &quot;&quot;&quot;
        Process a single line of input.

        Yields:
            list: The result of processing the line.
        &quot;&quot;&quot;
        try:
            yield
        except Exception as e:
            raise CommandError(f&quot;Processing error: {e}&quot;) from e

    def __iter__(self):
        &quot;&quot;&quot;
        Iterate over the lines of input.

        Yields:
            str: Each line of input.
        &quot;&quot;&quot;
        for line in self._lines:
            self.current_line = line
            yield from self._process_line()

def main():
    # Create a new command interpreter with some sample input lines
    interpreter = CommandInterpreter(
        &quot;hello&quot;,
        &quot;world!&quot;,
        &quot;# invalid line&quot;
    )

    # Process each line of input
    for result in interpreter:
        print(f&quot;Result: {result}&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

**Usage**
```bash
$ python cmd.py
Result: hello
Result: world!
Result: invalid line
Exception: CommandError: Processing error: SyntaxError: unexpected EOF while parsing
```
This implementation provides a basic command interpreter that can process lines of input. It includes the following features:

*   A `CommandInterpreter` class that manages the processing of individual lines.
*   A `_process_line` context manager that handles any errors that occur during line processing.
*   An `__iter__` method that yields each line of input.

Note that this is a simplified example, and you may want to add additional features such as support for command-line arguments or more complex syntax parsing.
</code></pre>

<h3 id='standard_library_documents/Program Frameworks/shlex - Simple lexical analysis.md'>shlex - Simple lexical analysis.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># shlex — Simple lexical analysis

**Shlex Module**
================

The `shlex` module provides simple lexical analysis of shell-like input.

### Usage

```python
import shlex

# Parsing example
input_string = &#x27;echo &quot;hello world&quot;&#x27;
parsed_string = shlex.split(input_string)
print(parsed_string)  # Output: [&#x27;echo&#x27;, &quot;hello world&quot;]

# Quoting and escaping example
quoted_input = &#x27;&quot;foo bar&quot; -- --&#x27;
quoting_style = shlex.quote
print(quoting_style(quoted_input))  # Output: &#x27;foo bar -- --&#x27;

# Tokenization example
input_string = &#x27;cat -n filename.txt&#x27;
tokens = shlex.split(input_string)
for token in tokens:
    print(token)  # Output: [&#x27;cat&#x27;, &#x27;-n&#x27;, &#x27;filename.txt&#x27;]
```

### Functions

#### `shlex.split(input_string, posix=False)`

Parses a string into a list of tokens.

*   `input_string`: The input string to parse.
*   `posix`: If `True`, splits on whitespace and quoted text according to the POSIX shell syntax. Defaults to `False`.

```python
# Example usage:
input_string = &#x27;foo bar&#x27;
parsed_tokens = shlex.split(input_string)
print(parsed_tokens)  # Output: [&#x27;foo&#x27;, &#x27;bar&#x27;]
```

#### `shlex.quote(value, posix=False)`

Escapes and quotes a value according to the shell syntax.

*   `value`: The input value to quote.
*   `posix`: If `True`, uses POSIX-style quoting. Defaults to `False`.

```python
# Example usage:
quoted_value = shlex.quote(&#x27;foo bar&#x27;)
print(quoted_value)  # Output: &#x27;foo\ bar&#x27;
```

### Classes

#### `shlex.tokenizer`

Provides a way to tokenize a stream of input.

*   `input_string`: The input string to tokenize.
*   `posix`: If `True`, uses POSIX-style quoting. Defaults to `False`.

```python
# Example usage:
tokenizer = shlex.tokenizer(input_string=&#x27;foo bar&#x27;)
while True:
    token = tokenizer.get_token()
    if not token:
        break
    print(token)  # Output: [&#x27;foo&#x27;, &#x27;bar&#x27;]
```

### Exceptions

#### `shlex.util.error`

Raised when an error occurs during parsing.

```python
try:
    shlex.split(&#x27;invalid input&#x27;)
except shlex.util.error as e:
    print(e)  # Output: Invalid input
```

Note that the actual exceptions raised by the `shlex` module may vary depending on the Python version and the specific use case.
</code></pre>

<h3 id='standard_library_documents/Program Frameworks/turtle - Turtle graphics.md'>turtle - Turtle graphics.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># turtle — Turtle graphics

Here&#x27;s an example of using the turtle module in Python:

```python
# Importing the turtle module
import turtle

# Creating a new turtle screen and setting its background color
screen = turtle.Screen()
screen.bgcolor(&quot;white&quot;)

# Creating a new turtle object
my_turtle = turtle.Turtle()

# Moving the turtle forward by 20 units
my_turtle.forward(100)

# Turning the turtle left by 90 degrees
my_turtle.left(90)

# Drawing a square using the turtle&#x27;s movements
for _ in range(4):
    my_turtle.forward(50)
    my_turtle.right(90)

# Writing &quot;Hello, World!&quot; on the screen using the turtle&#x27;s pen
my_turtle.penup()
my_turtle.goto(-100, 0)
my_turtle.pendown()
my_turtle.write(&quot;Hello, World!&quot;, align=&quot;center&quot;, font=(&quot;Arial&quot;, 24, &quot;bold&quot;))

# Keeping the window open until it is closed by the user
turtle.done()
```

### Turtle Module Overview

The turtle module in Python provides a simple way to create graphics and animations. It allows you to create shapes, lines, curves, and more using basic movements such as forward, backward, left, right, and up.

Here are some key features of the turtle module:

*   **Turtle Movement:** The turtle can move forward, backward, left, or right by a specified distance.
*   **Drawing Shapes:** You can use loops to draw shapes like squares, triangles, and more.
*   **Writing Text:** You can write text on the screen using the `write` method of the turtle object.
*   **Coloring Shapes:** You can change the color of the turtle&#x27;s pen by calling the `pencolor` method.

### Common Turtle Methods

Here are some common methods used with the turtle module:

*   `forward(distance)`: Moves the turtle forward by a specified distance.
*   `backward(distance)`: Moves the turtle backward by a specified distance.
*   `left(angle)`: Turns the turtle left by a specified angle.
*   `right(angle)`: Turns the turtle right by a specified angle.
*   `penup()`: Lifts the pen off the paper, allowing you to move without drawing.
*   `pendown()`: Places the pen back on the paper, starting to draw again.
*   `write(text, align=align, font=(font_size, font_type, font_style))`: Writes text on the screen using the turtle&#x27;s pen.

### Turtle Module Constants

Here are some constants provided by the turtle module:

*   `speed(slow=10, fast=0)`: Sets the speed of the turtle movements.
*   `colormode(r, g, b, color)`: Changes the color mode to RGB or CMYK.

Note: The above code examples demonstrate basic usage of the turtle module. For more advanced graphics and animations, consider exploring other Python modules like NumPy, Matplotlib, or Pillow.
</code></pre>
<h2 id='Numeric and Mathematical Modules'>Numeric and Mathematical Modules</h2><ul><li><a href='#standard_library_documents/Numeric and Mathematical Modules/statistics - Mathematical statistics functions.md'>statistics - Mathematical statistics functions.md</a></li><li><a href='#standard_library_documents/Numeric and Mathematical Modules/cmath - Mathematical functions for complex numbers.md'>cmath - Mathematical functions for complex numbers.md</a></li><li><a href='#standard_library_documents/Numeric and Mathematical Modules/math - Mathematical functions.md'>math - Mathematical functions.md</a></li><li><a href='#standard_library_documents/Numeric and Mathematical Modules/numbers - Numeric abstract base classes.md'>numbers - Numeric abstract base classes.md</a></li><li><a href='#standard_library_documents/Numeric and Mathematical Modules/fractions - Rational numbers.md'>fractions - Rational numbers.md</a></li><li><a href='#standard_library_documents/Numeric and Mathematical Modules/random - Generate pseudo-random numbers.md'>random - Generate pseudo-random numbers.md</a></li><li><a href='#standard_library_documents/Numeric and Mathematical Modules/decimal - Decimal fixed-point and floating-point arithmetic.md'>decimal - Decimal fixed-point and floating-point arithmetic.md</a></li></ul>
<h3 id='standard_library_documents/Numeric and Mathematical Modules/statistics - Mathematical statistics functions.md'>statistics - Mathematical statistics functions.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># statistics — Mathematical statistics functions

Here&#x27;s an example of how you can use the `statistics` module in Python 3.12:

```python
# Importing the statistics module
import statistics

def main():
    # Example 1: Finding the mean (average) of a list of numbers
    numbers = [1, 2, 3, 4, 5]
    mean = statistics.mean(numbers)
    print(&quot;Mean:&quot;, mean)

    # Example 2: Finding the median of a list of numbers
    numbers = [1, 2, 3, 4, 5]
    median = statistics.median(numbers)
    print(&quot;Median:&quot;, median)

    # Example 3: Finding the mode (most frequently occurring value) of a list of numbers
    numbers = [1, 2, 2, 3, 3, 3]
    try:
        mode = statistics.mode(numbers)
        print(&quot;Mode:&quot;, mode)
    except statistics.StatisticsError:
        print(&quot;No unique mode found&quot;)

    # Example 4: Finding the standard deviation of a list of numbers
    numbers = [1, 2, 3, 4, 5]
    stdev = statistics.stdev(numbers)
    print(&quot;Standard Deviation:&quot;, stdev)

    # Example 5: Finding the variance of a list of numbers
    numbers = [1, 2, 3, 4, 5]
    try:
        variance = statistics.variance(numbers)
        print(&quot;Variance:&quot;, variance)
    except statistics.StatisticsError:
        print(&quot;No unique mean found&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

The `statistics` module includes functions for calculating various mathematical statistics:

*   `mean`: returns the arithmetic mean (average) of a list of numbers.
*   `median`: returns the median of a sorted list of numbers.
*   `mode`: returns the most frequently occurring value in a list of numbers. If there is no unique mode, it raises a `StatisticsError`.
*   `stdev`: returns the standard deviation of a list of numbers.
*   `variance`: returns the variance of a list of numbers.

Please note that for certain functions like `mode`, `stdev` and `variance`, they require the input data to be sorted, so you need to sort the input before calling these functions. 

Also note that in case of floating point operations some results may have tiny rounding errors due to limitations in binary representation, but these should not affect your program&#x27;s behavior for most practical purposes.

Each function has a corresponding function with an `Error` raised if you try to use it on non-numeric data or if the number is less than 1 and the function used.
</code></pre>

<h3 id='standard_library_documents/Numeric and Mathematical Modules/cmath - Mathematical functions for complex numbers.md'>cmath - Mathematical functions for complex numbers.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># cmath — Mathematical functions for complex numbers

**cmath Module Documentation**
================================

The `cmath` module provides functions to handle complex numbers.

### Importing the Module

```python
import cmath
```

### Functions

#### 1. `cmath.exp(x)`

Computes the exponential function of a complex number.

```python
# Example usage:
result = cmath.exp(2 + 3j)
print(result)
```

#### 2. `cmath.log(x)`

Computes the natural logarithm of a positive real number or the complex logarithm of a complex number.

```python
# Example usage:
result = cmath.log(10)
print(result)

# Complex logarithm example:
complex_result = cmath.log(16 + 8j)
print(complex_result)
```

#### 3. `cmath.sqrt(x)`

Computes the square root of a positive real number or the complex square root of a complex number.

```python
# Example usage:
real_sqrt = cmath.sqrt(9)
complex_sqrt = cmath.sqrt(16 + 8j)
print(real_sqrt, complex_sqrt)
```

#### 4. `cmath.polar(x)`

Returns the polar form of a complex number.

```python
import math

# Example usage:
result = cmath.polar(10 + 2j)
r, phi = result
print(f&#x27;r = {r}, phi = {phi}&#x27;)

# Convert back to rectangular form:
rectangular_form = cmath.rect(r, phi)
print(rectangular_form)
```

#### 5. `cmath.phase(x)`

Returns the phase of a complex number.

```python
# Example usage:
result = cmath.phase(10 + 2j)
print(result)

# Note: This function is not always defined for all real numbers.
# It raises a ValueError if the input is zero or negative.
```

#### 6. `cmath.rect(r, phi)`

Returns the rectangular form of a complex number.

```python
import math

# Example usage:
result = cmath.rect(10, math.pi / 2)
print(result)

# Note: This function is not always defined for all real numbers.
# It raises a ValueError if r &lt;= 0 or pi/2 &lt; phi + 2*pi*n &lt; 3*pi/2.
```

#### 7. `cmath.isclose(x, y)` and `cmath.isfinite(x)`, etc.

These functions check whether two numbers are close to each other or finite, respectively.

```python
# Example usage:
import math

x = cmath.sqrt(-4)
print(cmath.isclose(x, -2))  # Returns True due to floating-point errors.
print(math.isfinite(x))      # Returns False.
```

### Constants

#### `cmath.pi` and `cmath.e`

Constants for pi and e.

```python
import math

# Example usage:
result = cmath.pi / (1 + cmath.sqrt(-3))
print(result)

result = cmath.e ** 2
print(result)
```
</code></pre>

<h3 id='standard_library_documents/Numeric and Mathematical Modules/math - Mathematical functions.md'>math - Mathematical functions.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># math — Mathematical functions

**Math Module Code Examples**
=====================================

The math module provides access to mathematical functions.

### Importing the Math Module
```python
# Import the math module
import math

# Print the version of the math module
print(math.version)

# Alternatively, you can also import the math module using &#x27;from math import *&#x27;
# from math import *

# Access a specific function from the math module
# print(math.sin(30))  # Calculate sine of 30 degrees
```

### Basic Math Functions
```python
# Trigonometric functions
print(math.sin(0))  # Sine of 0 degrees
print(math.cos(0))  # Cosine of 0 degrees
print(math.tan(0))  # Tangent of 0 degrees

print(math.sin(math.pi/2))  # Sine of pi/2 radians (90 degrees)

# Exponential and logarithmic functions
import math
x = 10
exp_x = math.exp(x)  # Calculate exponential of x
log_x = math.log(x)   # Calculate natural logarithm of x

# Power function
print(math.pow(2, 3))  # Square the number 2

# Absolute value
print(abs(-5))  # Calculate absolute value of -5

# Round a number to a specific decimal place
print(round(10.1234, 2))  # Round 10.1234 to 2 decimal places
```

### Hyperbolic Functions
```python
import math

# Hyperbolic sine (hyperbolic arc sine)
y = math.sinh(1)  # Calculate hyperbolic sine of 1

# Hyperbolic cosine (hyperbolic arc cosine)
z = math.cosh(0)  # Calculate hyperbolic cosine of 0

# Hyperbolic tangent (hyperbolic arc tangent)
t = math.tanh(0.5)  # Calculate hyperbolic tangent of 0.5
```

### Rounding and Remainder Functions
```python
import math

# Round a number to the nearest integer
print(math.ceil(10.1234))  # Round 10.1234 to the nearest integer
print(math.floor(10.1234))  # Round 10.1234 to the nearest lower integer

# Calculate remainder of division
a = 17
b = 5
remainder = a % b  # Calculate remainder of 17 divided by 5
```

### Math Constants
```python
import math

print(math.pi)  # Pi constant
print(math.e)   # Euler&#x27;s number (approximately 2.71828)
```

### Math Degrees to Radians Conversion Function
```python
import math

def deg_to_rad(degrees):
    &quot;&quot;&quot;
    Convert degrees to radians.
    
    Parameters:
    degrees (float): Angle in degrees
    
    Returns:
    float: Angle in radians
    &quot;&quot;&quot;
    return degrees * math.pi / 180

# Test the function
print(deg_to_rad(30))  # Output: pi/6
```
</code></pre>

<h3 id='standard_library_documents/Numeric and Mathematical Modules/numbers - Numeric abstract base classes.md'>numbers - Numeric abstract base classes.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># numbers — Numeric abstract base classes

Here&#x27;s an example of how you can use the `numbers` module from Python&#x27;s standard library.

```python
# Importing numbers module
from numbers import *

# Create instances of numeric types
int_instance = 5   # Integer
float_instance = 3.14  # Floating Point Number
complex_instance = 2+7j  # Complex Number

# Printing the values
print(&quot;Integer Instance:&quot;, int_instance)
print(&quot;Floating Point Instance:&quot;, float_instance)
print(&quot;Complex Instance:&quot;, complex_instance)

# Using numeric types in arithmetic operations
result_int_addition = int_instance + 5  # Integer Addition
result_float_multiplication = float_instance * 2.5  # Floating Point Multiplication

# Printing the results
print(&quot;Integer Addition Result:&quot;, result_int_addition)
print(&quot;Floating Point Multiplication Result:&quot;, result_float_multiplication)

# Checking if a number is an instance of a specific numeric type
if isinstance(int_instance, int):
    print(f&quot;{int_instance} is an integer&quot;)
elif isinstance(float_instance, float):
    print(f&quot;{float_instance} is a floating point number&quot;)
elif isinstance(complex_instance, complex):
    print(f&quot;{complex_instance} is a complex number&quot;)

# Using numeric types in comparison operations
print(&quot;Is int_instance greater than 10?&quot;, int_instance &gt; 10)
print(&quot;Is float_instance less than 2.5?&quot;, float_instance &lt; 2.5)

# Checking the type of a number
if isinstance(int_instance, (int, float)):
    print(f&quot;{int_instance} is either an integer or a floating point number&quot;)
elif isinstance(complex_instance, (int, float)):
    print(f&quot;{complex_instance} is either an integer or a floating point number&quot;)

# Using numeric types in membership tests
print(&quot;Is 5 an instance of the int type?&quot;, isinstance(5, int))
print(&quot;Is 3.14 an instance of the float type?&quot;, isinstance(3.14, float))

# Checking if a number is finite (not infinite)
if complex_instance.imag == 0 and complex_instance.real != 0:
    print(f&quot;{complex_instance} is a real number&quot;)
elif float_instance == float_instance:  # Not strictly equal to itself because of floating point precision issues
    print(f&quot;{float_instance} is a non-negative zero value&quot;)
else:
    print(f&quot;{float_instance} is a finite number&quot;)

# Checking if a number is an integer or a rational (not necessarily an integer)
if isinstance(int_instance, int):
    print(f&quot;{int_instance} is an integer&quot;)
elif isinstance(complex_instance, complex) and complex_instance.imag == 0:
    print(f&quot;{complex_instance} is a real rational number&quot;)
else:
    print(f&quot;{float_instance} is not an integer or rational&quot;)

# Using numeric types in geometric calculations
import math

print(&quot;Is the square root of 9 an integer?&quot;, isinstance(math.sqrt(9), int))
print(&quot;Is the cube root of 27 an integer?&quot;, isinstance(round(27 ** (1./3)), int))

```
This example showcases how you can use instances of different numeric types, perform arithmetic operations, and make comparisons with these numbers.
</code></pre>

<h3 id='standard_library_documents/Numeric and Mathematical Modules/fractions - Rational numbers.md'>fractions - Rational numbers.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># fractions — Rational numbers

**Fraction Module**
================

The `fractions` module provides support for rational number arithmetic.

### Importing the Module

```python
import fractions
```

### Creating Fractions

You can create a fraction by passing two integers to the `fractions.Fraction()` constructor:

```python
# Create a fraction from two integers
frac = fractions.Fraction(1, 2)
print(frac)  # Output: 1/2
```

Or you can pass a string representation of the fraction:

```python
# Create a fraction from a string
frac = fractions.Fraction(&#x27;1/2&#x27;)
print(frac)  # Output: 1/2
```

You can also create a fraction with a specific denominator by passing an integer to the `denominator` parameter:

```python
# Create a fraction with a custom denominator
frac = fractions.Fraction(1, 3)
print(frac.numerator)  # Output: 1
print(frac.denominator)  # Output: 3
```

### Basic Operations

You can perform basic arithmetic operations on fractions using the following methods:

```python
# Add two fractions
result = frac + fractions.Fraction(1, 4)
print(result)  # Output: 3/4

# Subtract one fraction from another
result = frac - fractions.Fraction(1, 4)
print(result)  # Output: 1/2

# Multiply two fractions
result = frac * fractions.Fraction(1, 4)
print(result)  # Output: 1/8

# Divide one fraction by another
result = frac / fractions.Fraction(1, 4)
print(result)  # Output: 2
```

### Comparing Fractions

You can compare two fractions using the following methods:

```python
# Check if two fractions are equal
print(frac == fractions.Fraction(1, 2))  # Output: True
print(frac != fractions.Fraction(1, 3))  # Output: False

# Compare two fractions (greater than, less than)
result = frac &gt; fractions.Fraction(1, 4)  # Output: False
result = frac &lt; fractions.Fraction(1, 2)  # Output: True
```

### Limiting Fractions

You can limit the number of digits in a fraction using the `limit_denominator()` method:

```python
# Create a fraction with limited precision
frac = fractions.Fraction(1, 3).limit_denominator(10)
print(frac)  # Output: 1/3
```

### Cancelling Fractions

You can simplify a fraction by cancelling out common factors using the `cancel()` method:

```python
# Create two fractions with common factors
frac1 = fractions.Fraction(6, 12)
frac2 = fractions.Fraction(3, 4)

# Cancel out common factors
frac1 = frac1.cancel()
frac2 = frac2.cancel()

print(frac1)  # Output: 1/2
print(frac2)  # Output: 1/4
```

### Customization

You can customize the behavior of the `fractions` module by using the `decimal` argument when creating a fraction:

```python
# Create two fractions with different precision
frac1 = fractions.Fraction(1, 3).limit_denominator(decimal=28)
frac2 = fractions.Fraction(6, 12).limit_denominator(decimal=50)

print(frac1)  # Output: 7/21
print(frac2)  # Output: 5/10
```
</code></pre>

<h3 id='standard_library_documents/Numeric and Mathematical Modules/random - Generate pseudo-random numbers.md'>random - Generate pseudo-random numbers.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># random — Generate pseudo-random numbers

**Random Module Code Examples**
=====================================

### Importing the Random Module
```python
# Import the random module
import random
```

### Generating Random Integers
```python
# Generate a random integer between 1 and 10
print(random.randint(1, 10))  # Output: 5

# Generate a random integer within a specified range
print(random.randint(-10, 10))  # Output: -7
```

### Generating Random Floating Point Numbers
```python
# Generate a random floating point number between 1.0 and 10.0
print(random.uniform(1.0, 10.0))  # Output: 4.523213456123456

# Generate a random floating point number within a specified range
print(random.uniform(-10.0, 10.0))  # Output: 2.134567890123456
```

### Generating Random Choices
```python
# Define a list of choices
choices = [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;cherry&#x27;]

# Generate a random choice from the list
print(random.choice(choices))  # Output: e.g., &#x27;banana&#x27;

# Generate multiple random choices
print(random.choices(choices, k=3))  # Output: e.g., [&#x27;banana&#x27;, &#x27;apple&#x27;, &#x27;cherry&#x27;]
```

### Generating Random Samples
```python
# Define a list of sample data
data = [1, 2, 3, 4, 5]

# Generate a random sample of 3 elements from the list
print(random.sample(data, 3))  # Output: e.g., [4, 2, 5]
```

### Shuffling Lists
```python
# Define a list to be shuffled
numbers = [1, 2, 3, 4, 5]

# Shuffle the list in-place
random.shuffle(numbers)
print(numbers)  # Output: e.g., [4, 5, 2, 1, 3]
```

### Setting Random Seeds
```python
# Set the random seed to a fixed value for reproducibility
random.seed(42)

# Generate a random integer between 1 and 10
print(random.randint(1, 10))  # Output: always 5

# Set the random seed again to return to default behavior
random.seed()
```

### Other Functions
```python
# Get the current system time in seconds since the epoch
print(random.getrandbits(32))

# Generate a random boolean value
print(random.random() &lt; 0.5)  # Output: True or False

# Generate a random selection of two values from a list
selected = random.sample([1, 2, 3], 2)
print(selected)  # Output: e.g., [2, 1]
```

Note that the `random` module uses a pseudo-random number generator (PRNG), which is seeded with a fixed value or generated randomly at runtime. This means that the output of the PRNG will be different each time you run your program.
</code></pre>

<h3 id='standard_library_documents/Numeric and Mathematical Modules/decimal - Decimal fixed-point and floating-point arithmetic.md'>decimal - Decimal fixed-point and floating-point arithmetic.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># decimal — Decimal fixed-point and floating-point arithmetic

**Decimal Module: Fixed-Point and Floating-Point Arithmetic**
===========================================================

The `decimal` module provides support for fast correctly rounded decimal floating point arithmetic.

### Importing the Module

```python
import decimal
```

### Setting the Precision

You can set the precision of the decimal arithmetic using the `getcontext().prec` attribute. This sets the total number of digits available for representation in the decimal arithmetic.

```python
# Set the precision to 4
decimal.getcontext().prec = 4
print(decimal.Decimal(&#x27;1.2345&#x27;).quantize(decimal.Decimal(&#x27;0.01&#x27;)))  # Output: 1.23
```

### Decimal Types

The `decimal` module supports two types of decimal numbers:

*   `decimal.Decimal`: This is the primary type for decimal arithmetic.
*   `int`: You can also use integers as decimal numbers, but this can lead to unexpected behavior if you&#x27;re not careful.

```python
# Create a decimal number using Decimal
decimal_num = decimal.Decimal(&#x27;1.2345&#x27;)
print(decimal_num)  # Output: 1.2345

# Use an integer as a decimal number (not recommended)
int_num = 12345
print(int_num)  # Output: 12345
```

### Operations on Decimal Numbers

You can perform various arithmetic operations on decimal numbers, including addition, subtraction, multiplication, and division.

```python
# Perform arithmetic operations
decimal_num1 = decimal.Decimal(&#x27;1.2345&#x27;)
decimal_num2 = decimal.Decimal(&#x27;2.3456&#x27;)

result_addition = decimal_num1 + decimal_num2
result_subtraction = decimal_num1 - decimal_num2
result_multiplication = decimal_num1 * decimal_num2
result_division = decimal_num1 / decimal_num2

print(result_addition)  # Output: 3.5801
print(result_subtraction)  # Output: -1.1111
print(result_multiplication)  # Output: 2.88805
print(result_division)  # Output: 0.5417
```

### Rounding Decimal Numbers

You can round decimal numbers using the `quantize` method or the `round` function.

```python
# Round a decimal number to 1 place after the decimal point
decimal_num = decimal.Decimal(&#x27;1.2345&#x27;)
rounded_num = decimal_num.quantize(decimal.Decimal(&#x27;0.01&#x27;))
print(rounded_num)  # Output: 1.23

# Round a decimal number using round function
import math
rounded_num = round(decimal.Decimal(&#x27;1.2345&#x27;), 2)
print(rounded_num)  # Output: 1.23
```

### Comparison and Ordering

You can compare and order decimal numbers using the standard comparison operators or the `compare` method.

```python
# Compare two decimal numbers
decimal_num1 = decimal.Decimal(&#x27;1.2345&#x27;)
decimal_num2 = decimal.Decimal(&#x27;2.3456&#x27;)

print(decimal_num1 &gt; decimal_num2)  # Output: False

# Order a list of decimal numbers
decimal_list = [decimal.Decimal(&#x27;1.2345&#x27;), decimal.Decimal(&#x27;2.3456&#x27;), decimal.Decimal(&#x27;0.1234&#x27;)]
sorted_list = sorted(decimal_list, key=lambda x: x)
print(sorted_list)  # Output: [decimal.Decimal(&#x27;0.1234&#x27;), decimal.Decimal(&#x27;1.2345&#x27;), decimal.Decimal(&#x27;2.3456&#x27;)]
```

### Formatting Decimal Numbers

You can format decimal numbers using the `format` function or f-strings.

```python
# Format a decimal number as a string with a specific precision and scale
decimal_num = decimal.Decimal(&#x27;1.2345&#x27;)
formatted_str = &quot;{:.4f}&quot;.format(decimal_num)
print(formatted_str)  # Output: 1.2345

# Use f-string to format a decimal number
formatted_str = f&quot;{decimal_num:.4f}&quot;
print(formatted_str)  # Output: 1.2345
```

### Miscellaneous Functions

The `decimal` module provides several miscellaneous functions, including:

*   `Context.clear`: Clears the context.
*   `Context.copy`: Returns a copy of the current context.
*   `Context.diff`: Calculates the difference between two decimal numbers in terms of their absolute value.
*   `Context.compare`: Compares two decimal numbers.

```python
# Clear the context
decimal.getcontext().clear()

# Copy the current context
context_copy = decimal.getcontext().copy()

# Calculate the difference between two decimal numbers
import math
difference = math.fabs(decimal.Decimal(&#x27;1.2345&#x27;) - decimal.Decimal(&#x27;2.3456&#x27;))
print(difference)  # Output: 1.11111

# Compare two decimal numbers
compare_result = decimal.getcontext().compare(decimal.Decimal(&#x27;1.2345&#x27;), decimal.Decimal(&#x27;2.3456&#x27;))
print(compare_result)  # Output: -1
```
</code></pre>
<h2 id='Development Tools'>Development Tools</h2><ul><li><a href='#standard_library_documents/Development Tools/test.support.script_helper - Utilities for the Python test suite.md'>test.support.script_helper - Utilities for the Python test suite.md</a></li><li><a href='#standard_library_documents/Development Tools/unittest.mock - mock object library.md'>unittest.mock - mock object library.md</a></li><li><a href='#standard_library_documents/Development Tools/typing - Support for type hints.md'>typing - Support for type hints.md</a></li><li><a href='#standard_library_documents/Development Tools/test.support - Utilities for the Python test suite.md'>test.support - Utilities for the Python test suite.md</a></li><li><a href='#standard_library_documents/Development Tools/2to3 - Automated Python 2 to 3 code translation.md'>2to3 - Automated Python 2 to 3 code translation.md</a></li><li><a href='#standard_library_documents/Development Tools/pydoc - Documentation generator and online help system.md'>pydoc - Documentation generator and online help system.md</a></li><li><a href='#standard_library_documents/Development Tools/doctest - Test interactive Python examples.md'>doctest - Test interactive Python examples.md</a></li><li><a href='#standard_library_documents/Development Tools/test - Regression tests package for Python.md'>test - Regression tests package for Python.md</a></li><li><a href='#standard_library_documents/Development Tools/unittest - Unit testing framework.md'>unittest - Unit testing framework.md</a></li><li><a href='#standard_library_documents/Development Tools/unittest.mock - getting started.md'>unittest.mock - getting started.md</a></li></ul>
<h3 id='standard_library_documents/Development Tools/test.support.script_helper - Utilities for the Python test suite.md'>test.support.script_helper - Utilities for the Python test suite.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># test.support.script_helper — Utilities for the Python test suite

Here are some examples of how you can use utilities provided by `test.support.script_helper`:
```python
import unittest
from test.support.script_helper import *

# Example 1: Test that a script exits with the correct status code
def test_script_exit():
    # Create a simple script that exits with a specific status code
    script = &quot;&quot;&quot;
        import sys

        if __name__ == &quot;__main__&quot;:
            print(&quot;Hello World!&quot;)
            sys.exit(123)
    &quot;&quot;&quot;

    # Run the script and check the exit status
    process = subprocess.Popen(script, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    output, error = process.communicate()
    assert process.returncode == 123

# Example 2: Test that a script outputs to a file descriptor
def test_script_output():
    # Create a simple script that prints to the standard output
    script = &quot;&quot;&quot;
        import sys

        if __name__ == &quot;__main__&quot;:
            print(&quot;Hello World!&quot;, flush=True)
    &quot;&quot;&quot;

    # Run the script and check the output
    process = subprocess.Popen(script, shell=True, stdout=subprocess.PIPE)
    output = process.communicate()[0]
    assert output.decode().strip() == &quot;Hello World!&quot;

# Example 3: Test that a script has the correct shebang line
def test_script_shebang():
    # Create a simple script with a shebang line that points to an invalid interpreter
    script = &quot;#!/bin/non-existent-interpreter\nimport sys\nif __name__ == \&quot;__main__\&quot;:\n    print(\&quot;Hello World!\&quot;)&quot;

    # Try to run the script and check for an error
    try:
        subprocess.run(script, shell=True, check=False)
    except FileNotFoundError:
        pass
    else:
        assert False

# Example 4: Test that a script has the correct executable permissions
def test_script_permissions():
    # Create a simple script with the wrong permissions
    script = &quot;&quot;&quot;
        import sys

        if __name__ == &quot;__main__&quot;:
            print(&quot;Hello World!&quot;)
    &quot;&quot;&quot;

    # Try to run the script and check for an error
    try:
        subprocess.run(script, shell=True)
    except PermissionError:
        pass
    else:
        assert False

# Example 5: Test that a script imports correctly
def test_script_imports():
    # Create a simple module with a function
    mod = &quot;&quot;&quot;
    import sys

    def hello_world():
        print(&quot;Hello World!&quot;)

    def main():
        hello_world()

    if __name__ == &quot;__main__&quot;:
        main()
    &quot;&quot;&quot;

    # Run the script and check that it calls the function
    process = subprocess.Popen(mod, shell=True)
    output = process.communicate()[0]
    assert &quot;Hello World!&quot; in output.decode()

if __name__ == &quot;__main__&quot;:
    unittest.main(argv=[__file__, &quot;-v&quot;, &quot;-s&quot;])
```
These examples demonstrate how you can use `test.support.script_helper` to test various aspects of a script, including its exit status, output, shebang line, permissions, and imports.
</code></pre>

<h3 id='standard_library_documents/Development Tools/unittest.mock - mock object library.md'>unittest.mock - mock object library.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># unittest.mock — mock object library

Here&#x27;s an example of how you can use `unittest.mock` to mock objects in your tests:

```python
import unittest
from unittest import mock
from your_module import YourClass  # Import the class you want to test

class TestYourClass(unittest.TestCase):

    @mock.patch(&#x27;your_module.your_function&#x27;)
    def test_your_function(self, mock_your_function):
        &quot;&quot;&quot;
        Mocking a function and verifying its behavior.
        
        In this example, we&#x27;re mocking `your_function` from `your_module`.
        We then call the mocked function and verify that it was called with
        the correct arguments.
        &quot;&quot;&quot;
        mock_your_function.return_value = &#x27;Mocked return value&#x27;
        your_class = YourClass()
        result = your_class.your_function()
        self.assertEqual(result, &#x27;Mocked return value&#x27;)

    @mock.patch(&#x27;your_module.your_other_function&#x27;)
    def test_your_other_function(self, mock_your_other_function):
        &quot;&quot;&quot;
        Mocking another function and verifying its behavior.
        
        In this example, we&#x27;re mocking `your_other_function` from `your_module`.
        We then call the mocked function and verify that it was called with
        the correct arguments and returned the expected value.
        &quot;&quot;&quot;
        mock_your_other_function.return_value = &#x27;Mocked return value&#x27;
        your_class = YourClass()
        result = your_class.your_other_function()
        self.assertEqual(result, &#x27;Mocked return value&#x27;)

    @mock.patch(&#x27;your_module.YourClass&#x27;)
    def test_inheritance(self, mock_YourClass):
        &quot;&quot;&quot;
        Mocking a class and verifying its behavior.
        
        In this example, we&#x27;re mocking `YourClass` from `your_module`.
        We then create an instance of the mocked class and verify that it
        behaves as expected.
        &quot;&quot;&quot;
        mock_YourClass.return_value = YourClass()
        your_class = mock_YourClass.return_value
        self.assertIsInstance(your_class, YourClass)

if __name__ == &#x27;__main__&#x27;:
    unittest.main()
```

In this example, we&#x27;re using `@mock.patch` to create a mock object for `your_function` and verify its behavior. We&#x27;re also mocking another function and verifying that it behaves as expected.

Here are some key things to note:

*   The `@mock.patch` decorator is used to create a mock object for the specified module or function.
*   You can use the `return_value` attribute of the mock object to specify the value that should be returned when the mocked function is called.
*   You can use the `side_effect` attribute of the mock object to specify the value(s) that should be returned when the mocked function is called multiple times or raises an exception.
*   The `assertIsInstance` method is used to verify that a mock object behaves like the original class.

**Mocking Exceptions**

You can also use `@mock.patch` to mock exceptions:

```python
@mock.patch(&#x27;your_module.your_function&#x27;)
def test_your_function(self, mock_your_function):
    &quot;&quot;&quot;
    Mocking an exception and verifying its behavior.
    
    In this example, we&#x27;re mocking `your_function` from `your_module`.
    We then call the mocked function and verify that it raises the expected exception.
    &quot;&quot;&quot;
    mock_your_function.side_effect = Exception(&#x27;Mocked exception&#x27;)
    with self.assertRaises(Exception):
        your_class.your_function()
```

In this example, we&#x27;re using the `side_effect` attribute of the mock object to specify an exception. We then use a `with` statement to ensure that the mocked function raises the expected exception.

**Mocking Methods**

You can also use `@mock.patch` to mock methods:

```python
class TestYourClass(unittest.TestCase):

    @mock.patch(&#x27;your_module.your_class&#x27;)
    def test_your_method(self, mock_your_class):
        &quot;&quot;&quot;
        Mocking a method and verifying its behavior.
        
        In this example, we&#x27;re mocking the `your_method` of `your_class`.
        We then call the mocked method and verify that it behaves as expected.
        &quot;&quot;&quot;
        mock_your_class.return_value.your_method.return_value = &#x27;Mocked return value&#x27;
        your_class = YourClass()
        result = your_class.your_method()
        self.assertEqual(result, &#x27;Mocked return value&#x27;)

    @mock.patch(&#x27;your_module.YourClass&#x27;)
    def test_inheritance(self, mock_YourClass):
        &quot;&quot;&quot;
        Mocking a method and verifying its behavior.
        
        In this example, we&#x27;re mocking the `your_method` of `YourClass`.
        We then create an instance of the mocked class and verify that it
        behaves as expected.
        &quot;&quot;&quot;
        mock_YourClass.return_value.your_method.return_value = &#x27;Mocked return value&#x27;
        your_class = mock_YourClass.return_value
        self.assertEqual(your_class.your_method(), &#x27;Mocked return value&#x27;)
```

In this example, we&#x27;re using the `return_value` attribute of the mock object to specify a value for the mocked method. We then call the mocked method and verify that it behaves as expected.

**Resetting Mocks**

After a test has completed, you may want to reset the mocks to restore their original state:

```python
@mock.patch(&#x27;your_module.your_function&#x27;)
def test_your_function(self, mock_your_function):
    &quot;&quot;&quot;
    Mocking an object and verifying its behavior.
    
    In this example, we&#x27;re mocking `your_function` from `your_module`.
    We then call the mocked function and verify that it behaves as expected.
    After the test completes, we reset the mock to restore its original state.
    &quot;&quot;&quot;
    mock_your_function.return_value = &#x27;Mocked return value&#x27;
    your_class = YourClass()
    result = your_class.your_function()
    self.assertEqual(result, &#x27;Mocked return value&#x27;)
    mock_your_function.assert_called_once_with(&#x27;some_args&#x27;)
```

In this example, we&#x27;re using the `assert_called_once_with` method to verify that the mocked function was called once with the correct arguments. After the test completes, we&#x27;re using the `assert_called_once_with` method again to ensure that the mock is in its original state.

**Using a Mock Factory**

Instead of creating mocks directly, you can use a mock factory to create mocks programmatically:

```python
@mock.patch(&#x27;your_module.your_function&#x27;, side_effect=Exception(&#x27;Mocked exception&#x27;))
def test_your_function(self):
    &quot;&quot;&quot;
    Using a mock factory to create a mock object.
    
    In this example, we&#x27;re using the `@mock.patch` decorator to create a mock
    object for `your_function`. We then use the `@patch.object` context manager
    to patch the `your_function` attribute of `your_class`.
    &quot;&quot;&quot;
    with patch.object(YourClass, &#x27;your_function&#x27;, side_effect=Exception(&#x27;Mocked exception&#x27;)):
        your_class = YourClass()
        result = your_class.your_function()
        self.assertEqual(result, Exception(&#x27;Mocked exception&#x27;))
```

In this example, we&#x27;re using the `@patch.object` context manager to create a mock object for `your_function`. We then use the `side_effect` attribute of the mock object to specify an exception.
</code></pre>

<h3 id='standard_library_documents/Development Tools/typing - Support for type hints.md'>typing - Support for type hints.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># typing — Support for type hints

**typing Module**
================

The `typing` module provides support for type hints, which can improve the readability and maintainability of Python code.

### Importing the typing Module
```python
import typing as t
```
### Type Hints

Type hints are used to indicate the expected types of variables, function parameters, and return values. Here&#x27;s an example:
```python
from typing import List

def greet(name: str) -&gt; None:
    print(f&quot;Hello, {name}!&quot;)
```
In this example, `str` is a type hint indicating that the `name` parameter should be a string.

### Type Hints for Lists and Tuples

You can use the `List` and `Tuple` types to indicate that a variable or function parameter should be a list or tuple:
```python
from typing import List, Tuple

def process_data(data: List[int]) -&gt; None:
    print(f&quot;Processing data: {data}&quot;)

def extract_key(data: Tuple[str, int]) -&gt; str:
    return data[0]
```
### Type Hints for Dictionaries

You can use the `Dict` type to indicate that a variable or function parameter should be a dictionary:
```python
from typing import Dict

def process_config(config: Dict[str, bool]) -&gt; None:
    print(f&quot;Processing config: {config}&quot;)
```
### Type Hints for Union Types

Union types allow you to specify multiple possible types for a variable or function parameter. Here&#x27;s an example using the `Union` type:
```python
from typing import Union

def process_data(data: Union[int, str]) -&gt; None:
    if isinstance(data, int):
        print(f&quot;Processing integer data: {data}&quot;)
    elif isinstance(data, str):
        print(f&quot;Processing string data: {data}&quot;)
```
### Type Hints for Optional Types

Optional types allow you to specify that a variable or function parameter may be `None`. Here&#x27;s an example using the `Optional` type:
```python
from typing import Optional

def process_data(data: Optional[int]) -&gt; None:
    if data is not None:
        print(f&quot;Processing integer data: {data}&quot;)
```
### Type Hints for Named Tuples

Named tuples are a convenient way to represent structured data in Python. Here&#x27;s an example using the `TypedDict` type:
```python
from typing import TypedDict

class Person(TypedDict):
    name: str
    age: int

def process_person(person: Person) -&gt; None:
    print(f&quot;Processing person: {person}&quot;)
```
### Type Hints for Generic Types

Generic types allow you to specify the types of template parameters. Here&#x27;s an example using the `List` and `TypeVar` type:
```python
from typing import List, TypeVar

T = TypeVar(&quot;T&quot;)

def process_data(data: List[T]) -&gt; None:
    print(f&quot;Processing data: {data}&quot;)
```
### Using the `Literal` Type

The `Literal` type allows you to specify a fixed value. Here&#x27;s an example:
```python
from typing import Literal

def greet(greeting: Literal[&quot;hello&quot;, &quot;goodbye&quot;]) -&gt; None:
    print(greeting)
```
This code will only accept `&quot;hello&quot;` or `&quot;goodbye&quot;` as the value for the `greeting` parameter.

### Using the `Union` Type with a Single Value

You can also use the `Union` type with a single value to make it more readable. Here&#x27;s an example:
```python
from typing import Union

def process_data(data: Union[str, int]) -&gt; None:
    print(f&quot;Processing data: {data}&quot;)
```
This code is equivalent to using the `str | int` syntax in Python 3.10 and later.

### Using the ` Any` Type

The `Any` type allows you to specify that a variable or function parameter can be any type. Here&#x27;s an example:
```python
from typing import Any

def process_data(data: Any) -&gt; None:
    print(f&quot;Processing data: {data}&quot;)
```
This code will accept any type of value.

### Using the `NoReturn` Type

The `NoReturn` type indicates that a function does not return any value. Here&#x27;s an example:
```python
from typing import NoReturn

def raise_error() -&gt; NoReturn:
    raise Exception(&quot;Something went wrong&quot;)
```
This code is useful when you want to indicate that a function will raise an exception and never returns.

### Using the ` Callable` Type

The `Callable` type allows you to specify that a variable or function parameter should be a callable object. Here&#x27;s an example:
```python
from typing import Callable

def process_data(data: Callable[[int], None]) -&gt; None:
    data(42)
```
This code will accept any callable object that takes an `int` argument and returns `None`.

### Using the ` overload` Decorator

The `overload` decorator allows you to specify multiple types for a function parameter. Here&#x27;s an example:
```python
from typing import overload

@overload
def greet(name: str) -&gt; None:
    ...

@overload
def greet(names: tuple[str, ...]) -&gt; None:
    ...
```
This code is useful when you want to define multiple versions of the same function with different parameter types.

### Using the ` ParamSpec` Type

The `ParamSpec` type allows you to specify a set of parameters for a function or method. Here&#x27;s an example:
```python
from typing import ParamSpec

P = ParamSpec(&quot;params&quot;)

def greet(name: P) -&gt; None:
    print(f&quot;Hello, {name}!&quot;)
```
This code is useful when you want to define a function or method with a variable number of parameters.

### Using the ` Generic` Type

The `Generic` type allows you to specify generic types for a class or function. Here&#x27;s an example:
```python
from typing import Generic, TypeVar

T = TypeVar(&quot;T&quot;)

class Container(Generic[T]):
    def __init__(self, value: T) -&gt; None:
        self.value = value

    def get_value(self) -&gt; T:
        return self.value
```
This code is useful when you want to define a class that works with any type of data.

### Using the ` ClassVar` Type

The `ClassVar` type allows you to specify a variable that should be stored as an attribute of a class. Here&#x27;s an example:
```python
from typing import ClassVar

class Person:
    _age: ClassVar[int] = 0

    def __init__(self, age: int) -&gt; None:
        self._age = age

    @property
    def age(self) -&gt; int:
        return self._age
```
This code is useful when you want to define a class that has a variable that should be shared across all instances of the class.
</code></pre>

<h3 id='standard_library_documents/Development Tools/test.support - Utilities for the Python test suite.md'>test.support - Utilities for the Python test suite.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># test.support — Utilities for the Python test suite

**test.support Module**
======================

The `test.support` module provides various utilities and tools for the Python test suite.

### Importing the Module

```python
import unittest
from test import support
```

### 1. SubTest Class

The `SubTest` class allows you to create a sub-test that can fail independently of the parent test case.

```python
# Create a SubTest object
sub_test = support.SubTest()

# Run some setup code within the sub-test
with sub_test.context():
    # Setup code here...
    pass

# Now you can use the setup code and assert statements within the sub-test
with sub_test.assert_called_once_with(&quot;some_arg&quot;):
    # Code that calls the function being tested with &quot;some_arg&quot;
    pass
```

### 2. test.cases.TestCase Class

The `TestCase` class is a base class for creating test cases in Python.

```python
class MyTest(TestCase):
    def setUp(self):
        self.setup_code()

    def test_my_method(self):
        # Test code here...
        self.assertEqual(my_function(), &quot;some_value&quot;)
```

### 3. test.result.TestResult Class

The `TestResult` class is used to report the results of tests.

```python
class MyTestResult(support.TestResult):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Initialize any custom attributes you need here...

test_result = MyTestResult()
# Use test_result to report test results
```

### 4. test.discovery.Discover Class

The `Discover` class is used to discover tests in a package.

```python
import unittest
from test import discovery

discover.run(module=&quot;path.to.my.module&quot;, test_path=[r&quot;test.*&quot;])
```

### 5. test.functional.FunctionalTestSuite Class

The `FunctionalTestSuite` class is used for functional testing of Python applications.

```python
from test import functional

# Create a FunctionalTestSuite object
suite = functional.FunctionalTestSuite(&quot;path.to.my.test&quot;)

# Run the tests in the suite
suite.run()
```

### 6. test.suite.TestSuite Class

The `TestSuite` class is used to create a suite of test cases.

```python
from test import suite

# Create a TestSuite object
suite = suite.TestSuite()

# Add test cases to the suite
suite.addTest(MyTest(&quot;test_case_1&quot;))
suite.addTest(MyTest(&quot;test_case_2&quot;))

# Run the tests in the suite
suite.run()
```

### 7. test.runner.TextTestRunner Class

The `TextTestRunner` class is used to run a test suite and report results.

```python
from test import runner

# Create a TextTestRunner object
runner = runner.TextTestRunner()

# Run the tests
runner.run(MyTest())
```

### 8. test.runner.TestResult Class

The `TestResult` class is used to report the results of tests in text format.

```python
class MyTestResult(support.TestResult):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Initialize any custom attributes you need here...

test_result = MyTestResult()
# Use test_result to report test results
```

### 9. test.monkeypatch.MonkeyPatch Class

The `MonkeyPatch` class is used to patch functions and objects during testing.

```python
from test import monkeypatch

def my_function():
    return &quot;some_value&quot;

with monkeypatch.context() as mp:
    # Patch the function being tested
    mp.setattr(my_function, &quot;_value&quot;, &quot;new_value&quot;)

    # Now you can use the patched function
    result = my_function()
    self.assertEqual(result, &quot;new_value&quot;)
```

### 10. test.monkeypatch.Mocker Class

The `Mocker` class is used to create mock objects during testing.

```python
from test import monkeypatch

def my_function():
    return &quot;some_value&quot;

with monkeypatch.context() as mp:
    # Create a mock object for the function being tested
    mp.create_mock(my_function)

    # Now you can use the mock object
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 11. test.mock.Mock Object

The `Mock` class is used to create mock objects during testing.

```python
from test import mock

my_mock = mock.Mock()

# Set attributes on the mock object
my_mock.return_value = &quot;some_value&quot;

# Now you can use the mock object
result = my_mock()
self.assertEqual(result, &quot;some_value&quot;)
```

### 12. test.mock.patch.Patch Class

The `Patch` class is used to patch functions and objects during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

with patch(&quot;path.to.my.function&quot;, my_mock):
    # Now you can use the patched function
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 13. test.mock.patch.PatchContext Class

The `PatchContext` class is used to create a context for patching functions and objects during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

with patch(&quot;path.to.my.function&quot;) as mp:
    # Now you can use the patched function
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 14. test.mock.patch.PatchDict Class

The `PatchDict` class is used to create a dictionary of patches for functions and objects during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.function&quot;: my_mock}

with patch(patches):
    # Now you can use the patched function
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 15. test.mock.patch.PatchFunc Class

The `PatchFunc` class is used to create a dictionary of patches for functions and objects during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.function&quot;: my_mock}

with patch(patches):
    # Now you can use the patched function
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 16. test.mock.patch.PatchClass Class

The `PatchClass` class is used to create a dictionary of patches for classes and objects during testing.

```python
from test import patch

class MyClass:
    def __init__(self):
        pass

my_mock = mock.Mock()

patches = {&quot;path.to.my.Class&quot;: my_mock}

with patch(patches):
    # Now you can use the patched class
    obj = MyClass()
```

### 17. test.mock.patch.PatchDictClass Class

The `PatchDictClass` class is used to create a dictionary of patches for classes and objects during testing.

```python
from test import patch

class MyClass:
    def __init__(self):
        pass

my_mock = mock.Mock()

patches = {&quot;path.to.my.Class&quot;: my_mock}

with patch(patches):
    # Now you can use the patched class
    obj = MyClass()
```

### 18. test.mock.patch.PatchModule Class

The `PatchModule` class is used to create a dictionary of patches for modules during testing.

```python
from test import patch

my_module = mock.Mock()

patches = {&quot;path.to.my.module&quot;: my_mock}

with patch(patches):
    # Now you can use the patched module
    obj = my_module()
```

### 19. test.mock.patch.PatchModuleClass Class

The `PatchModuleClass` class is used to create a dictionary of patches for modules and classes during testing.

```python
from test import patch

my_module = mock.Mock()

patches = {&quot;path.to.my.module&quot;: my_mock}

with patch(patches):
    # Now you can use the patched module
    obj = my_module()
```

### 20. test.mock.patch.PatchFunctionClass Class

The `PatchFunctionClass` class is used to create a dictionary of patches for functions and classes during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

my_mock = mock.Mock()

patches = {&quot;path.to.my.function&quot;: my_mock}

with patch(patches):
    # Now you can use the patched function
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 21. test.mock.patch.PatchVariable Class

The `PatchVariable` class is used to create a dictionary of patches for variables during testing.

```python
from test import patch

my_variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_variable
    self.assertEqual(result, &quot;some_value&quot;)
```

### 22. test.mock.patch.PatchClassVariable Class

The `PatchClassVariable` class is used to create a dictionary of patches for variables in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 23. test.mock.patch.PatchFunctionVariable Class

The `PatchFunctionVariable` class is used to create a dictionary of patches for variables in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 24. test.mock.patch.PatchVariableDict Class

The `PatchVariableDict` class is used to create a dictionary of patches for dictionaries during testing.

```python
from test import patch

my_dict = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_dict
    self.assertEqual(result, &quot;some_value&quot;)
```

### 25. test.mock.patch.PatchClassDict Class

The `PatchClassDict` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 26. test.mock.patch.PatchFunctionDict Class

The `PatchFunctionDict` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 27. test.mock.patch.PatchVariableList Class

The `PatchVariableList` class is used to create a dictionary of patches for lists during testing.

```python
from test import patch

my_list = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_list
    self.assertEqual(result, &quot;some_value&quot;)
```

### 28. test.mock.patch.PatchClassList Class

The `PatchClassList` class is used to create a dictionary of patches for lists in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 29. test.mock.patch.PatchFunctionList Class

The `PatchFunctionList` class is used to create a dictionary of patches for lists in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 30. test.mock.patch.PatchVariableSet Class

The `PatchVariableSet` class is used to create a dictionary of patches for sets during testing.

```python
from test import patch

my_set = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_set
    self.assertEqual(result, &quot;some_value&quot;)
```

### 31. test.mock.patch.PatchClassSet Class

The `PatchClassSet` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 32. test.mock.patch.PatchFunctionSet Class

The `PatchFunctionSet` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 33. test.mock.patch.PatchVariableTuple Class

The `PatchVariableTuple` class is used to create a dictionary of patches for tuples during testing.

```python
from test import patch

my_tuple = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_tuple
    self.assertEqual(result, &quot;some_value&quot;)
```

### 34. test.mock.patch.PatchClassTuple Class

The `PatchClassTuple` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 35. test.mock.patch.PatchFunctionTuple Class

The `PatchFunctionTuple` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 36. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 37. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 38. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 39. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 40. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 41. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 42. test.mock.patch.PatchVariableListClass Class

The `PatchVariableListClass` class is used to create a dictionary of patches for lists in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 43. test.mock.patch.PatchFunctionListClass Class

The `PatchFunctionListClass` class is used to create a dictionary of patches for lists in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 44. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 45. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 46. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 47. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 48. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 49. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 50. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 51. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 52. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 53. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 54. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 55. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 56. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 57. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 58. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 59. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 60. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 61. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 62. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 63. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 64. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 65. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 66. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 67. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 68. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 69. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 70. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 71. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 72. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 73. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 74. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 75. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 76. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 77. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 78. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 79. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 80. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 81. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 82. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 83. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 84. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 85. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 86. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 87. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 88. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 89. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 90. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 91. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 92. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 93. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 94. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 95. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 96. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 97. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 98. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 99. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 100. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 101. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 102. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 103. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 104. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 105. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 106. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 107. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 108. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 109. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 110. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 111. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 112. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 113. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 114. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 115. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 116. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 117. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 118. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 119. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 120. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 121. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 122. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 123. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 124. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 125. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 126. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 127. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 128. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 129. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 130. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 131. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 132. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 133. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 134. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 135. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 136. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 137. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 138. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 139. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 140. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 141. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 142. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 143. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 144. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 145. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 146. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 147. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 148. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 149. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 150. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 151. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 152. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 153. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 154. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 155. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 156. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 157. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 158. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 159. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 160. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 161. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 162. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 163. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 164. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 165. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 166. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 167. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 168. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 169. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 170. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 171. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 172. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 173. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 174. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 175. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 176. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 177. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 178. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 179. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 180. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 181. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 182. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 183. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 184. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 185. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 186. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 187. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 188. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 189. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 190. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 191. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 192. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 193. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 194. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 195. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 196. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 197. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 198. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 199. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 200. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 201. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 202. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 203. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 204. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 205. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 206. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 207. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 208. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 209. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 210. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 211. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 212. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 213. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 214. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 215. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 216. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 217. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 218. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 219. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 220. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 221. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 222. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 223. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 224. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 225. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 226. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 227. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 228. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 229. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 230. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 231. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 232. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 233. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 234. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 235. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 236. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 237. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 238. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 239. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 240. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 241. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 242. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 243. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 244. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 245. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 246. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 247. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 248. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 249. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 250. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 251. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 252. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 253. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 254. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 255. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 256. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 257. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 258. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 259. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 260. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 261. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 262. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 263. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 264. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 265. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 266. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 267. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 268. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 269. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 270. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 271. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 272. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 273. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 274. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 275. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 276. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 277. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 278. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 279. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 280. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 281. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 282. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 283. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 284. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 285. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 286. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 287. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 288. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 289. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 290. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 291. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 292. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 293. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 294. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 295. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 296. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 297. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 298. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 299. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 300. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 301. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 302. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 303. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 304. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 305. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 306. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 307. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 308. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 309. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 310. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 311. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 312. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 313. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 314. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 315. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 316. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 317. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 318. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 319. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 320. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 321. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 322. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 323. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 324. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 325. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 326. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 327. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 328. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 329. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 330. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 331. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 332. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 333. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 334. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 335. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 336. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 337. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 338. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 339. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 340. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 341. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 342. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 343. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 344. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 345. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 346. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 347. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 348. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 349. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 350. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 351. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 352. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 353. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 354. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 355. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 356. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 357. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 358. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 359. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 360. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 361. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 362. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 363. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 364. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 365. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 366. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 367. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 368. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 369. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 370. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 371. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 372. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 373. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 374. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 375. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 376. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 377. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 378. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 379. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 380. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 381. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 382. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 383. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 384. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 385. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 386. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 387. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 388. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 389. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 390. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 391. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 392. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 393. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 394. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 395. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 396. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 397. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 398. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 399. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 400. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 401. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 402. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 403. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 404. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 405. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 406. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 407. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 408. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 409. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 410. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 411. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 412. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 413. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 414. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 415. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 416. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 417. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 418. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 419. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 420. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 421. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 422. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 423. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 424. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 425. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 426. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 427. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 428. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 429. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 430. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 431. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 432. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 433. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 434. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 435. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 436. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 437. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 438. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 439. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 440. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 441. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 442. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 443. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 444. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 445. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 446. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 447. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 448. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 449. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 450. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 451. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 452. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 453. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 454. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 455. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 456. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 457. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 458. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 459. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 460. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 461. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 462. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 463. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 464. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 465. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 466. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 467. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 468. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 469. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 470. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 471. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 472. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 473. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 474. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 475. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 476. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 477. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 478. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 479. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 480. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 481. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 482. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 483. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 484. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 485. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 486. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 487. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 488. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 489. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 490. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 491. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 492. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 493. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 494. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 495. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 496. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 497. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 498. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 499. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 500. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 501. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 502. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 503. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 504. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 505. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 506. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 507. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 508. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 509. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 510. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 511. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 512. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 513. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 514. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 515. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 516. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 517. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 518. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 519. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 520. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 521. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 522. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 523. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 524. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 525. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 526. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 527. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 528. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 529. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 530. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 531. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 532. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 533. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 534. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 535. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 536. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 537. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 538. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 539. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 540. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 541. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 542. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 543. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 544. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 545. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 546. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 547. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 548. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 549. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 550. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 551. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 552. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 553. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 554. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 555. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 556. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 557. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 558. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 559. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 560. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 561. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 562. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 563. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 564. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 565. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 566. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 567. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 568. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 569. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 570. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 571. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 572. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 573. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 574. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 575. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 576. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 577. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 578. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 579. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 580. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 581. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 582. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 583. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 584. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 585. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 586. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 587. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 588. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 589. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 590. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 591. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 592. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 593. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 594. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 595. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 596. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 597. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 598. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 599. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 600. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 601. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 602. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 603. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 604. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 605. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 606. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 607. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 608. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 609. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 610. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 611. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 612. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 613. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 614. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 615. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 616. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 617. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 618. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 619. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 620. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 621. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 622. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 623. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 624. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 625. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 626. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 627. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 628. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 629. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 630. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 631. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 632. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 633. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 634. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 635. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 636. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 637. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 638. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 639. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 640. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 641. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 642. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 643. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 644. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 645. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 646. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 647. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 648. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 649. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 650. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 651. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 652. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 653. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 654. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 655. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 656. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 657. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 658. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 659. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 660. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 661. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 662. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 663. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 664. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 665. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 666. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 667. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 668. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 669. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 670. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 671. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 672. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 673. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 674. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 675. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 676. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 677. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 678. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 679. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 680. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 681. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 682. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 683. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 684. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 685. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 686. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 687. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 688. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 689. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 690. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 691. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 692. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 693. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 694. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 695. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 696. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 697. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 698. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 699. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 700. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 701. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 702. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 703. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 704. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 705. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 706. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 707. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 708. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 709. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 710. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 711. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 712. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 713. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 714. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 715. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 716. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 717. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 718. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 719. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 720. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 721. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 722. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 723. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 724. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 725. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 726. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 727. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 728. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 729. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 730. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 731. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 732. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 733. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 734. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 735. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 736. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 737. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 738. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 739. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 740. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 741. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 742. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 743. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 744. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 745. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 746. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 747. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 748. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 749. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 750. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 751. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 752. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 753. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 754. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 755. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 756. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 757. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 758. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 759. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 760. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 761. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 762. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 763. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 764. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 765. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 766. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 767. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 768. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 769. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 770. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 771. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 772. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 773. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 774. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 775. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 776. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 777. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 778. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 779. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 780. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 781. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 782. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 783. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 784. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 785. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 786. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 787. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 788. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 789. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 790. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 791. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 792. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 793. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 794. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 795. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 796. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 797. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 798. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 799. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 800. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 801. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 802. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 803. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 804. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 805. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 806. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 807. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 808. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 809. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 810. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 811. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 812. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 813. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 814. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 815. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 816. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 817. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 818. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 819. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 820. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 821. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 822. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 823. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 824. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 825. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 826. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 827. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 828. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 829. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 830. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 831. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 832. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 833. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 834. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 835. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 836. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 837. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 838. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 839. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 840. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 841. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 842. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 843. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 844. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 845. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 846. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 847. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 848. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 849. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 850. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 851. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 852. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 853. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 854. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 855. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 856. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 857. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 858. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 859. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 860. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 861. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 862. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 863. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 864. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 865. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 866. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 867. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 868. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 869. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 870. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 871. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 872. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 873. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 874. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 875. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 876. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 877. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 878. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 879. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 880. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 881. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 882. test.mock.patch.PatchVariableDictClass Class

The `PatchVariableDictClass` class is used to create a dictionary of patches for dictionaries in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 883. test.mock.patch.PatchFunctionDictClass Class

The `PatchFunctionDictClass` class is used to create a dictionary of patches for dictionaries in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 884. test.mock.patch.PatchVariableSetClass Class

The `PatchVariableSetClass` class is used to create a dictionary of patches for sets in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 885. test.mock.patch.PatchFunctionSetClass Class

The `PatchFunctionSetClass` class is used to create a dictionary of patches for sets in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    result = my_function()
    self.assertEqual(result, &quot;some_value&quot;)
```

### 886. test.mock.patch.PatchVariableTupleClass Class

The `PatchVariableTupleClass` class is used to create a dictionary of patches for tuples in classes during testing.

```python
from test import patch

class MyClass:
    variable = mock.Mock()

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches):
    # Now you can use the patched variable
    obj = MyClass()
```

### 887. test.mock.patch.PatchFunctionTupleClass Class

The `PatchFunctionTupleClass` class is used to create a dictionary of patches for tuples in functions during testing.

```python
from test import patch

def my_function():
    return &quot;some_value&quot;

patches = {&quot;path.to.my.variable&quot;: my_variable}

with patch(patches
</code></pre>

<h3 id='standard_library_documents/Development Tools/2to3 - Automated Python 2 to 3 code translation.md'>2to3 - Automated Python 2 to 3 code translation.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># 2to3 — Automated Python 2 to 3 code translation

Here are some examples of what can be done using the `2to3` module from the standard library:

```python
# Importing the 2to3 module
from 2to3 import fix_code

def translate_to_3():
    # Writing a simple Python expression to convert
    expr = &quot;print &#x27;Hello World!&#x27;&quot;

    # Fixing the code using 2to3
    fixed_expr = fix_code(expr, None, None)

    print(f&quot;Original Expression: {expr}&quot;)
    print(f&quot;Fixed Expression: {fixed_expr}&quot;)

# Translating a Python class to use __init__ and self
def translate_class():
    class MyClass:
        def __init__(self, x, y):
            pass

    # Using 2to3 to convert the class
    fixed_class = fix_code(&quot;class MyClass:\n    def __init__(self, x, y):\n        pass&quot;, None, None)

    print(f&quot;Original Class:\n{fixed_class}&quot;)

# Translating a Python function with default arguments
def translate_function():
    def add(x=0, y=0):
        return x + y

    # Using 2to3 to convert the function
    fixed_function = fix_code(&quot;def add(x=0, y=0):\n    return x + y&quot;, None, None)

    print(f&quot;Original Function:\n{fixed_function}&quot;)

# Translating a Python module using find_all_and_fix
def translate_module():
    # Find all and fix the code in a given module
    import os
    file_path = &quot;path_to_your_module.py&quot;

    if not os.path.exists(file_path):
        print(&quot;File does not exist.&quot;)
    elif not os.path.isfile(file_path):
        print(&quot;Path is not a file.&quot;)
    else:
        # Using 2to3 to fix the code in the module
        fixed_file = fix_code(open(file_path).read(), None, None)

        # Writing the fixed code back to the file
        with open(file_path, &quot;w&quot;) as f:
            f.write(fixed_file)
```

Here is how you can use it:

1.  Install `2to3` module if not already installed: You can install it via pip command.

    ```bash
pip install -U 2to3
```
2.  Usage of the above code examples and make necessary modifications according to your needs.
3.  To convert a specific Python file, you need to provide the path of that file. 

This is an overview of what can be done using `2to3` module from the standard library in python. For more information, refer to [Python&#x27;s Official Documentation for 2to3](https://docs.python.org/3/library/2to3/index.html).
</code></pre>

<h3 id='standard_library_documents/Development Tools/pydoc - Documentation generator and online help system.md'>pydoc - Documentation generator and online help system.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># pydoc — Documentation generator and online help system

Here&#x27;s an example of how you can use the `pydoc` module from the Python standard library to generate documentation and online help:

```python
import pydoc

def main():
    # Generate documentation for a module
    print(&quot;Generating documentation for the &#x27;math&#x27; module:&quot;)
    pydoc.generate_doc(&#x27;math&#x27;)
    
    # Get information about a specific function or class in the &#x27;math&#x27; module
    print(&quot;\nGetting info about the &#x27;sin&#x27; function in the &#x27;math&#x27; module:&quot;)
    doc = pydoc.getdoc(&#x27;math.sin&#x27;)
    if doc:
        print(doc)
    else:
        print(&quot;No documentation found for the &#x27;sin&#x27; function.&quot;)
    
    # Generate HTML help for a module
    print(&quot;\nGenerating HTML help for the &#x27;math&#x27; module:&quot;)
    pydoc.generate_html(&#x27;math&#x27;)
    
    # Get online help for a specific function or class in the &#x27;math&#x27; module
    print(&quot;\nGetting online help for the &#x27;cos&#x27; function in the &#x27;math&#x27; module:&quot;)
    import math  # Import the math module to use its functions
    try:
        doc = pydoc.getonline(&#x27;math.cos&#x27;)
        print(doc)
    except Exception as e:
        print(f&quot;Error getting online help: {e}&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

This example demonstrates how you can generate documentation, get information about specific functions or classes, and generate HTML help for a module using the `pydoc` module. It also shows how to import the `math` module to use its functions.

Here are some additional methods of the `pydoc` object:

*   `generate_doc(module_name)`: Generate documentation for the specified module.
*   `getdoc(object_name)`: Get information about a specific function or class in the specified module. Returns `None` if no documentation is found.
*   `generate_html(module_name)`: Generate HTML help for the specified module.
*   `getonline(object_name)`: Get online help for the specified function or class in the specified module. Returns `None` if no documentation is found.

Please note that these methods do not return any useful information when called with a module name as an argument, because the standard library&#x27;s `pydoc` module only supports getting info about functions and classes defined in modules, but not for modules themselves.

**Example Use Cases:**

*   Generating documentation for external libraries: The `pydoc` module can be used to generate documentation for external libraries that provide custom functionality.
*   Displaying help information for specific functions or classes: The `getdoc()` method can be used to display the docstring of a specific function or class, which provides a description of its behavior and usage.

**Commit Message Guidelines:**

*   Use the present tense (&quot;Generate documentation&quot; instead of &quot;Generated documentation&quot;).
*   Use the imperative mood (i.e., use commands that tell others what to do).
*   Keep it concise and focused on the changes made.
*   Avoid using unnecessary words or phrases.
</code></pre>

<h3 id='standard_library_documents/Development Tools/doctest - Test interactive Python examples.md'>doctest - Test interactive Python examples.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># doctest — Test interactive Python examples

**doctest Module**
====================

The `doctest` module provides a way to run interactive Python examples as test cases.

### Installation

You don&#x27;t need to install anything, as this is a standard library module in Python.

### Example Use Cases

1. **Running doctests**: You can use the `doctest` module to run your interactive Python examples as tests.
2. **Writing custom test cases**: You can write your own test cases using the `doctest` module.

### Code Examples
```python
import doctest

# Interactive example from the docstring of a function
def greet(name):
    &quot;&quot;&quot;Prints out a personalized greeting.&quot;&quot;&quot;
    print(f&quot;Hello, {name}!&quot;)

def main():
    # Running the interactive example as a test case
    result = doctest.testmod(greet)
    if result.failures:
        print(&quot;Test cases failed:&quot;, result.failures)

if __name__ == &quot;__main__&quot;:
    main()
```

### Explanation

In this code:

1. We import the `doctest` module.
2. We define a simple function `greet` that prints out a personalized greeting.
3. The docstring of the `greet` function is used as a test case to verify its correctness.
4. In the `main` function, we use `doctest.testmod(greet)` to run the interactive example as a test case.
5. If any test cases fail, their failure messages are printed out.

### Additional Example: Writing Custom Test Cases

```python
import doctest

# Interactive example from the docstring of a function
def add(a, b):
    &quot;&quot;&quot;Returns the sum of two numbers.&quot;&quot;&quot;
    return a + b

def main():
    # Writing our own test case
    def test_add():
        result = add(2, 3)
        assert result == 5, &quot;Test failed&quot;
        print(&quot;Addition test passed&quot;)

    # Running our custom test case
    doctest.testmod(add, module=&#x27;test_add&#x27;, optionflags=doctest.ELLIPSIS)

if __name__ == &quot;__main__&quot;:
    main()
```

### Explanation

In this code:

1. We import the `doctest` module.
2. We define a simple function `add` that returns the sum of two numbers.
3. In the `main` function, we write our own test case using a custom function `test_add`.
4. We use `doctest.testmod(add, ...)`, specifying our custom test case and some additional options (`optionflags=doctest.ELLIPSIS`).
</code></pre>

<h3 id='standard_library_documents/Development Tools/test - Regression tests package for Python.md'>test - Regression tests package for Python.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># test — Regression tests package for Python

Here&#x27;s an example of how you can use the `unittest` framework, which is part of the Python Standard Library, to write regression tests for a given module.

```python
# Import the unittest framework from the standard library
import unittest

# Define a function to test the &#x27;math&#x27; module
class TestMathFunctions(unittest.TestCase):

    # Test if the sqrt function returns the correct result for positive numbers
    def test_sqrt_positive_number(self):
        self.assertAlmostEqual(math.sqrt(4), 2)
    
    # Test if the sqrt function returns a ValueError for non-positive numbers
    def test_sqrt_non_positive_number(self):
        with self.assertRaises(ValueError):
            math.sqrt(-1)

# Define another function to test the &#x27;os&#x27; module
class TestOsFunctions(unittest.TestCase):

    # Test if the system() function calls the correct shell command
    def test_system_command_execution(self):
        self.assertEqual(os.system(&#x27;ls -l&#x27;), 0)
    
    # Test if the system() function raises an exception when the command fails
    def test_system_command_failure(self):
        with self.assertRaises(Exception):
            os.system(&#x27;non-existent-command&#x27;)

# Run all tests in the TestMathFunctions and TestOsFunctions classes
if __name__ == &#x27;__main__&#x27;:
    unittest.main()
```

However, to generate a complete code example for every possible thing that can be done in the `unittest` module from the standard library, here&#x27;s an example of how you could do it programmatically:

```python
import unittest

# List of test cases to cover
test_cases = [
    # Testing the &#x27;math&#x27; module
    {
        &quot;module&quot;: &quot;math&quot;,
        &quot;functions&quot;: [&quot;sqrt&quot;, &quot;ceil&quot;, &quot;floor&quot;],
        &quot;test_methods&quot;: [
            &quot;test_sqrt_positive_number&quot;,
            &quot;test_sqrt_non_positive_number&quot;
        ]
    },
    
    # Testing the &#x27;os&#x27; module
    {
        &quot;module&quot;: &quot;os&quot;,
        &quot;functions&quot;: [&quot;system&quot;, &quot;getenv&quot;],
        &quot;test_methods&quot;: [
            &quot;test_system_command_execution&quot;,
            &quot;test_system_command_failure&quot;
        ]
    }
]

# Initialize a test suite and runner
suite = unittest.TestSuite()
runner = unittest.TextTestRunner()

# Loop over each test case and add it to the test suite
for test_case in test_cases:
    class TestModuleFunctions(unittest.TestCase):
        for function in test_case[&quot;functions&quot;]:
            def test_function(self):
                # Add a placeholder function body (replace with actual implementation)
                pass
    suite.addTest(TestModuleFunctions())

# Run the test suite and display results
runner.run(suite)
```

This example uses a list of dictionaries to define different test cases for various modules from the standard library. Each dictionary specifies the module name, a list of functions to test, and a list of corresponding test methods.

Note that in practice, you&#x27;d need to replace the placeholder function bodies with actual implementations of your tests.
</code></pre>

<h3 id='standard_library_documents/Development Tools/unittest - Unit testing framework.md'>unittest - Unit testing framework.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># unittest — Unit testing framework

**Unit Testing Framework: `unittest`**
=====================================

The `unittest` module is a built-in Python framework for writing and running unit tests.

### Example 1: Basic Usage
```python
import unittest

def add_numbers(a, b):
    &quot;&quot;&quot;Return the sum of two numbers.&quot;&quot;&quot;
    return a + b

class TestAddNumbers(unittest.TestCase):
    def test_add_positive_numbers(self):
        &quot;&quot;&quot;Test adding positive numbers.&quot;&quot;&quot;
        self.assertEqual(add_numbers(2, 3), 5)

    def test_add_negative_numbers(self):
        &quot;&quot;&quot;Test adding negative numbers.&quot;&quot;&quot;
        self.assertEqual(add_numbers(-2, -3), -5)

    def test_add_mixed_numbers(self):
        &quot;&quot;&quot;Test adding a mix of positive and negative numbers.&quot;&quot;&quot;
        self.assertEqual(add_numbers(-2, 3), 1)

if __name__ == &#x27;__main__&#x27;:
    unittest.main()
```
### Explanation

* We define a simple `add_numbers` function that takes two arguments.
* We create a test class `TestAddNumbers` that inherits from `unittest.TestCase`.
* In the `test_add_positive_numbers`, `test_add_negative_numbers`, and `test_add_mixed_numbers` methods, we use the `assertEqual` method to verify that our `add_numbers` function behaves as expected.

### Example 2: Using Assert Methods
```python
import unittest

def add_numbers(a, b):
    &quot;&quot;&quot;Return the sum of two numbers.&quot;&quot;&quot;
    return a + b

class TestAddNumbers(unittest.TestCase):
    def test_add_positive_numbers(self):
        # Use assertEqual to check for equality
        self.assertEqual(add_numbers(2, 3), 5)

    def test_add_negative_numbers(self):
        # Use assertNotEqual to check for inequality
        self.assertNotEqual(add_numbers(-2, -3), -1)
        # Use assertTrue to check for truthiness
        self.assertTrue(add_numbers(-2, 0) &gt; 0)

if __name__ == &#x27;__main__&#x27;:
    unittest.main()
```
### Explanation

* We use different `assert` methods to verify our test cases:
	+ `assertEqual`: checks if two values are equal.
	+ `assertNotEqual`: checks if two values are not equal.
	+ `assertTrue`: checks if a value is true (non-zero, non-empty string, etc.).

### Example 3: Testing Exceptions
```python
import unittest

def divide_numbers(a, b):
    &quot;&quot;&quot;Return the quotient of two numbers.&quot;&quot;&quot;
    if b == 0:
        raise ValueError(&quot;Cannot divide by zero!&quot;)
    return a / b

class TestDivideNumbers(unittest.TestCase):
    def test_divide_positive_numbers(self):
        # Use assertRaises to check for exception
        with self.assertRaises(ValueError):
            divide_numbers(2, 3)

    def test_divide_zero(self):
        # Use assertIsNone to check if value is None
        self.assertIsNone(divide_numbers(0, 0))

if __name__ == &#x27;__main__&#x27;:
    unittest.main()
```
### Explanation

* We define a `divide_numbers` function that raises a `ValueError` when dividing by zero.
* In the `test_divide_positive_numbers` and `test_divide_zero` methods, we use `assertRaises` to check if our function raises the expected exception when divided by zero.
</code></pre>

<h3 id='standard_library_documents/Development Tools/unittest.mock - getting started.md'>unittest.mock - getting started.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># unittest.mock — getting started

Here&#x27;s an example of how you can use `unittest.mock` to mock objects, functions, and modules:

**Mocking Objects**

```python
import unittest
from unittest import mock

# Create a mock object
def add(a, b):
    return a + b

class TestAddFunction(unittest.TestCase):

    # Mock the function we want to test
    @mock.patch(&#x27;my_module.add&#x27;)
    def test_add(self, mock_add):
        # Set up the mock to return a specific value when called
        mock_add.return_value = 10
        
        # Call the function being tested with some arguments
        result = add(2, 3)
        
        # Assert that the returned value is correct
        self.assertEqual(result, 5)

    # Test case where we don&#x27;t call the function (should raise an error)
    @mock.patch(&#x27;my_module.add&#x27;)
    def test_add_not_called(self, mock_add):
        with self.assertRaises(RecursionError):
            add(2, 3)
```

**Mocking Functions**

```python
import unittest
from unittest import mock

class TestPrintFunction(unittest.TestCase):

    # Mock the function we want to test
    @mock.patch(&#x27;builtins.print&#x27;)
    def test_print(self, mock_print):
        # Set up the mock to print a specific message when called
        mock_print.return_value = None
        
        # Call the function being tested with some arguments
        print(&quot;Hello, world!&quot;)
        
        # Assert that the printed message is correct
        self.assertEqual(mock_print.call_args, (&#x27;Hello, world!&#x27;,))

    # Test case where we don&#x27;t call the function (should raise an error)
    @mock.patch(&#x27;builtins.print&#x27;)
    def test_print_not_called(self, mock_print):
        with self.assertRaises(RecursionError):
            print(&quot;Hello, world!&quot;)
```

**Mocking Modules**

```python
import unittest
from unittest import mock

class TestRandomModule(unittest.TestCase):

    # Mock the module we want to test
    @mock.patch(&#x27;random&#x27;)
    def test_random(self, mock_random):
        # Set up the mock to return a specific value when called
        mock_random.randint.return_value = 42
        
        # Call the function being tested with some arguments
        import random
        result = random.randint(1, 100)
        
        # Assert that the returned value is correct
        self.assertEqual(result, 42)

    # Test case where we don&#x27;t call the function (should raise an error)
    @mock.patch(&#x27;random&#x27;)
    def test_random_not_called(self, mock_random):
        with self.assertRaises(RecursionError):
            import random
```

**Mocking Exceptions**

```python
import unittest
from unittest import mock

class TestRaiseException(unittest.TestCase):

    # Mock the exception we want to raise
    @mock.patch(&#x27;ValueError&#x27;)
    def test_raise_exception(self, mock_value_error):
        # Set up the mock to raise an exception when called
        mock_value_error.side_effect = ValueError(&quot;Something went wrong!&quot;)
        
        # Call the function being tested with some arguments
        with self.assertRaises(ValueError):
            raise ValueError(&quot;Something went wrong!&quot;)

    # Test case where we don&#x27;t call the function (should not raise an error)
    @mock.patch(&#x27;ValueError&#x27;)
    def test_raise_exception_not_called(self, mock_value_error):
        with self.assertRaises(RecursionError):
            raise ValueError
```

**Mocking Context Managers**

```python
import unittest
from unittest import mock

class TestContextManager(unittest.TestCase):

    # Mock the context manager we want to test
    @mock.patch(&#x27;contextlib.contextmanager&#x27;)
    def test_context_manager(self, mock_contextmanager):
        # Set up the mock to yield a specific value when called
        mock_contextmanager.return_value.__enter__.return_value = &quot;Hello&quot;
        
        # Call the function being tested with some arguments
        with self.assertRaises(RecursionError):
            yield from &quot;Hello&quot;

    # Test case where we don&#x27;t call the function (should not raise an error)
    @mock.patch(&#x27;contextlib.contextmanager&#x27;)
    def test_context_manager_not_called(self, mock_contextmanager):
        with self.assertRaises(RecursionError):
            import contextlib
```

**Mocking Decorators**

```python
import unittest
from unittest import mock

class TestDecorator(unittest.TestCase):

    # Mock the decorator we want to test
    @mock.patch(&#x27;functools.wraps&#x27;)
    def test_decorator(self, mock_functor_wraps):
        # Set up the mock to return a specific value when called
        mock_functor_wraps.return_value = &quot;Hello&quot;
        
        # Call the function being tested with some arguments
        from functools import wraps
        @wraps(&quot;Hello&quot;)
        def hello(name):
            return f&quot;Hello, {name}!&quot;
        result = hello(&quot;world&quot;)
        
        # Assert that the returned value is correct
        self.assertEqual(result, &quot;Hello, world!&quot;)

    # Test case where we don&#x27;t call the function (should not raise an error)
    @mock.patch(&#x27;functools.wraps&#x27;)
    def test_decorator_not_called(self, mock_functor_wraps):
        with self.assertRaises(RecursionError):
            from functools import wraps
```
</code></pre>
<h2 id='Microsoft Windows Specific Services'>Microsoft Windows Specific Services</h2><ul><li><a href='#standard_library_documents/Microsoft Windows Specific Services/winreg - Windows registry access.md'>winreg - Windows registry access.md</a></li><li><a href='#standard_library_documents/Microsoft Windows Specific Services/winsound - Sound-playing interface for Windows.md'>winsound - Sound-playing interface for Windows.md</a></li><li><a href='#standard_library_documents/Microsoft Windows Specific Services/msvcrt - Useful routines from the MS VC  runtime.md'>msvcrt - Useful routines from the MS VC  runtime.md</a></li><li><a href='#standard_library_documents/Microsoft Windows Specific Services/msvcrt - Useful routines from the MS VC++ runtime.md'>msvcrt - Useful routines from the MS VC++ runtime.md</a></li></ul>
<h3 id='standard_library_documents/Microsoft Windows Specific Services/winreg - Windows registry access.md'>winreg - Windows registry access.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># winreg — Windows registry access

Here&#x27;s an example of how you can use the `winreg` module in Python:

**Accessing and Modifying Registry Values**
```python
import winreg

# Open the registry key
key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, &quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run&quot;, 0, winreg.KEY_READ | winreg.KEY_WRITE)

try:
    # Read the value of the &#x27;Python&#x27; key
    value, regtype = winreg.QueryValueEx(key, &quot;Python&quot;)
    print(f&quot;Current Python executable: {value}&quot;)

    # Modify the value of the &#x27;Python&#x27; key
    new_value = r&quot;C:\path\to\python.exe&quot;
    winreg.SetValueEx(key, &quot;Python&quot;, 0, winreg.REG_SZ, new_value)
except Exception as e:
    print(f&quot;Error accessing registry key: {e}&quot;)
finally:
    # Close the registry key
    winreg.CloseKey(key)
```

**Creating a New Registry Key**
```python
import winreg

# Create a new registry key
key = winreg.CreateKey(winreg.HKEY_LOCAL_MACHINE, &quot;SOFTWARE\\MyCompany\\Settings&quot;)

try:
    # Set a value in the new key
    regvalue = winreg.CreateValueEx(winreg.KEY_VALUE, b&quot;MySetting&quot;, 0, winreg.REG_SZ, b&quot;Hello World&quot;)
    winreg.SetValue(key, regvalue)
except Exception as e:
    print(f&quot;Error creating registry key: {e}&quot;)
finally:
    # Close the registry key
    winreg.CloseKey(key)
```

**Deleting a Registry Key**
```python
import winreg

# Open the registry key
key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, &quot;SOFTWARE\\MyCompany\\Settings&quot;, 0, winreg.KEY_READ | winreg.KEY_WRITE)

try:
    # Delete the value in the key
    winreg.DeleteValue(key, b&quot;MySetting&quot;)
except Exception as e:
    print(f&quot;Error deleting registry key: {e}&quot;)
finally:
    # Close the registry key
    winreg.CloseKey(key)
```

**Querying Registry Keys**
```python
import winreg

# Open a specific registry key
key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, &quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run&quot;, 0, winreg.KEY_READ)

try:
    # Iterate over the values in the key
    while True:
        value, regtype = winreg.QueryValueEx(key, None)
        if not value:
            break
        print(f&quot;Key: {value}&quot;)
except Exception as e:
    print(f&quot;Error querying registry key: {e}&quot;)
finally:
    # Close the registry key
    winreg.CloseKey(key)
```

Note that you&#x27;ll need to run your Python script with administrator privileges to access and modify the Windows registry.
</code></pre>

<h3 id='standard_library_documents/Microsoft Windows Specific Services/winsound - Sound-playing interface for Windows.md'>winsound - Sound-playing interface for Windows.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># winsound — Sound-playing interface for Windows

**winsound Module Code Examples**
=====================================

The `winsound` module provides an interface for playing sounds on Windows.

### Importing the Winsound Module

```python
import winsound
```

### Playing a Beep

You can play a beep by calling the `Beep` function. The first argument is the frequency and the second argument is the duration of the sound in milliseconds.

```python
# Play a 2500 Hz beep for 500 ms
winsound.Beep(2500, 500)
```

### Playing a Wave File

You can play a wave file by calling the `PlaySound` function. The first argument is the filename of the wave file and the second argument is a flag indicating whether to wait for the sound to finish playing.

```python
import winsound
import os

# Define the path to the wave file
wave_file = &quot;path_to_your_wave_file.wav&quot;

# Play the wave file with a delay after it finishes
winsound.PlaySound(wave_file, winsound.SND_FILENAME)
```

### Playing a Beep with Different Modes

You can play a beep in different modes by using the following flags:

*   `SND_ASYNC`: The sound plays asynchronously.
*   `SND_WAITFINISH`: The function waits for the sound to finish playing.
*   `SND_NOREMOVE`: No error is returned if the file does not exist.

```python
# Play a 2500 Hz beep with synchronous mode and wait for it to finish
winsound.Beep(2500, 500, winsound.SND_WAITFINISH)

# Play a 2500 Hz beep with asynchronous mode
winsound.Beep(2500, 500, winsound.SND_ASYNC)
```

### Playing a Beep Without Removing Error

You can play a beep without removing the error by using the `SND_NOREMOVE` flag.

```python
# Play a 2500 Hz beep with no remove error
winsound.Beep(2500, 500, winsound.SND_NOREMOVE)
```

### Playing a Beep With Multiple Frequencies

You can play a beep with multiple frequencies by using the `Beep` function multiple times.

```python
# Play a 2000 Hz and 3000 Hz beep for 100 ms each
winsound.Beep(2000, 100)
winsound.Beep(3000, 100)
```

### Playing a Beep Without Delay

You can play a beep without delay by using the `PlaySound` function.

```python
import winsound
import os

# Define the path to the wave file
wave_file = &quot;path_to_your_wave_file.wav&quot;

# Play the wave file without delay
winsound.PlaySound(wave_file, 0)
```

### Playing a Beep With Volume Control

You can play a beep with volume control by using the `SetVolume` function.

```python
import winsound
import ctypes

# Get the handle to the sound device
handle = ctypes.windll.mmxctrl.mmOpenDevice(0)

# Set the initial volume to 100%
volume = winsound.SetVolume(handle, 100)

# Play a 2500 Hz beep with a volume of 50%
winsound.Beep(2500, 500, volume)
```
</code></pre>

<h3 id='standard_library_documents/Microsoft Windows Specific Services/msvcrt - Useful routines from the MS VC  runtime.md'>msvcrt - Useful routines from the MS VC  runtime.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># msvcrt - Useful routines from the MS VC++ runtime

Here are some useful code examples using the `msvcrt` module from the Python Standard Library.

**Getting User Input**
```python
import msvcrt

# Get user input without echoing to the console
input_str = msvcrt.getch().decode(&#x27;utf-8&#x27;).strip()
print(&quot;You entered:&quot;, input_str)
```

**Checking for Keyboard Presses**
```python
import msvcrt

while True:
    # Check if a key is pressed
    if msvcrt.kbhit():
        # Get the pressed key
        key = msvcrt.getche().decode(&#x27;utf-8&#x27;).strip()
        print(&quot;Key pressed:&quot;, key)
```

**Getting Character from Keyboard without Echoing**
```python
import msvcrt

char = msvcrt.getch().decode(&#x27;utf-8&#x27;)
print(&quot;You entered character:&quot;, char)
```

**Reading a Whole Line from Keyboard without Echoing**
```python
import msvcrt

line = msvcrt.getwcha()
print(&quot;You entered line:&quot;, line.decode(&#x27;utf-8&#x27;))
```

**Waiting for Enter Key Press**
```python
import msvcrt
import time

# Wait for the enter key press
input(&quot;Press Enter to continue...&quot;)

# Check if a key is pressed
if msvcrt.kbhit():
    # Get the pressed key
    key = msvcrt.getche().decode(&#x27;utf-8&#x27;).strip()
    print(&quot;Key pressed:&quot;, key)
```

**Clearing Screen**
```python
import os
import msvcrt

# Clear the screen
os.system(&#x27;cls&#x27; if os.name == &#x27;nt&#x27; else &#x27;clear&#x27;)

# Print some text to clear the screen
print(&quot;Press Enter to continue...&quot;)
msvcrt.getch()
```
Please note that `msvcrt` is not a part of Python&#x27;s standard library, it&#x27;s included in Windows API. If you are using a non-Windows operating system, you will need to use alternative libraries or implement these functionalities manually.

This examples demonstrate how the `msvcrt` module can be used for various tasks related to keyboard input and output on Windows platforms.
</code></pre>

<h3 id='standard_library_documents/Microsoft Windows Specific Services/msvcrt - Useful routines from the MS VC++ runtime.md'>msvcrt - Useful routines from the MS VC++ runtime.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># msvcrt — Useful routines from the MS VC++ runtime

Here are some example code snippets for the `msvcrt` module:

```python
# Importing the msvcrt module
import msvcrt

# 1. Getting the current cursor position
def get_cursor_position():
    # Use the caret positioning function to get the current cursor position
    x, y = msvcrt.getyx()
    return (x, y)

print(get_cursor_position())

# 2. Handling keyboard input
def handle_keyboard_input():
    # Use a loop to continuously read from standard input until Ctrl+Z is pressed
    while True:
        try:
            key = msvcrt.getche().decode(&#x27;utf-8&#x27;)
            print(f&quot;Key pressed: {key}&quot;)
        except EOFError:
            break

handle_keyboard_input()

# 3. Getting the current cursor position using getyx() function
def get_cursor_position_yx():
    # Use the caret positioning function to get the current cursor position
    x, y = msvcrt.getyx()
    return f&quot;Cursor Position (X, Y): ({x}, {y})&quot;

print(get_cursor_position_yx())

# 4. Getting the terminal size
def get_terminal_size():
    # Use the cbreak() function to disable line buffering and ensure that the program receives the correct character count from the read() method
    msvcrt.cbreak()
    # Get the terminal size using the getyx() function
    x, y = msvcrt.getyx()
    # Return the terminal size as a tuple (width, height)
    return (x, y)

print(get_terminal_size())

# 5. Disabling cbreak mode
def disable_cbreak_mode():
    # Use the nodelay() function to enable line buffering and set the read timeout to -1
    msvcrt.nodelay(0, True)  # Set timeout to 0 seconds

disable_cbreak_mode()
```

These examples demonstrate various functions provided by the `msvcrt` module in Python, including handling keyboard input, getting cursor positions, terminal size, and more.
</code></pre>
<h2 id='Unix Specific Services'>Unix Specific Services</h2><ul><li><a href='#standard_library_documents/Unix Specific Services/nis - Interface to Sun’s NIS (Yellow Pages).md'>nis - Interface to Sun’s NIS (Yellow Pages).md</a></li><li><a href='#standard_library_documents/Unix Specific Services/pipes - Interface to shell pipelines.md'>pipes - Interface to shell pipelines.md</a></li><li><a href='#standard_library_documents/Unix Specific Services/tty - Terminal control functions.md'>tty - Terminal control functions.md</a></li><li><a href='#standard_library_documents/Unix Specific Services/syslog - Unix syslog library routines.md'>syslog - Unix syslog library routines.md</a></li><li><a href='#standard_library_documents/Unix Specific Services/nis - Interface to Sun s NIS (Yellow Pages).md'>nis - Interface to Sun s NIS (Yellow Pages).md</a></li><li><a href='#standard_library_documents/Unix Specific Services/grp - The group database.md'>grp - The group database.md</a></li><li><a href='#standard_library_documents/Unix Specific Services/pwd - The password database.md'>pwd - The password database.md</a></li><li><a href='#standard_library_documents/Unix Specific Services/termios - POSIX style tty control.md'>termios - POSIX style tty control.md</a></li><li><a href='#standard_library_documents/Unix Specific Services/resource - Resource usage information.md'>resource - Resource usage information.md</a></li><li><a href='#standard_library_documents/Unix Specific Services/fcntl - The fcntl and ioctl system calls.md'>fcntl - The fcntl and ioctl system calls.md</a></li><li><a href='#standard_library_documents/Unix Specific Services/spwd - The shadow password database.md'>spwd - The shadow password database.md</a></li><li><a href='#standard_library_documents/Unix Specific Services/posix - The most common POSIX system calls.md'>posix - The most common POSIX system calls.md</a></li><li><a href='#standard_library_documents/Unix Specific Services/crypt - Function to check Unix passwords.md'>crypt - Function to check Unix passwords.md</a></li><li><a href='#standard_library_documents/Unix Specific Services/pty - Pseudo-terminal utilities.md'>pty - Pseudo-terminal utilities.md</a></li></ul>
<h3 id='standard_library_documents/Unix Specific Services/nis - Interface to Sun’s NIS (Yellow Pages).md'>nis - Interface to Sun’s NIS (Yellow Pages).md</h3>
<button onclick="history.back()">Back</button>
<pre><code># nis — Interface to Sun’s NIS (Yellow Pages)

**nis Module Code Generation**
=====================================

The `nis` module provides an interface to Sun&#x27;s NIS (Yellow Pages), also known as the Network Information Service.

### Table of Contents

1. [Importing the nis module](#importing-the-nis-module)
2. [Loading a NIS database](#loading-a-nis-database)
3. [Searching for entries in a NIS database](#searching-for-entries-in-a-nis-database)
4. [Creating a NIS database](#creating-a-nis-database)
5. [Deleting a NIS database](#deleting-a-nis-database)

### Code Examples

#### Importing the nis module
```python
import nis

# Create an instance of the nis class
nis_db = nis.NIS()
```

#### Loading a NIS database
```python
# Load a existing NIS database from the default location ( /var/nis )
nis_db.load(&#x27;sun4c&#x27;)

# Load a specific NIS database with name &#x27;my_nis&#x27;
nis_db.load(&#x27;my_nis&#x27;)
```

#### Searching for entries in a NIS database
```python
# Search for all entries in the current database
entries = nis_db.getnames()

# Get a specific entry from the current database by name
entry = nis_db.getname(&#x27;MY_SERVICE&#x27;)

print(entries)
print(entry)
```

#### Creating a NIS database
```python
# Create a new NIS database with default configuration
nis_db.create_database()

# Create a new NIS database with custom configuration
nis_db.create_database(
    # Specify the name of the database
    name=&#x27;my_nis&#x27;,
    # Specify the password for the database
    passwd=&#x27;my_password&#x27;,
)
```

#### Deleting a NIS database
```python
# Delete the current NIS database
nis_db.delete_database()

# Delete a specific NIS database with name &#x27;my_nis&#x27;
nis_db.delete_database(&#x27;my_nis&#x27;)
```

### Full Code Example

```python
import nis

def main():
    # Create an instance of the nis class
    nis_db = nis.NIS()
    
    # Load a existing NIS database from the default location ( /var/nis )
    nis_db.load(&#x27;sun4c&#x27;)
    
    # Search for all entries in the current database
    entries = nis_db.getnames()
    
    print(&quot;Entries:&quot;)
    print(entries)
    
    # Get a specific entry from the current database by name
    entry = nis_db.getname(&#x27;MY_SERVICE&#x27;)
    
    print(&quot;\nEntry:&quot;)
    print(entry)
    
    # Create a new NIS database with default configuration
    nis_db.create_database()
    
    # Search for all entries in the newly created database
    entries_new = nis_db.getnames()
    
    print(&quot;New Entries:&quot;)
    print(entries_new)
    
if __name__ == &quot;__main__&quot;:
    main()

```

Note: This code examples are just a starting point, you should consider implementing proper error handling and security measures when working with NIS databases.
</code></pre>

<h3 id='standard_library_documents/Unix Specific Services/pipes - Interface to shell pipelines.md'>pipes - Interface to shell pipelines.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># pipes — Interface to shell pipelines

Here&#x27;s an example of how you can use the `pipes` interface from Python&#x27;s standard library:

```python
# Import the pipes module
import pipes

def pipe_example():
    # Create a pipe
    read_fd, write_fd = pipes.open()

    try:
        # Write to the pipe
        write_fd.write(b&quot;Hello, world!&quot;)
        
        # Read from the pipe
        data = read_fd.read()
        
        print(f&quot;Received: {data.decode()}&quot;)

    finally:
        # Close the pipe
        pipes.close(read_fd, write_fd)

# Create a pipe and use it to read from a file
def pipe_file_example():
    # Open a file for reading
    with open(&quot;example.txt&quot;, &quot;r&quot;) as f:
        # Create a pipe
        read_fd, write_fd = pipes.open()
        
        try:
            # Read data from the file into the pipe
            data = f.read()
            
            # Write data to the pipe
            write_fd.write(data)
            
            # Read data from the pipe back into the file
            read_data = read_fd.read()
            
            print(f&quot;File contents: {data}&quot;)
            print(f&quot;Pipe output: {read_data.decode()}&quot;)
        
        finally:
            # Close the pipe
            pipes.close(read_fd, write_fd)

pipe_example()
pipe_file_example()
```

Here&#x27;s a more complex example of piping data between multiple processes:

```python
# Import the pipes module and threading library
import pipes
import threading

def process_data(data):
    print(f&quot;Processing data: {data}&quot;)
    
    # Write the processed data to the pipe
    with open(&quot;output.txt&quot;, &quot;w&quot;) as f:
        f.write(data.decode())

def pipe_example():
    # Create a pipe
    read_fd, write_fd = pipes.open()
    
    # Read some example data from a file into the pipe
    with open(&quot;example.txt&quot;, &quot;r&quot;) as f:
        data = f.read()
        
        # Write the data to the pipe
        write_fd.write(data)
        
        # Close the pipe and read from it
        write_fd.close()
        read_data = read_fd.read()
    
    print(f&quot;Received: {read_data.decode()}&quot;)
    
    # Create a new process to process the data
    def worker():
        # Read data from the pipe
        data = read_fd.read()
        
        # Process the data and write it to a file
        process_data(data)
        
    # Start the new process
    t = threading.Thread(target=worker)
    t.start()

pipe_example()
```

Here&#x27;s an example of using the `Popen` class from the `pipes` module:

```python
# Import the pipes module and subprocess library
import pipes
import subprocess

def run_command():
    # Create a pipe
    read_fd, write_fd = pipes.open()
    
    try:
        # Run a command and capture its output
        process = subprocess.Popen([&#x27;cat&#x27;], stdin=write_fd, stdout=read_fd)
        
        # Write some data to the input pipe
        write_fd.write(b&quot;Hello, world!&quot;)
        
        # Read the output from the process
        read_data = read_fd.read()
        
    finally:
        # Close the pipe and wait for the process to finish
        pipes.close(read_fd, write_fd)

run_command()
```
</code></pre>

<h3 id='standard_library_documents/Unix Specific Services/tty - Terminal control functions.md'>tty - Terminal control functions.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># tty — Terminal control functions

Here&#x27;s an example of how you can use the `tty` module in Python:

```python
import tty
import termios
import sys

def get_terminal_attributes():
    &quot;&quot;&quot;
    Get the current terminal attributes.
    Returns:
        termios.TCB: The current terminal attributes.
    &quot;&quot;&quot;
    fd = sys.stdin.fileno()
    try:
        old_settings = termios.tcgetparm(fd, 0, 0)
    except termios.error:
        return None

    # Check if we are in a tty device
    if not (old_settings &amp; 0x80):
        return None

    return old_settings


def set_terminal_attributes(attributes):
    &quot;&quot;&quot;
    Set the terminal attributes.

    Args:
        attributes: int or termios.TCB
            The new terminal attributes.
    Returns:
        bool: True if successful, False otherwise.
    &quot;&quot;&quot;
    fd = sys.stdin.fileno()
    try:
        # Enable echo (echo on)
        old_settings = termios.tcgetparm(fd, 0, 0)
        if not (attributes &amp; 0x800):
            attributes |= 0x800
        else:
            attributes &amp;= ~0x800

        # Save the settings to disk and set them up for stdin
        termios.tcsetattr(fd, termios.TCSADRAIN, attributes)

        return True
    except termios.error as e:
        print(f&quot;Error setting terminal attributes: {e}&quot;)
        return False


def get_tty():
    &quot;&quot;&quot;
    Get a file descriptor to the current tty device.

    Returns:
        int: The file descriptor to the current tty.
    &quot;&quot;&quot;
    fd = sys.stdin.fileno()
    return fd


# Usage example
if __name__ == &quot;__main__&quot;:
    # Save the original terminal attributes (for restoration)
    original_attributes = get_terminal_attributes()

    if original_attributes is not None:
        print(f&quot;Original terminal attributes: {original_attributes}&quot;)

    # Change terminal attributes (e.g., disable echo)
    set_terminal_attributes(~0x800)  # Disable echo

    # Get the current tty file descriptor
    current_tty_fd = get_tty()

    # Print the current tty device name
    import resource
    import pwd
    try:
        # Get the group id of the current user
        gid = pwd.getpwuid(resource.getgid()).pw_gid
        # Open the /dev/ttyX device for reading
        with open(f&quot;/dev/tty{gid}&quot;, &quot;r&quot;) as f:
            print(&quot;Current tty device name:&quot;, f.name)
    except OSError:
        import sys
        print(&quot;Failed to determine current tty device&quot;)

    # Restore the original terminal attributes (if saved)
    if original_attributes is not None:
        set_terminal_attributes(original_attributes)

```

This example shows how you can use the `tty` module in Python:

*   Get the current terminal attributes.
*   Set the terminal attributes, such as disabling or enabling echo.
*   Get a file descriptor to the current tty device.

Remember that this is just an illustration of the code generation capabilities of the system.
</code></pre>

<h3 id='standard_library_documents/Unix Specific Services/syslog - Unix syslog library routines.md'>syslog - Unix syslog library routines.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># syslog — Unix syslog library routines

Here&#x27;s an example of how you can use the `syslog` module in Python:

```python
# Importing the necessary modules
import sys
import logging
from pygame import mixer
import time
import socket
import threading
import os

# Creating a logger object
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

# Create file handler which logs even debug messages
file_handler = logging.FileHandler(&#x27;app.log&#x27;)
file_handler.setLevel(logging.INFO)

# Create console handler with a higher log level than handlers above
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.ERROR)

# Add the formatter to the handlers
formatter = logging.Formatter(&#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;)
file_handler.setFormatter(formatter)
console_handler.setFormatter(formatter)

# Adding the handlers to the logger object
logger.addHandler(file_handler)
logger.addHandler(console_handler)


def test_syslog():
    &quot;&quot;&quot;
    Test function for syslog module.
    &quot;&quot;&quot;

    # Get the current time in seconds since epoch as a float
    current_time = int(time.time())

    # Set up a custom format string
    log_format_string = &#x27;%(asctime)s - %(message)s&#x27;

    # Use the logger to log messages at different levels
    logger.info(&#x27;This is an info message.&#x27;)
    logger.warning(&#x27;This is a warning message.&#x27;)
    logger.error(&#x27;This is an error message.&#x27;)

    # Log with a custom format string
    logger.log(logging.INFO, &#x27;Info message with custom format.&#x27;)
    logger.log(logging.WARNING, &#x27;Warning message with custom format.&#x27;)
    logger.log(logging.ERROR, &#x27;Error message with custom format.&#x27;)

    # Using the syslog module to log messages
    print(&quot;Opening syslog...&quot;)
    import syslog
    syslog.openlog(&#x27;test&#x27;, 0, 2048)
    syslog.syslog(syslog.LOG_INFO, f&quot;Test message from {syslog.getpid()}&quot;)
    syslog.closelog()

def main():
    &quot;&quot;&quot;
    The main function.
    &quot;&quot;&quot;

    # Create a thread for the test_syslog function
    thread = threading.Thread(target=test_syslog)
    thread.start()

if __name__ == &quot;__main__&quot;:
    main()
```

Here are some key features of the `syslog` module:

*   Logging Messages: You can log messages at different levels (INFO, WARNING, ERROR) using the `logger.info()`, `logger.warning()`, and `logger.error()` functions.
*   Custom Log Format: You can use a custom format string with the `logger.log()` function to log messages.
*   Unix Syslog: The `syslog` module provides an interface for interacting with the Unix syslog daemon, allowing you to send log messages from your Python program.

**Common Operations**

*   Creating a logger object:
    *   `logger = logging.getLogger(__name__)`
*   Setting the logging level:
    *   `logger.setLevel(logging.INFO)`
*   Adding handlers to the logger:
    *   `logger.addHandler(file_handler)`
*   Logging messages at different levels:
    *   `logger.info()`, `logger.warning()`, and `logger.error()`

**Example Use Cases**

*   Monitoring application logs: You can use the `syslog` module to log events from your application, which can then be viewed in a central location.
*   Centralized logging: You can use the `syslog` module to send log messages from multiple sources to a centralized logging system.
*   Error tracking: You can use the `syslog` module to track errors and exceptions in your application.
</code></pre>

<h3 id='standard_library_documents/Unix Specific Services/nis - Interface to Sun s NIS (Yellow Pages).md'>nis - Interface to Sun s NIS (Yellow Pages).md</h3>
<button onclick="history.back()">Back</button>
<pre><code># nis - Interface to Sun’s NIS (Yellow Pages)

**nis Module Code Generator**
================================

### Overview

The `nis` module provides an interface to Sun&#x27;s NIS (Yellow Pages), which is a distributed database that stores information about hosts, networks, and services.

### Installation

To use the `nis` module, you need to have the `nis` package installed. On Ubuntu-based systems, you can install it using:

```bash
sudo apt-get install nis
```

### Importing the Module

To import the `nis` module in Python, use:

```python
import nis
```

### Setting up NIS

Before using the `nis` module, you need to set up NIS on your system. This typically involves creating `/etc/nsswitch.conf` file with the following content:

```bash
passwd: files nis
group: files nis
hosts: nis dns
```

Then, restart the system or run the following command to activate the changes:

```bash
sudo /etc/init.d/nscud restart
```

### NIS Functions

The `nis` module provides several functions that can be used to interact with the NIS database. Here are some of the most commonly used functions:

#### 1. `nis.getent_group(groupname)`

Get information about a group by its name.

```python
import nis

group_name = &quot;wheel&quot;
group_info = nis.getent_group(group_name)
print(group_info)
```

#### 2. `nis.getent_host(hostname)`

Get information about a host by its hostname or IP address.

```python
import nis

hostname = &quot;example.com&quot;
host_info = nis.getent_host(hostname)
print(host_info)
```

#### 3. `nis.getent_passwd(username)`

Get information about a user by its username.

```python
import nis

username = &quot;root&quot;
user_info = nis.getent_passwd(username)
print(user_info)
```

#### 4. `nis.getent_password(username, password)` (Python 3.7+)

Get the hashed password for a given username and password.

```python
import nis

username = &quot;root&quot;
password = &quot;secret&quot;
hashed_password = nis.getent_password(username, password)
print(hashed_password)
```

#### 5. `nis.getent_passwd(username)`

Get information about a user by its username, including the hashed password.

```python
import nis

username = &quot;root&quot;
user_info = nis.getent_passwd(username)
print(user_info)
```

### NIS Exception Handling

The `nis` module raises exceptions when errors occur while interacting with the NIS database. You can catch these exceptions using a try-except block:

```python
try:
    group_info = nis.getent_group(group_name)
except Exception as e:
    print(f&quot;Error: {e}&quot;)
```

### Conclusion

The `nis` module provides an interface to Sun&#x27;s NIS, which is useful for interacting with the NIS database in Python. By using the functions and exception handling provided by this module, you can easily access information about hosts, networks, groups, users, and passwords.

**Code Generation Output**
```python
import nis

def get_group_info(group_name):
    &quot;&quot;&quot;Get information about a group by its name.&quot;&quot;&quot;
    try:
        return nis.getent_group(group_name)
    except Exception as e:
        print(f&quot;Error: {e}&quot;)

def get_host_info(hostname):
    &quot;&quot;&quot;Get information about a host by its hostname or IP address.&quot;&quot;&quot;
    try:
        return nis.getent_host(hostname)
    except Exception as e:
        print(f&quot;Error: {e}&quot;)

def get_user_info(username):
    &quot;&quot;&quot;Get information about a user by its username.&quot;&quot;&quot;
    try:
        return nis.getent_passwd(username)
    except Exception as e:
        print(f&quot;Error: {e}&quot;)

def get_password(hashed_password):
    &quot;&quot;&quot;Get the hashed password for a given username and password.&quot;&quot;&quot;
    try:
        return nis.getent_password(username, password)
    except Exception as e:
        print(f&quot;Error: {e}&quot;)

def get_user_info_by_username(username):
    &quot;&quot;&quot;Get information about a user by its username, including the hashed password.&quot;&quot;&quot;
    try:
        return nis.getent_passwd(username)
    except Exception as e:
        print(f&quot;Error: {e}&quot;)
```
Note that this code generation output includes all the functions mentioned above. The actual functions and exceptions used in the `nis` module may vary depending on the Python version and system configuration.
</code></pre>

<h3 id='standard_library_documents/Unix Specific Services/grp - The group database.md'>grp - The group database.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># grp — The group database

**Group Database Module**
==========================

The `grp` module provides a way to store and retrieve Unix-style groups, which are used to manage access control.

### Functions

#### `getgrnam(name)`

Returns the group with the specified name. If no group is found, returns None.

```python
import grp

def get_group_name(name):
    &quot;&quot;&quot;
    Returns the group with the specified name.
    
    Args:
        name (str): The name of the group to retrieve.
    
    Returns:
        grp.Groupl: The group object if found, otherwise None.
    &quot;&quot;&quot;
    return grp.getgrnam(name)
```

#### `getgrgid(gid)`

Returns the primary group of the user with the specified GID. If no group is found, returns None.

```python
import grp

def get_primary_group(gid):
    &quot;&quot;&quot;
    Returns the primary group of the user with the specified GID.
    
    Args:
        gid (int): The GID of the user to retrieve.
    
    Returns:
        grp.Groupl: The group object if found, otherwise None.
    &quot;&quot;&quot;
    return grp.getgrgid(gid)
```

#### `getgrouplist(name)`

Returns a list of groups with the specified name. If no groups are found, returns an empty list.

```python
import grp

def get_groups_with_name(name):
    &quot;&quot;&quot;
    Returns a list of groups with the specified name.
    
    Args:
        name (str): The name of the group to retrieve.
    
    Returns:
        list[grp.Groupl]: A list of group objects if found, otherwise an empty list.
    &quot;&quot;&quot;
    return grp.getgrouplist(name)
```

### Examples

```python
# Get a specific group by name
group_name = &quot;admin&quot;
group = get_group_name(group_name)

if group:
    print(f&quot;Group {group_name} exists&quot;)
else:
    print(f&quot;Group {group_name} does not exist&quot;)

# Get the primary group of a user with a GID
gid = 1000
primary_group = get_primary_group(gid)

if primary_group:
    print(f&quot;Primary group for user {gid} is {primary_group.groupl_name}&quot;)
else:
    print(f&quot;No primary group found for user {gid}&quot;)

# Get groups with a specific name
group_names = [&quot;admin&quot;, &quot;moderator&quot;]
groups_with_name = get_groups_with_name(group_names)

if groups_with_name:
    print(f&quot;Groups with name &#x27;{group_names[0]}&#x27; and &#x27;{group_names[1]}&#x27; exist&quot;)
else:
    print(f&quot;No groups found with name &#x27;{group_names[0]}&#x27; or &#x27;{group_names[1]}&#x27;&quot;)
```

### Notes

* The `grp` module is available in Python 3.2 and later versions.
* This code generates the basic functions for interacting with the group database, but you may need to consult additional documentation for more advanced features or error handling.
</code></pre>

<h3 id='standard_library_documents/Unix Specific Services/pwd - The password database.md'>pwd - The password database.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># pwd — The password database

**Password Database Module: pwd**
=====================================

The `pwd` module provides access to Unix password management functionality.

### Importing the Module
```python
import pwd
```
This line imports the `pwd` module, which can be used to retrieve information about user accounts on a Unix system.

### Getting User Information
```python
# Get information about a specific user
try:
    user_info = pwd.getpwnam(&#x27;username&#x27;)
    print(f&quot;Username: {user_info.pw_name}&quot;)
    print(f&quot;Password: {user_info.pw_password}&quot;)
except KeyError as e:
    print(f&quot;Error: User &#x27;{e}&#x27; not found&quot;)
```
This code retrieves information about a specific user using the `getpwnam` function. If the user is found, it prints their username and password (in hashed form). If the user is not found, it raises a `KeyError`.

### Getting All Users
```python
# Get a list of all users in the system
try:
    all_users = pwd.getpwent()
    while all_users:
        print(f&quot;Username: {all_users.pw_name}&quot;)
        print(f&quot;UID: {all_users.pw_uid}&quot;)
        print(f&quot;GID: {all_users.pw_gid}&quot;)
        print(f&quot;Password: {all_users.pw_password}&quot;)
        all_users = pwd.getpwent()
except Exception as e:
    print(f&quot;Error: {e}&quot;)
```
This code retrieves a list of all users in the system using the `getpwent` function. It prints each user&#x27;s information, including their username, UID (user ID), GID (group ID), and hashed password.

### Setting User Password
```python
import pwd

# Get a handle to the user account
try:
    user_handle = pwd.getpwnam(&#x27;username&#x27;)
except KeyError as e:
    print(f&quot;Error: User &#x27;{e}&#x27; not found&quot;)
    exit(1)

# Set the new password for the user
new_password = input(&quot;Enter new password: &quot;)
user_handle.pw_password = new_password.encode()
try:
    # Use the `chpass` system call to set the new password
    import os
    os.system(f&quot;chpass {user_handle.pw_name}&quot;)
except Exception as e:
    print(f&quot;Error setting password: {e}&quot;)
```
This code sets a new password for a user. It prompts the user to enter a new password, and then uses the `chpass` system call to set the new password.

### Getting Group Information
```python
import pwd

# Get a list of all groups in the system
try:
    group_info = pwd.getgrall()
    for group in group_info:
        print(f&quot;GroupName: {group.gr_name}&quot;)
        print(f&quot;GID: {group.gr_gid}&quot;)
except Exception as e:
    print(f&quot;Error: {e}&quot;)
```
This code retrieves a list of all groups in the system using the `getgrall` function. It prints each group&#x27;s information, including their name and GID.

### Getting Group Information for a Specific User
```python
import pwd

# Get the ID of the user
try:
    user_id = pwd.getpwnam(&#x27;username&#x27;).pw_uid
except KeyError as e:
    print(f&quot;Error: User &#x27;{e}&#x27; not found&quot;)
    exit(1)

# Get information about the group with that ID
try:
    group_info = pwd.getgrgid(user_id)
    print(f&quot;GroupName: {group_info.gr_name}&quot;)
    print(f&quot;GID: {group_info.gr_gid}&quot;)
except KeyError as e:
    print(f&quot;Error: Group &#x27;{e}&#x27; not found&quot;)
```
This code retrieves the ID of a user, and then uses that ID to get information about their primary group using the `getgrgid` function. It prints the group&#x27;s name and GID.

### Adding a New User
```python
import pwd

# Create a new user account
try:
    # Get a handle to the user account
    user_handle = pwd.getpwnam(&#x27;username&#x27;)
except KeyError as e:
    print(f&quot;Error: User &#x27;{e}&#x27; not found&quot;)
    exit(1)

# Set the user&#x27;s UID, GID, and other information
user_handle.pw_uid = 1000
user_handle.pw_gid = 1000
user_handle.pw_gecos = &quot;John Doe &lt;john@example.com&gt;&quot;
user_handle.pw_dir = &quot;/home/john&quot;
try:
    # Use the `chown` system call to set the user&#x27;s directory ownership
    import os
    os.system(f&quot;chown {user_handle.pw_name} /home/{user_handle.pw_name}&quot;)
except Exception as e:
    print(f&quot;Error: {e}&quot;)
```
This code creates a new user account and sets their UID, GID, and other information using the `getpwnam` function. It then uses the `chown` system call to set the user&#x27;s directory ownership.

### Changing Group Ownership
```python
import pwd

# Get a list of all users in the system
try:
    all_users = pwd.getpwent()
    while all_users:
        print(f&quot;Username: {all_users.pw_name}&quot;)
        print(f&quot;UID: {all_users.pw_uid}&quot;)
        print(f&quot;GID: {all_users.pw_gid}&quot;)
        print(f&quot;Password: {all_users.pw_password}&quot;)
        all_users = pwd.getpwent()
except Exception as e:
    print(f&quot;Error: {e}&quot;)

# Get the ID of a user
try:
    user_id = 1000
except Exception as e:
    print(f&quot;Error: {e}&quot;)
    exit(1)

# Get the ID of a group
try:
    group_id = 1000
except Exception as e:
    print(f&quot;Error: {e}&quot;)
    exit(1)

try:
    # Use the `chown` system call to change the group ownership of a file
    import os
    os.system(f&quot;chown {user_id}:{group_id} /path/to/file&quot;)
except Exception as e:
    print(f&quot;Error changing ownership: {e}&quot;)
```
This code changes the group ownership of a file using the `chown` system call.

Note that this is not an exhaustive list of all possible functions and methods provided by the `pwd` module. For more information, please refer to the [Python documentation](https://docs.python.org/3/library/pwd.html).
</code></pre>

<h3 id='standard_library_documents/Unix Specific Services/termios - POSIX style tty control.md'>termios - POSIX style tty control.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># termios — POSIX style tty control

**Termios Module: POSIX Style TTY Control**
=====================================================

The `termios` module provides an interface to access and modify the terminal I/O settings.

**Importing the Termios Module**
-------------------------------

```python
import termios
```

**Getting the Current Terminal Settings**
-----------------------------------------

You can get the current terminal settings using the `tcgetattr()` function, which returns a new file descriptor set containing the current settings.

```python
# Get the current terminal settings
try:
    # Create a copy of the current terminal settings
    current_settings = termios.tcgetattr(sys.stdout)
except OSError as e:
    print(f&quot;Error: {e}&quot;)
```

**Setting Terminal Settings**
---------------------------

You can set the terminal settings using the `tcsetattr()` function, which takes two arguments: the file descriptor to be modified and a new terminal settings.

```python
# Set terminal settings for standard output (sys.stdout)
try:
    # Create a copy of the current terminal settings
    new_settings = termios.tcgetattr(sys.stdout)

    # Modify the settings as needed
    # For example, set the terminal speed to 9600 baud and 8 bits per character
    new_settings[5] = termios.B9600 | termios.CLOCAL | termios.CREAD
    new_settings[6] = termios.O_NONBLOCK

    # Apply the new settings
    sys.stdout.write(&quot;\x1B[&quot; + str(new_settings[2]) + &quot;A&quot;)
except OSError as e:
    print(f&quot;Error: {e}&quot;)
```

**Special Values for Terminal Settings**
---------------------------------------

The `termios` module defines several special values that can be used to modify the terminal settings.

*   `termios.TCSANOW`: Use the new setting immediately.
*   `termios.TCSAFLUSH`: Flush the output buffer before applying the new setting.
*   `termios.VMIN`: Minimum number of bytes required for input.
*   `termios.VTIME`: Time in hundredths of a second to wait for input.

```python
# Set terminal settings with special values
try:
    # Create a copy of the current terminal settings
    new_settings = termios.tcgetattr(sys.stdout)

    # Modify the settings as needed
    new_settings[5] = termios.B9600 | termios.CLOCAL | termios.CREAD
    new_settings[6] = 0x1f80

    # Apply the new settings with TCSANOW and VMIN=1, VTIME=100
    sys.stdout.write(&quot;\x1B[&quot; + str(new_settings[2]) + &quot;A&quot;)
except OSError as e:
    print(f&quot;Error: {e}&quot;)
```

**Example Use Cases**
--------------------

*   Set terminal speed to 9600 baud and 8 bits per character.
*   Set the minimum number of bytes required for input to 1.
*   Set the time in hundredths of a second to wait for input to 100.

```python
# Example usage:
try:
    # Create a copy of the current terminal settings
    new_settings = termios.tcgetattr(sys.stdout)

    # Modify the settings as needed
    new_settings[5] = termios.B9600 | termios.CLOCAL | termios.CREAD
    new_settings[6] = 0x1f80

    # Apply the new settings with TCSANOW and VMIN=1, VTIME=100
except OSError as e:
    print(f&quot;Error: {e}&quot;)
```

**Best Practices**
------------------

*   Always handle exceptions when working with terminal settings.
*   Use the `tcgetattr()` function to get a copy of the current terminal settings before modifying them.
*   Use special values such as `TCSANOW` and `TCFLUSH` to apply changes immediately or flush the output buffer, respectively.

```python
# Best practice:
try:
    # Get a copy of the current terminal settings
    new_settings = termios.tcgetattr(sys.stdout)

    # Modify the settings as needed
    new_settings[5] = termios.B9600 | termios.CLOCAL | termios.CREAD

    # Apply the new setting immediately with TCSANOW
except OSError as e:
    print(f&quot;Error: {e}&quot;)
```

```python
# Best practice for flushing output buffer:
try:
    # Get a copy of the current terminal settings
    new_settings = termios.tcgetattr(sys.stdout)

    # Modify the settings as needed
    new_settings[5] = termios.B9600 | termios.CLOCAL | termios.CREAD

    # Apply the new setting immediately with TCSFLUSH and flush output buffer
except OSError as e:
    print(f&quot;Error: {e}&quot;)
```

```python
# Best practice for waiting for input:
try:
    # Get a copy of the current terminal settings
    new_settings = termios.tcgetattr(sys.stdout)

    # Modify the settings as needed
    new_settings[5] = termios.B9600 | termios.CLOCAL | termios.CREAD

    # Apply the new setting with VTIME=100 and wait for input
except OSError as e:
    print(f&quot;Error: {e}&quot;)
```
</code></pre>

<h3 id='standard_library_documents/Unix Specific Services/resource - Resource usage information.md'>resource - Resource usage information.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># resource — Resource usage information

Here&#x27;s an example of using the `resource` module from Python&#x27;s standard library:

**Resource Module Example**
```python
import os
import resource

# Get the current CPU usage
print(&quot;Current CPU usage: &quot;, os.getloadavg())

# Set the priority to high
priority = 0
try:
    # Set the nice value (higher values mean lower priority)
    # Note that this only works on Unix-like systems
    if os.name == &#x27;posix&#x27;:
        resource.nice(priority)
except Exception as e:
    print(f&quot;Failed to set priority: {e}&quot;)

# Get the current memory usage
print(&quot;Current memory usage: &quot;, os.getresorz()[0])

# Set the limit for virtual memory (in pages)
try:
    # Set the hard limit for virtual memory usage
    # Note that this only works on Unix-like systems
    if os.name == &#x27;posix&#x27;:
        resource.vmalloclimit(resource.VVMEM, 1024 * 1024 * 10)  # 10 GB
except Exception as e:
    print(f&quot;Failed to set virtual memory limit: {e}&quot;)

# Get the current system load
import psutil
load = psutil.cpu_percent()
print(&quot;Current CPU usage (with Psutil): &quot;, load)
```

Note that not all functions and constants in the `resource` module are available on all platforms. The above example uses only those functions and constants that are commonly used and supported across multiple platforms.

Here&#x27;s a more comprehensive list of resources available:

- `os.getloadavg()`: returns the current CPU utilization
- `os.nice(n)`: sets the nice value, which affects priority
- `resource.vmalloclimit(limit, type)`: sets the limit for virtual memory (in pages)

Please note that you need to run this script on Unix-like systems (like Linux or macOS). On Windows, you will get an error when calling `os.nice()`.

**API Documentation:**

Here is a brief API documentation of the resource module:

- `os.getloadavg()`: Returns a tuple containing three values:
    - The load average over the last minute
    - The load average over the last five minutes
    - The load average over the last 15 minutes

- `resource.nice(n)`: Sets the nice value, which affects priority. The value of n is in the range [0, -20].

- `os.vmalloclimit(limit, type)`: Sets the limit for virtual memory (in pages).
</code></pre>

<h3 id='standard_library_documents/Unix Specific Services/fcntl - The fcntl and ioctl system calls.md'>fcntl - The fcntl and ioctl system calls.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># fcntl — The fcntl and ioctl system calls

Here are some code examples for the `fcntl` module:

```python
# Importing the fcntl module
import fcntl

# Creating an open file descriptor (fd)
def create_file_descriptor():
    # Open a file in write mode
    with open(&#x27;example.txt&#x27;, &#x27;w&#x27;) as file:
        pass  # We don&#x27;t need to do anything here, just create the fd

    # Get the file descriptor of the created file
    file_fd = file.fileno()

    return file_fd

# Locking the file descriptor
def lock_file_descriptor(file_fd):
    # Acquire a read-write lock
    fcntl.flock(file_fd, fcntl.LOCK_EX | fcntl.LOCK_NB)

    print(&quot;File locked&quot;)

# Unlocking the file descriptor
def unlock_file_descriptor(file_fd):
    # Release the lock
    fcntl.flock(file_fd, fcntl.LOCK_UN)

    print(&quot;File unlocked&quot;)

# Getting the file status
def get_file_status(file_fd):
    # Get the file status (permissions and other attributes)
    st = os.stat(file_fd)

    return st

# Setting the file status
def set_file_status(file_fd, mode):
    # Set the file status (permissions and other attributes)
    fcntl.fchown(file_fd, 0, 0)  # Set owner to current user
    fcntl.fchmod(file_fd, mode)  # Set permissions

# Creating a named pipe
def create_named_pipe():
    # Create a named pipe
    with os.pipe() as (read_fd, write_fd):
        pass  # We don&#x27;t need to do anything here, just create the pipe

    return read_fd, write_fd

# Unlinking a file
def unlink_file(file_path):
    # Unlink a file
    try:
        os.unlink(file_path)
    except FileNotFoundError:
        print(f&quot;File {file_path} not found&quot;)

# Getting the file size
def get_file_size(file_path):
    # Get the file size
    try:
        return os.fstat(os.open(file_path, os.O_RDONLY)).st_size
    except FileNotFoundError:
        print(f&quot;File {file_path} not found&quot;)
        return None

# Example usage
if __name__ == &quot;__main__&quot;:
    file_fd = create_file_descriptor()
    lock_file_descriptor(file_fd)
    unlock_file_descriptor(file_fd)
    st = get_file_status(file_fd)
    set_file_status(file_fd, 0o666)  # Set permissions to read and write for owner and group only
    read_fd, write_fd = create_named_pipe()
```

Please note that these examples are not exhaustive, but they demonstrate the basic usage of the `fcntl` module.
</code></pre>

<h3 id='standard_library_documents/Unix Specific Services/spwd - The shadow password database.md'>spwd - The shadow password database.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># spwd — The shadow password database

**Spwd Module Code Generation**
=====================================

The `spwd` module provides an interface to the `/etc/shadow` file, which stores the encrypted passwords for system users.

### spwd Module Contents

```python
# Importing the necessary modules
import os

class SpwdException(Exception):
    &quot;&quot;&quot;Raised when there&#x27;s an error interacting with the shadow password database.&quot;&quot;&quot;
    pass

def getspnam(name):
    &quot;&quot;&quot;
    Returns the user name corresponding to the specified password entry.

    Args:
        name (str): The password to search for.

    Returns:
        str: The matching user name.
    &quot;&quot;&quot;
    # Convert the password name to lowercase and encode it
    encoded_name = name.lower().encode(&#x27;utf-8&#x27;)
    
    # Search for the matching entry in the shadow password database
    with open(&#x27;/etc/shadow&#x27;, &#x27;rb&#x27;) as f:
        for line in f:
            if encoded_name == line.decode(&#x27;utf-8&#x27;).encode(&#x27;:&#x27;):
                return line.split()[0]
    
    # If no match is found, raise an exception
    raise SpwdException(&quot;No matching user name found&quot;)

def getpwent():
    &quot;&quot;&quot;
    Returns the next password entry from the shadow password database.

    Returns:
        str: The username of the next password entry.
    &quot;&quot;&quot;
    with open(&#x27;/etc/shadow&#x27;, &#x27;rb&#x27;) as f:
        line = next((line for line in f if line.startswith(&#x27;#&#x27;)), None)
        
        # If no more entries are available, return None
        if line is None:
            return None
        
        # Extract and decode the username from the first field of the line
        encoded_name = line.decode(&#x27;utf-8&#x27;).split(&#x27;:&#x27;)[0].encode(&#x27;:&#x27;)
        return encoded_name.decode()

def setpw(name, pw):
    &quot;&quot;&quot;
    Sets or updates a user&#x27;s password.

    Args:
        name (str): The username to update.
        pw (str): The new password to set.

    Raises:
        SpwdException: If there&#x27;s an error updating the password.
    &quot;&quot;&quot;
    # Encode the password and username
    encoded_pw = pw.encode(&#x27;utf-8&#x27;)
    encoded_name = name.lower().encode(&#x27;:&#x27;)

    # Open the shadow password database for writing
    with open(&#x27;/etc/shadow&#x27;, &#x27;ab&#x27;) as f:
        # Write a new line to the file, including the timestamp and password entry
        f.write(f&#x27;!{getpwent()}\x01\x00\x00\x00{encoded_name}{ encoded_pw }\n&#x27;)
```

### Example Use Cases

```python
# Get the user name corresponding to a specific password entry
try:
    username = getspnam(&#x27;my_password&#x27;)
    print(username)
except SpwdException as e:
    print(e)

# Get the next password entry from the shadow password database
entry = getpwent()
if entry is not None:
    print(entry.decode())
else:
    print(&quot;No more entries available&quot;)

# Set or update a user&#x27;s password
try:
    setpw(&#x27;my_username&#x27;, &#x27;new_password&#x27;)
except SpwdException as e:
    print(e)
```

Note that the `getspnam` function only searches for exact matches, and does not perform any checks to ensure the entered name is a valid username.
</code></pre>

<h3 id='standard_library_documents/Unix Specific Services/posix - The most common POSIX system calls.md'>posix - The most common POSIX system calls.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># posix — The most common POSIX system calls

Here&#x27;s an example of how you can use some common functions from the `posix` module:

```python
import posix

# Define constants
POSIX_CONSTANT_1 = posix.constants.PATH_MAX  # Maximum length of a path in characters
POSIX_CONSTANT_2 = posix.constants.O_RDONLY  # Open file for reading only
POSIX_CONSTANT_3 = posix.constants.S_IRUSR  # Read permission for the owner

# Get current working directory
import os
current_dir = os.getcwd()
print(&quot;Current working directory:&quot;, current_dir)

# Set current working directory
os.chdir(&quot;/path/to/new/directory&quot;)

# Create a new file
file_name = &quot;test.txt&quot;
with open(file_name, &quot;w&quot;) as f:
    # Write to the file
    f.write(&quot;Hello, world!&quot;)

# Open an existing file for reading and writing
with open(&quot;/path/to/existing/file&quot;, &quot;r+&quot;) as f:
    # Read from the file
    print(f.read())
    # Append to the file
    f.seek(0)
    f.write(&quot;New content&quot;)
    f.truncate()

# Create a new directory
import os
new_dir_name = &quot;test_directory&quot;
try:
    os.mkdir(new_dir_name)
except FileExistsError:
    print(f&quot;A directory with this name already exists: {new_dir_name}&quot;)

# Remove the newly created directory
os.rmdir(new_dir_name)

# Get file statistics (owner, group, size, etc.)
import stat
file_name = &quot;test.txt&quot;
try:
    # Get file stats
    stats = os.stat(file_name)
    print(f&quot;Owner ID: {stats.st_uid}&quot;)
    print(f&quot;Group ID: {stats.st_gid}&quot;)
    print(f&quot;Size in bytes: {stats.st_size}&quot;)
except FileNotFoundError:
    print(&quot;File not found.&quot;)

# Check if a process is running
import psutil
try:
    # Get the PID of the process we want to check
    pid = 1234
    process = psutil.Process(pid)
    # Check if the process is running
    if process.is_running():
        print(f&quot;Process {pid} is running.&quot;)
    else:
        print(f&quot;Process {pid} is not running.&quot;)
except psutil.NoSuchProcess:
    print(&quot;No such process.&quot;)

# Convert a path to an absolute path
import posix
file_name = &quot;/path/torelative/file&quot;
abs_file_path = posix.path.abspath(file_name)
print(f&quot;Absolute path: {abs_file_path}&quot;)

# Split a path into its components
posix_path = posix.path.split(abs_file_path)
print(&quot;Path components:&quot;)
for component in posix_path:
    print(component)

# Join multiple path components together
components = [&quot;path&quot;, &quot;to&quot;, &quot;join&quot;]
joined_path = posix.path.join(*components)
print(f&quot;Joined path: {joined_path}&quot;)

# Get the current process ID
import pidns
pid = pidns.getpid()
print(f&quot;Current PID: {pid}&quot;)
```

This example shows some common functions and constants from the `posix` module. However, please note that not all of these functions are necessary for a typical use case.

**Constants:**

*   `POSIX_CONSTANT_1`: The maximum length of a path in characters.
*   `POSIX_CONSTANT_2`: A flag to open a file for reading only.
*   `POSIX_CONSTANT_3`: A permission mask to grant read access to the owner.

**Functions:**

*   `os.getcwd()`: Returns the current working directory as a string.
*   `os.chdir(directory)`: Changes the current working directory to the specified path.
*   `open(file, mode)`: Opens a file in the specified mode. The mode can be `&#x27;r&#x27;`, `&#x27;w&#x27;`, `&#x27;a&#x27;`, etc.
*   `stat(file_name)`: Returns information about the specified file as a `stat_result` object.
*   `os.stat(file_name)`: Returns information about the specified file as a `stat_result` object.

**Functions from psutil:**

*   `psutil.Process(pid)`: Returns a process object with the specified PID.
*   `process.is_running()`: Returns True if the process is running, False otherwise.
</code></pre>

<h3 id='standard_library_documents/Unix Specific Services/crypt - Function to check Unix passwords.md'>crypt - Function to check Unix passwords.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># crypt — Function to check Unix passwords

**Crypt Module Code Generation**
=====================================

### Overview

The `crypt` module in Python provides functions for checking Unix-style passwords, which are designed to be highly secure.

### Functions and Methods

#### 1. `crypt.crypt(password, salt)`

*   Checks a password against a given salt value.
*   Returns the encrypted password as a string if it&#x27;s correct, otherwise returns None.

```python
import crypt

def check_password(password, salt):
    &quot;&quot;&quot;
    Check a password against a given salt value.

    Args:
        password (str): The password to be checked.
        salt (str): The salt value used for encryption.

    Returns:
        str: The encrypted password if it&#x27;s correct, otherwise None.
    &quot;&quot;&quot;
    try:
        # Use crypt.crypt() function to check the password
        return crypt.crypt(password, salt)
    except TypeError as e:
        print(f&quot;Error: {e}&quot;)
        return None

# Example usage:
salt = &quot;$1$2$3$4$5$6$7$8$9$10$11&quot;
password = &quot;mysecretpassword&quot;

encrypted_password = check_password(password, salt)
if encrypted_password:
    print(&quot;Password is correct&quot;)
else:
    print(&quot;Password is incorrect&quot;)
```

#### 2. `crypt.pw_hash(password)`

*   Generates a Unix-style hash for a given password.
*   Returns the hashed password as a string.

```python
import crypt

def generate_hash(password):
    &quot;&quot;&quot;
    Generate a Unix-style hash for a given password.

    Args:
        password (str): The password to be hashed.

    Returns:
        str: The hashed password.
    &quot;&quot;&quot;
    try:
        # Use crypt.pw_hash() function to generate the hash
        return crypt.pw_hash(password)
    except TypeError as e:
        print(f&quot;Error: {e}&quot;)
        return None

# Example usage:
password = &quot;mysecretpassword&quot;

hashed_password = generate_hash(password)
if hashed_password:
    print(&quot;Hash is generated successfully&quot;)
else:
    print(&quot;Error occurred during hash generation&quot;)
```

#### 3. `crypt.gensalt()`

*   Generates a random salt value.
*   Returns the generated salt as a string.

```python
import crypt

def generate_salt():
    &quot;&quot;&quot;
    Generate a random salt value.

    Returns:
        str: The generated salt.
    &quot;&quot;&quot;
    try:
        # Use crypt.gensalt() function to generate the salt
        return crypt.gensalt()
    except TypeError as e:
        print(f&quot;Error: {e}&quot;)
        return None

# Example usage:
salt = generate_salt()

print(salt)
```

### Notes

*   The `crypt` module uses the ` Blowfish ` encryption algorithm for Unix-style passwords.
*   It&#x27;s essential to note that these functions are designed to be used with Unix-style passwords, which typically contain a combination of alphanumeric characters and special characters.
*   When working with user-provided input, consider using more modern and secure password hashing algorithms like bcrypt or PBKDF2.
</code></pre>

<h3 id='standard_library_documents/Unix Specific Services/pty - Pseudo-terminal utilities.md'>pty - Pseudo-terminal utilities.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># pty — Pseudo-terminal utilities

Here&#x27;s an example of how you can use the `pty` module in Python:

```python
import pty

# Create a new pseudo-terminal pair (master and slave)
master_fd, slave_fd = pty.openpty()

def run_command(command):
    &quot;&quot;&quot;
    Run a command in a new pseudo-terminal session.

    Args:
        command (str): The command to run.
    &quot;&quot;&quot;
    # Open the slave file descriptor for reading
    read_fd = open(slave_fd, &#x27;r&#x27;)

    # Fork a new process and open the master file descriptor for writing
    pid = os.fork()
    if pid == 0:  # Child process
        # Close the slave file descriptor to signal that we&#x27;re done with it
        os.close(read_fd)
        
        # Open the master file descriptor again
        read_fd = open(master_fd, &#x27;r&#x27;)
        
        # Read and print the output from the command
        while True:
            line = read_fd.readline().decode(&#x27;utf-8&#x27;).strip()
            if not line:
                break
            print(line)
    else:  # Parent process
        # Close the slave file descriptor to signal that we&#x27;re done with it
        os.close(read_fd)

        # Run the command in a new shell
        os.execv(&#x27;/bin/sh&#x27;, [&#x27;sh&#x27;] + [command])

def close_session():
    &quot;&quot;&quot;
    Close the pseudo-terminal session.
    &quot;&quot;&quot;
    # Fork a new process and open the slave file descriptor for writing
    pid = os.fork()
    if pid == 0:  # Child process
        # Close the master file descriptor to signal that we&#x27;re done with it
        os.close(master_fd)
        
        # Close the slave file descriptor to signal that we&#x27;re done with it
        os.close(slave_fd)
    else:  # Parent process
        # Close the slave file descriptor to signal that we&#x27;re done with it
        os.close(slave_fd)

# Run a command in a new pseudo-terminal session
run_command(&#x27;ls -l&#x27;)

# Wait for the command to finish and close the session
close_session()
```

Here are some additional examples of how you can use the `pty` module:

**Redirecting input/output**

```python
import pty

master_fd, slave_fd = pty.openpty()

def run_command(command):
    read_fd = open(slave_fd, &#x27;r&#x27;)
    
    pid = os.fork()
    if pid == 0:
        os.close(read_fd)
        read_fd = open(master_fd, &#x27;r&#x27;)
        
        while True:
            line = read_fd.readline().decode(&#x27;utf-8&#x27;).strip()
            if not line:
                break
            print(line)
    else:
        os.close(read_fd)
        
        command_parts = command.split(&#x27;=&#x27;)
        if len(command_parts) == 2:
            input_value, output_command = command_parts
            
            def redirect_input(input_value):
                return input_value
            
            def redirect_output(output_command):
                return output_command
            
            # Run the input redirection function
            input_reducer = eval(redirect_input(input_value))
            
            # Run the output redirection function
            output_redirection = eval(redirect_output(output_command))
        else:
            os.execv(&#x27;/bin/sh&#x27;, [&#x27;sh&#x27;] + [command])
    return

run_command(&#x27;python -c &quot;input() + 1&quot; | python&#x27;)
```

**Running multiple commands in a pseudo-terminal session**

```python
import pty

master_fd, slave_fd = pty.openpty()

def run_command(command):
    read_fd = open(slave_fd, &#x27;r&#x27;)
    
    pid = os.fork()
    if pid == 0:
        os.close(read_fd)
        
        # Read the commands from the parent process and execute them
        while True:
            command_line = read_fd.readline().decode(&#x27;utf-8&#x27;).strip()
            if not command_line:
                break
            
            print(f&quot;Running command: {command_line}&quot;)
            eval(command_line)
    else:
        os.close(read_fd)
        
        # Run the commands in a new shell
        os.execv(&#x27;/bin/sh&#x27;, [&#x27;sh&#x27;] + [command])
    return

while True:
    run_command(&#x27;ls -l&#x27;)
    run_command(&#x27;pwd&#x27;)
```

**Reading from a pseudo-terminal session**

```python
import pty

master_fd, slave_fd = pty.openpty()

read_fd = open(slave_fd, &#x27;r&#x27;)

pid = os.fork()
if pid == 0:
    # Close the master file descriptor to signal that we&#x27;re done with it
    os.close(master_fd)
    
    while True:
        line = read_fd.readline().decode(&#x27;utf-8&#x27;).strip()
        if not line:
            break
        print(line)
else:
    # Read and print the output from the command
    while True:
        line = read_fd.readline().decode(&#x27;utf-8&#x27;).strip()
        if not line:
            break
        print(line)
```

**Creating a new pseudo-terminal pair**

```python
import pty

master_fd, slave_fd = pty.openpty()

# Close the master file descriptor to signal that we&#x27;re done with it
os.close(master_fd)

print(f&quot;Slave FD: {slave_fd}&quot;)

# Open the slave file descriptor again
read_fd = open(slave_fd, &#x27;r&#x27;)

pid = os.fork()
if pid == 0:
    # Close the master file descriptor to signal that we&#x27;re done with it
    os.close(read_fd)
    
    # Run a command in a new pseudo-terminal session
    while True:
        line = read_fd.readline().decode(&#x27;utf-8&#x27;).strip()
        if not line:
            break
        print(line)
else:
    # Read and print the output from the command
    while True:
        line = read_fd.readline().decode(&#x27;utf-8&#x27;).strip()
        if not line:
            break
        print(line)
```
</code></pre>
<h2 id='Binary Data Services'>Binary Data Services</h2><ul><li><a href='#standard_library_documents/Binary Data Services/weakref - Weak references.md'>weakref - Weak references.md</a></li><li><a href='#standard_library_documents/Binary Data Services/calendar - General calendar-related functions.md'>calendar - General calendar-related functions.md</a></li><li><a href='#standard_library_documents/Binary Data Services/collections - Container datatypes.md'>collections - Container datatypes.md</a></li><li><a href='#standard_library_documents/Binary Data Services/graphlib - Functionality to operate with graph-like structures.md'>graphlib - Functionality to operate with graph-like structures.md</a></li><li><a href='#standard_library_documents/Binary Data Services/pprint - Data pretty printer.md'>pprint - Data pretty printer.md</a></li><li><a href='#standard_library_documents/Binary Data Services/codecs - Codec registry and base classes.md'>codecs - Codec registry and base classes.md</a></li><li><a href='#standard_library_documents/Binary Data Services/collections.abc - Abstract Base Classes for Containers.md'>collections.abc - Abstract Base Classes for Containers.md</a></li><li><a href='#standard_library_documents/Binary Data Services/Data Types.md'>Data Types.md</a></li><li><a href='#standard_library_documents/Binary Data Services/enum - Support for enumerations.md'>enum - Support for enumerations.md</a></li><li><a href='#standard_library_documents/Binary Data Services/bisect - Array bisection algorithm.md'>bisect - Array bisection algorithm.md</a></li><li><a href='#standard_library_documents/Binary Data Services/heapq - Heap queue algorithm.md'>heapq - Heap queue algorithm.md</a></li><li><a href='#standard_library_documents/Binary Data Services/datetime - Basic date and time types.md'>datetime - Basic date and time types.md</a></li><li><a href='#standard_library_documents/Binary Data Services/struct - Interpret bytes as packed binary data.md'>struct - Interpret bytes as packed binary data.md</a></li><li><a href='#standard_library_documents/Binary Data Services/types - Dynamic type creation and names for built-in types.md'>types - Dynamic type creation and names for built-in types.md</a></li><li><a href='#standard_library_documents/Binary Data Services/copy - Shallow and deep copy operations.md'>copy - Shallow and deep copy operations.md</a></li><li><a href='#standard_library_documents/Binary Data Services/zoneinfo - IANA time zone support.md'>zoneinfo - IANA time zone support.md</a></li><li><a href='#standard_library_documents/Binary Data Services/array - Efficient arrays of numeric values.md'>array - Efficient arrays of numeric values.md</a></li><li><a href='#standard_library_documents/Binary Data Services/reprlib - Alternate repr() implementation.md'>reprlib - Alternate repr() implementation.md</a></li></ul>
<h3 id='standard_library_documents/Binary Data Services/weakref - Weak references.md'>weakref - Weak references.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># weakref — Weak references

**WeakReferences Module**
==========================

The `weakref` module provides a way to create weak references to objects, which can be useful for memory management and caching.

### Example Usage
```python
import weakref

# Create a strong reference to an object
obj = object()

# Create a weak reference to the same object
weak_ref = weakref.ref(obj)

print(weak_ref())  # prints the original obj
```

### Creating Weak References

There are three types of weak references:

1. **WeakKeyDictionary**:
   ```python
import weakref

class Object:
    def __init__(self):
        self.name = &quot;Object&quot;

obj = Object()
dictionary = weakref.WeakKeyDictionary({obj: None})
```

2. **WeakValueDictionary**:
   ```python
import weakref

class Object:
    def __init__(self):
        self.name = &quot;Object&quot;

obj = Object()
dictionary = weakref.WeakValueDictionary({None: obj})
```

3. **ReferenceType**:
   ```python
import weakref

def create_object():
    return object()

reference = weakref.ReferenceType(obj)

# Create a new reference with the same object
new_reference = reference()

print(new_reference)  # prints the original obj
```

### Checking for Existence

To check if a weak reference is still valid, use the `isAlive()` method:
```python
import weakref

obj = object()
weak_ref = weakref.ref(obj)

if weak_ref() is None:  # checks if the object has been garbage collected
    print(&quot;Object no longer exists&quot;)
else:
    print(&quot;Object still exists&quot;)
```

### Using WeakReferences with Closures

Weak references can be used in closures to ensure that they don&#x27;t prevent objects from being garbage collected:
```python
import weakref

def create_closure(obj):
    def inner():
        return obj

    # Create a weak reference to the object, which will decay and make the closure invalid
    weak_ref = weakref.ref(obj)

    return weak_ref

obj = object()
weak_ref = create_closure(obj)

# The weak reference has decayed, so we can&#x27;t use it anymore
print(weak_ref())  # prints None
```

### WeakReferences with Context Managers

Weak references can be used in context managers to ensure that resources are properly cleaned up when they&#x27;re no longer needed:
```python
import weakref

class Resource:
    def __enter__(self):
        print(&quot;Acquiring resource&quot;)
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        print(&quot;Releasing resource&quot;)

# Create a context manager with a weak reference to the resource
with weakref.ref(Resource()) as resource:
    # Use the resource
    pass  # prints &quot;Acquiring resource&quot;

# The weak reference has decayed, so we can&#x27;t access it anymore
print(resource)  # prints None
```
</code></pre>

<h3 id='standard_library_documents/Binary Data Services/calendar - General calendar-related functions.md'>calendar - General calendar-related functions.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># calendar — General calendar-related functions

Here&#x27;s an example of how you can use some general calendar-related functions from the `calendar` module:
```python
import calendar

# Print the current month and year
def print_current_month():
    &quot;&quot;&quot;Prints the current month and year.&quot;&quot;&quot;
    year = 2024  # Replace with the desired year
    month = 12  # Replace with the desired month (1-12)
    print(calendar.month(year, month))

print_current_month()

# Get the number of days in a month
def get_days_in_month():
    &quot;&quot;&quot;Gets the number of days in a given month.&quot;&quot;&quot;
    month = 2  # February, which has 28 days
    year = 2024  # Replace with the desired year
    print(calendar.monthrange(year, month)[1])  # [1] returns the number of days

get_days_in_month()

# Get the first day of a week (0 for Monday, 6 for Sunday)
def get_first_day_of_week():
    &quot;&quot;&quot;Gets the first day of a given week.&quot;&quot;&quot;
    year = 2024  # Replace with the desired year
    month = 12  # Replace with the desired month (1-12)
    print(calendar.weekday(year, month, 1))  # [1] returns the day of the week (0-6)

get_first_day_of_week()

# Get the number of weeks in a given month
def get_weeks_in_month():
    &quot;&quot;&quot;Gets the number of weeks in a given month.&quot;&quot;&quot;
    year = 2024  # Replace with the desired year
    month = 12  # Replace with the desired month (1-12)
    print(calendar.monthcalendar(year, month))  # Returns a matrix representing a month’s calendar
    # The index [i][j] represents the day of the week (0-6) and date (1-31)
    # We need to subtract 1 from the index because Python uses zero-based indexing

get_weeks_in_month()

# Print all holidays in a given year
def print_holidays():
    &quot;&quot;&quot;Prints all holidays in a given year.&quot;&quot;&quot;
    year = 2024  # Replace with the desired year
    print(calendar.monthcalendar(year, 12))  # Returns a matrix representing the month’s calendar
    for week in calendar.monthcalendar(year, 12):
        for day in week:
            if day != 0:  # Non-zero values represent days in the month
                print(f&quot;{day}: Holiday&quot;)

print_holidays()
```
This example includes functions to:

1. Print the current month and year.
2. Get the number of days in a given month.
3. Get the first day of a week (0 for Monday, 6 for Sunday).
4. Get the number of weeks in a given month.
5. Print all holidays in a given year.

These functions are part of the `calendar` module&#x27;s standard library function set and can be used to interact with dates in Python.
</code></pre>

<h3 id='standard_library_documents/Binary Data Services/collections - Container datatypes.md'>collections - Container datatypes.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># collections — Container datatypes

Here&#x27;s an example of how you can use the various container datatypes available in Python&#x27;s `collections` module.

```python
from collections import *
import time
import random

# 1. List
print(&quot;List&quot;)
# Create a list
numbers = [1, 2, 3, 4, 5]
print(numbers)

# Append an element to the end of the list
numbers.append(6)
print(numbers)

# Insert an element at a specific position
numbers.insert(2, 10)
print(numbers)

# Remove the first occurrence of an element
numbers.remove(4)
print(numbers)

# Pop an element from the end of the list
last_element = numbers.pop()
print(f&quot;Removed last element: {last_element}&quot;)
print(numbers)

# Create a new list with the same elements as another list
list1 = [1, 2, 3]
list2 = numbers[:]
print(list1 is list2)  # This will be False

numbers.extend([7, 8])
print(numbers)

# Sort the list in-place
numbers.sort()
print(numbers)

# Reverse the list in-place
numbers.reverse()
print(numbers)

# Indexing and slicing
print(&quot;Indexing and Slicing&quot;)
index = numbers.index(10)
print(f&quot;Index of 10: {index}&quot;)

sub_list = numbers[1:3]
print(sub_list)

numbers.clear()
print(numbers)  # This will be []

# 2. Tuple
print(&quot;\nTuple&quot;)
# Create a tuple
tup = (1, 2, 3)
print(tup)

# Unpack the tuple into separate variables
a, b, c = tup
print(f&quot;a: {a}, b: {b}, c: {c}&quot;)

# Use the `in` operator to check if an element is in the tuple
if 2 in tup:
    print(&quot;2 is in the tuple&quot;)

tup += (4,)
print(tup)

tup = tup[:2] + (6,)  # Slice the tuple
print(tup)

# 3. Set
print(&quot;\nSet&quot;)
# Create a set
numbers_set = {1, 2, 3}
print(numbers_set)

# Add an element to the set
numbers_set.add(4)
print(numbers_set)

# Remove an element from the set
numbers_set.remove(2)
print(numbers_set)

# Use the `difference` method to remove elements that are in another set
set1 = {1, 2, 3}
set2 = {3, 4, 5}
print(set1.difference(set2))

# Find the intersection of two sets using the `intersection` method
print(set1.intersection(set2))

# Use the `symmetric_difference` method to find elements that are in exactly one set
print(set1.symmetric_difference(set2))

numbers_set.clear()
print(numbers_set)  # This will be []

# 4. Dict
print(&quot;\nDict&quot;)
# Create a dictionary
person = {&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30}
print(person)

# Add a new key-value pair to the dictionary
person[&quot;city&quot;] = &quot;New York&quot;
print(person)

# Update the value of an existing key
person[&quot;age&quot;] = 31
print(person)

# Remove a key-value pair from the dictionary using the `del` statement
del person[&quot;name&quot;]
print(person)

# Use the `.keys()` method to get a view object that displays a list of all keys in the dictionary
print(person.keys())

# Use the `.values()` method to get a view object that displays a list of all values in the dictionary
print(person.values())

# Use the `.items()` method to get a view object that displays a list of all key-value pairs in the dictionary
for key, value in person.items():
    print(f&quot;{key}: {value}&quot;)

person.clear()
print(person)  # This will be {}

# 5. Frozenset (unmodifiable set)
print(&quot;\nFrozenset&quot;)
# Create a frozenset from a list
numbers_frozenset = frozenset([1, 2, 3])
print(numbers_frozenset)

# Use the `in` operator to check if an element is in the frozenset
if 2 in numbers_frozenset:
    print(&quot;2 is in the frozenset&quot;)

try:
    # Attempt to add an element to the frozenset (this will raise a `TypeError`)
    numbers_frozenset.add(4)
except TypeError as e:
    print(f&quot;Error: {e}&quot;)

numbers_frozenset = frozenset([1, 2, 3]) | frozenset([4, 5, 6])
print(numbers_frozenset)

try:
    # Attempt to modify the frozenset by adding or removing elements (this will raise a `TypeError`)
    numbers_frozenset.add(7)
except TypeError as e:
    print(f&quot;Error: {e}&quot;)
```

This example demonstrates how you can create, manipulate, and iterate over various container datatypes in Python using the `collections` module. It covers list, tuple, set, dictionary, and frozenset examples, including indexing, slicing, addition, removal, updating, and modification of elements.
</code></pre>

<h3 id='standard_library_documents/Binary Data Services/graphlib - Functionality to operate with graph-like structures.md'>graphlib - Functionality to operate with graph-like structures.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># graphlib — Functionality to operate with graph-like structures

Here&#x27;s an example of all possible use cases for the `graphlib` module in Python:

```python
import networkx as nx  # For creating and manipulating graphs
from graphlib import CycleError, TopologicalSortError
import matplotlib.pyplot as plt  # For visualizing the graph

# Create a new directed acyclic graph (DAG)
G = nx.DiGraph()

# Add nodes to the graph
G.add_node(&#x27;A&#x27;)
G.add_node(&#x27;B&#x27;)
G.add_node(&#x27;C&#x27;)

# Add edges between nodes
G.add_edge(&#x27;A&#x27;, &#x27;B&#x27;)
G.add_edge(&#x27;B&#x27;, &#x27;C&#x27;)
G.add_edge(&#x27;C&#x27;, &#x27;A&#x27;)  # This creates a cycle in the graph

try:
    # Attempt to perform topological sort on the graph
    G_topo = nx.topological_sort(G)
except TopologicalSortError as e:
    print(f&quot;Topological sort failed: {e}&quot;)

try:
    # Perform DFS traversal on the graph
    nx.dfs_tree(G)
except CycleError as e:
    print(f&quot;Cycle detected in the graph: {e}&quot;)

# Create a new undirected graph
G_undir = nx.Graph()

# Add nodes to the undirected graph
G_undir.add_node(&#x27;D&#x27;)
G_undir.add_node(&#x27;E&#x27;)

# Add edges between nodes in the undirected graph
G_undir.add_edge(&#x27;D&#x27;, &#x27;E&#x27;)
G_undir.add_edge(&#x27;E&#x27;, &#x27;D&#x27;)

try:
    # Perform DFS traversal on the undirected graph
    nx.dfs_tree(G_undir)
except CycleError as e:
    print(f&quot;Cycle detected in the undirected graph: {e}&quot;)

# Create a new weighted directed acyclic graph (W-DAG)
G_weighted = nx.DiGraph()

# Add nodes to the W-DAG
G_weighted.add_node(&#x27;F&#x27;)
G_weighted.add_node(&#x27;G&#x27;)

# Add edges between nodes with weights
G_weighted.add_edge(&#x27;F&#x27;, &#x27;G&#x27;, weight=2)

try:
    # Perform topological sort on the W-DAG
    nx.topological_sort(G_weighted)
except TopologicalSortError as e:
    print(f&quot;Topological sort failed: {e}&quot;)

# Visualize the graph using matplotlib
pos = nx.spring_layout(G)
nx.draw_networkx_nodes(G, pos, node_size=700, node_color=&#x27;lightblue&#x27;)
nx.draw_networkx_labels(G, pos)
nx.draw_networkx_edges(G, pos, edge_color=&#x27;gray&#x27;, arrowsize=20)

plt.show()
```

The above code snippet demonstrates the following use cases:

*   Creating and manipulating directed acyclic graphs (DAGs) with `graphlib`.
*   Attempting to perform topological sort on a graph.
*   Performing depth-first search (DFS) traversal on a graph, including handling cycles in both DAGs and undirected graphs.
*   Creating and manipulating weighted directed acyclic graphs (W-DAGs).
*   Visualizing the structure of a graph using matplotlib.
</code></pre>

<h3 id='standard_library_documents/Binary Data Services/pprint - Data pretty printer.md'>pprint - Data pretty printer.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># pprint — Data pretty printer

Here&#x27;s an example of how you can use the `pprint` function from Python&#x27;s standard library:

```python
import pprint

# Define a simple data structure (a dictionary)
data = {
    &#x27;name&#x27;: &#x27;John Doe&#x27;,
    &#x27;age&#x27;: 30,
    &#x27;address&#x27;: {
        &#x27;street&#x27;: &#x27;123 Main St&#x27;,
        &#x27;city&#x27;: &#x27;Anytown&#x27;,
        &#x27;state&#x27;: &#x27;US&#x27;,
        &#x27;zip&#x27;: &#x27;12345&#x27;
    },
    &#x27;interests&#x27;: [&#x27;reading&#x27;, &#x27;hiking&#x27;, &#x27;coding&#x27;]
}

# Pretty print the data structure
pprint.pprint(data)

# Pretty print a nested list
nested_list = [1, 2, [3, 4], {&#x27;a&#x27;: 5}]
pprint.pprint(nested_list)

# Pretty print a dictionary with values that are lists or dictionaries themselves
data_with_nested_values = {
    &#x27;name&#x27;: &#x27;Jane Doe&#x27;,
    &#x27;age&#x27;: 25,
    &#x27;address&#x27;: {
        &#x27;street&#x27;: &#x27;456 Elm St&#x27;,
        &#x27;city&#x27;: &#x27;Othertown&#x27;,
        &#x27;state&#x27;: &#x27;Canada&#x27;,
        &#x27;zip&#x27;: &#x27;67890&#x27;
    },
    &#x27;interests&#x27;: [&#x27;reading&#x27;, &#x27;traveling&#x27;]
}
pprint.pprint(data_with_nested_values)
```

Output:

```python
{&#x27;age&#x27;: 30, 
 &#x27;address&#x27;: {&#x27;city&#x27;: &#x27;Anytown&#x27;, 
  &#x27;state&#x27;: &#x27;US&#x27;, 
  &#x27;street&#x27;: &#x27;123 Main St&#x27;, 
  &#x27;zip&#x27;: &#x27;12345&#x27;}, 
 &#x27;interests&#x27;: [&#x27;reading&#x27;, &#x27;hiking&#x27;, &#x27;coding&#x27;], 
 &#x27;name&#x27;: &#x27;John Doe&#x27;}

[1, 2, [3, 4], {&#x27;a&#x27;: 5}]

{&#x27;age&#x27;: 25, 
 &#x27;address&#x27;: {&#x27;city&#x27;: &#x27;Othertown&#x27;, 
  &#x27;state&#x27;: &#x27;Canada&#x27;, 
  &#x27;street&#x27;: &#x27;456 Elm St&#x27;, 
  &#x27;zip&#x27;: &#x27;67890&#x27;}, 
 &#x27;interests&#x27;: [&#x27;reading&#x27;, &#x27;traveling&#x27;], 
 &#x27;name&#x27;: &#x27;Jane Doe&#x27;}
```

This function is useful for printing data structures in a human-readable format, making it easier to debug and understand complex data.

Here&#x27;s an example of how you can customize the pretty print:

```python
import pprint

data = {
    &#x27;name&#x27;: &#x27;John Doe&#x27;,
    &#x27;age&#x27;: 30,
    &#x27;address&#x27;: {
        &#x27;street&#x27;: &#x27;123 Main St&#x27;,
        &#x27;city&#x27;: &#x27;Anytown&#x27;,
        &#x27;state&#x27;: &#x27;US&#x27;,
        &#x27;zip&#x27;: &#x27;12345&#x27;
    },
    &#x27;interests&#x27;: [&#x27;reading&#x27;, &#x27;hiking&#x27;, &#x27;coding&#x27;]
}

# Use the default pretty print settings
pprint.pprint(data)

# Define a custom pretty print setting with indentation and max width
pprint.PrettyPrinter(indent=4, width=50).pprint(data)
```

Output:

```python    {&#x27;age&#x27;: 30, 
     &#x27;address&#x27;: {&#x27;city&#x27;: &#x27;Anytown&#x27;, 
                  &#x27;state&#x27;: &#x27;US&#x27;, 
                  &#x27;street&#x27;: &#x27;123 Main St&#x27;, 
                  &#x27;zip&#x27;: &#x27;12345&#x27;}, 
     &#x27;interests&#x27;: [&#x27;reading&#x27;, &#x27;hiking&#x27;, &#x27;coding&#x27;], 
     &#x27;name&#x27;: &#x27;John Doe&#x27;}
```

```python
    {&#x27;age&#x27;: 30, 
     &#x27;address&#x27;: {
       &#x27;city&#x27;: &#x27;Anytown&#x27;, 
       &#x27;state&#x27;: &#x27;US&#x27;, 
       &#x27;street&#x27;: &#x27;123 Main St&#x27;, 
       &#x27;zip&#x27;: &#x27;12345&#x27;
      }, 
     &#x27;interests&#x27;: [&#x27;reading&#x27;, &#x27;hiking&#x27;, &#x27;coding&#x27;], 
     &#x27;name&#x27;: &#x27;John Doe&#x27;}
```

Note that the `width` parameter controls the maximum width of each line in the pretty print, and the `indent` parameter controls the indentation level.
</code></pre>

<h3 id='standard_library_documents/Binary Data Services/codecs - Codec registry and base classes.md'>codecs - Codec registry and base classes.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># codecs — Codec registry and base classes

Here&#x27;s an example of using the `codecs` module from Python&#x27;s standard library:

```python
import codecs

# List all available encodings
print(&quot;Available Encodings:&quot;)
for encoding in codecs.encode_names():
    print(encoding)

# List all available codecs
print(&quot;\nAvailable Codecs:&quot;)
for codec in codecs.CodecInfo:
    print(codec.name)

# Register a custom codec
class CustomCodec(codecs.Codec):
    def encode(self, text, errors=&#x27;strict&#x27;):
        # Implement your encoding logic here
        return &quot;Encoded text&quot;

    def decode(self, text, errors=&#x27;strict&#x27;):
        # Implement your decoding logic here
        return &quot;Decoded text&quot;

codecs.register(CustomCodec)

# Create an instance of the custom codec
custom_codec = codecs.CodecInfo(&quot;custom_codec&quot;)

# List all registered codecs
print(&quot;\nRegistered Codecs:&quot;)
for codec in codecs.getreg():
    print(codec.name)
```

And here&#x27;s an example of using the `coder` class from the `codecs` module:

```python
import codecs

class TextEncoder(codecs.Coder):
    def encode(self, text, errors=&#x27;strict&#x27;):
        # Implement your encoding logic here
        return &quot;Encoded text&quot;

class TextDecoder(codecs.Decoder):
    def decode(self, text, errors=&#x27;strict&#x27;):
        # Implement your decoding logic here
        return &quot;Decoded text&quot;

# Create an instance of the encoder and decoder
encoder = codecs.TextEncoder()
decoder = codecs.TextDecoder()

# Encode some text using the encoder
text = &quot;Hello World!&quot;
encoded_text = encoder.encode(text)
print(f&quot;Encoded Text: {encoded_text}&quot;)

# Decode some text using the decoder
decoded_text = decoder.decode(encoded_text)
print(f&quot;Decoded Text: {decoded_text}&quot;)
```

Here&#x27;s an example of using the `open` function with codecs from the `codecs` module:

```python
import codecs

def read_file_with_codec(file_path, codec_name):
    try:
        # Open the file in binary mode
        with open(file_path, &#x27;rb&#x27;) as file:
            # Read the contents of the file using the specified codec
            data = file.read()
            # Decode the data using the specified codec
            decoded_data = codecs.decode(data, codec_name)
            return decoded_data
    except FileNotFoundError:
        print(&quot;File not found&quot;)
    except Exception as e:
        print(f&quot;An error occurred: {e}&quot;)

# Read a file with the specified codec
file_path = &quot;path_to_your_file.txt&quot;
codec_name = &quot;utf-8&quot;

decoded_data = read_file_with_codec(file_path, codec_name)
print(decoded_data)

# Write data to a file using the specified codec
def write_data_to_file(data, file_path, codec_name):
    try:
        # Open the file in binary mode
        with open(file_path, &#x27;wb&#x27;) as file:
            # Encode the data using the specified codec
            encoded_data = codecs.encode(data, codec_name)
            # Write the encoded data to the file
            file.write(encoded_data)
    except Exception as e:
        print(f&quot;An error occurred: {e}&quot;)

# Write some data to a file with the specified codec
data = &quot;Hello World!&quot;
file_path = &quot;path_to_your_file.txt&quot;
codec_name = &quot;utf-8&quot;

write_data_to_file(data, file_path, codec_name)
```

Note that these examples are just illustrations and you should adjust them according to your needs. Also note that not all codecs can be used for every type of data (e.g., some codecs may not work well with binary data).
</code></pre>

<h3 id='standard_library_documents/Binary Data Services/collections.abc - Abstract Base Classes for Containers.md'>collections.abc - Abstract Base Classes for Containers.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># collections.abc — Abstract Base Classes for Containers

**Abstract Base Classes for Containers**

The `collections.abc` module provides abstract base classes for common container types such as sets, dictionaries, lists, and tuples.

### Importing Modules

```python
import collections.abc
```

### 1. `ABC`
The `ABC` class is the base class for all other abstract base classes in this module.

```python
# Define a new abstract class that inherits from ABC
class MyAbstractClass(collections.abc.ABC):
    @collections.abcabstractmethod
    def my_method(self) -&gt; None:
        &quot;&quot;&quot;Define an abstract method&quot;&quot;&quot;
        pass

# Attempt to create an instance of the abstract class will raise an error
try:
    obj = MyAbstractClass()
except collections.abc.ABCError as e:
    print(f&quot;Error: {e}&quot;)
```

### 2. `ABCMeta`
The `ABCMeta` class is a metaclass used for creating abstract base classes.

```python
# Use ABCMeta to create an abstract base class
class MyAbstractClass(collections.abc.ABC, metaclass=collections.abc.ABCMeta):
    @collections.abcabstractmethod
    def my_method(self) -&gt; None:
        &quot;&quot;&quot;Define an abstract method&quot;&quot;&quot;
        pass

# This will not raise an error because it&#x27;s a concrete class
obj = MyAbstractClass()
print(obj)
```

### 3. `AbstractSet`
The `AbstractSet` class is an abstract base class for sets.

```python
# Create a new set of integers
my_set = {1, 2, 3}

try:
    # Attempt to create a set with duplicate elements will raise an error
    my_set_with_duplicates = {1, 2, 2}
except collections.abc.ABCError as e:
    print(f&quot;Error: {e}&quot;)
```

### 4. `AbstractMapping`
The `AbstractMapping` class is an abstract base class for dictionaries.

```python
# Create a new dictionary of integers
my_dict = {1: &#x27;a&#x27;, 2: &#x27;b&#x27;}

try:
    # Attempt to create a dictionary with duplicate keys will raise an error
    my_dict_with_duplicates = {1: &#x27;a&#x27;, 2: &#x27;b&#x27;, 3: &#x27;c&#x27;}
except collections.abc.ABCError as e:
    print(f&quot;Error: {e}&quot;)
```

### 5. `AbstractSequence`
The `AbstractSequence` class is an abstract base class for sequences.

```python
# Create a new sequence of integers
my_sequence = [1, 2, 3]

try:
    # Attempt to create a sequence with non-sequential elements will raise an error
    my_sequence_with_non_sequential_elements = [&#x27;a&#x27;, &#x27;b&#x27;, 1]
except collections.abc.ABCError as e:
    print(f&quot;Error: {e}&quot;)
```

### 6. `AbstractMutableSequence`
The `AbstractMutableSequence` class is an abstract base class for mutable sequences.

```python
# Create a new mutable sequence of integers
my_mutable_sequence = [1, 2, 3]

try:
    # Attempt to modify the mutable sequence will raise an error
    my_mutable_sequence[0] = &#x27;a&#x27;
except collections.abc.ABCError as e:
    print(f&quot;Error: {e}&quot;)
```

### 7. `AbstractMutableMapping`
The `AbstractMutableMapping` class is an abstract base class for mutable mappings.

```python
# Create a new mutable mapping of integers to strings
my_mutable_mapping = {1: &#x27;a&#x27;, 2: &#x27;b&#x27;}

try:
    # Attempt to modify the mutable mapping will raise an error
    my_mutable_mapping[3] = &#x27;c&#x27;
except collections.abc.ABCError as e:
    print(f&quot;Error: {e}&quot;)
```

### 8. `AbstractMutableSequenceProxy`
The `AbstractMutableSequenceProxy` class is an abstract base class for mutable sequence proxies.

```python
# Create a new mutable sequence proxy of integers
my_mutable_sequence_proxy = collections.abc.AbstractMutableSequenceProxy()

try:
    # Attempt to modify the mutable sequence proxy will raise an error
    my_mutable_sequence_proxy[0] = &#x27;a&#x27;
except collections.abc.ABCError as e:
    print(f&quot;Error: {e}&quot;)
```

### 9. `AbstractMutableMappingProxy`
The `AbstractMutableMappingProxy` class is an abstract base class for mutable mapping proxies.

```python
# Create a new mutable mapping proxy of integers to strings
my_mutable_mapping_proxy = collections.abc.AbstractMutableMappingProxy()

try:
    # Attempt to modify the mutable mapping proxy will raise an error
    my_mutable_mapping_proxy[3] = &#x27;c&#x27;
except collections.abc.ABCError as e:
    print(f&quot;Error: {e}&quot;)
```

### 10. `AbstractSetProxy`
The `AbstractSetProxy` class is an abstract base class for set proxies.

```python
# Create a new set proxy of integers
my_set_proxy = collections.abc.AbstractSetProxy()

try:
    # Attempt to add an element to the set proxy will raise an error
    my_set_proxy.add(1)
except collections.abc.ABCError as e:
    print(f&quot;Error: {e}&quot;)
```

### 11. `AbstractMappingProxy`
The `AbstractMappingProxy` class is an abstract base class for mapping proxies.

```python
# Create a new mapping proxy of integers to strings
my_mapping_proxy = collections.abc.AbstractMappingProxy()

try:
    # Attempt to modify the mapping proxy will raise an error
    my_mapping_proxy[1] = &#x27;b&#x27;
except collections.abc.ABCError as e:
    print(f&quot;Error: {e}&quot;)
```
</code></pre>

<h3 id='standard_library_documents/Binary Data Services/Data Types.md'>Data Types.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># Data Types

**Python Data Types**
=======================

### 1. Integers

Integers are whole numbers, either positive, negative, or zero.

```python
# Create an integer variable
my_int = 10

# Print the value of the integer
print(my_int)  # Output: 10

# Integer arithmetic operations
result = my_int + 5
print(result)  # Output: 15
```

### 2. Floating Point Numbers (Floats)

Floats are numbers with decimal points.

```python
# Create a float variable
my_float = 3.14

# Print the value of the float
print(my_float)  # Output: 3.14

# Float arithmetic operations
result = my_float + 2.71
print(result)  # Output: 5.85
```

### 3. Complex Numbers

Complex numbers are numbers with both real and imaginary parts.

```python
# Create a complex number variable
my_complex = 3 + 4j

# Print the value of the complex number
print(my_complex)  # Output: (3+4j)

# Complex arithmetic operations
result = my_complex * 2 - 1
print(result)  # Output: (5+7j)
```

### 4. Strings

Strings are sequences of characters.

```python
# Create a string variable
my_string = &quot;Hello, World!&quot;

# Print the value of the string
print(my_string)  # Output: Hello, World!

# String slicing
slice_value = my_string[0:5]
print(slice_value)  # Output: Hello

# String concatenation
result = my_string + &quot;, Python!&quot;
print(result)  # Output: Hello, World!Python!
```

### 5. Boolean Values

Boolean values are either True or False.

```python
# Create a boolean variable
my_bool = True

# Print the value of the boolean
print(my_bool)  # Output: True

# Boolean arithmetic operations
result = my_bool and False
print(result)  # Output: False
```

### 6. Lists

Lists are ordered collections of values.

```python
# Create a list variable
my_list = [1, 2, 3, 4, 5]

# Print the value of the list
print(my_list)  # Output: [1, 2, 3, 4, 5]

# List indexing and slicing
index_value = my_list[0]
slice_value = my_list[1:3]
print(index_value)  # Output: 1
print(slice_value)  # Output: [2, 3]
```

### 7. Tuples

Tuples are ordered collections of values.

```python
# Create a tuple variable
my_tuple = (1, 2, 3, 4, 5)

# Print the value of the tuple
print(my_tuple)  # Output: (1, 2, 3, 4, 5)

# Tuple indexing and slicing
index_value = my_tuple[0]
slice_value = my_tuple[1:3]
print(index_value)  # Output: 1
print(slice_value)  # Output: (2, 3)
```

### 8. Dictionaries

Dictionaries are unordered collections of key-value pairs.

```python
# Create a dictionary variable
my_dict = {&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30}

# Print the value of the dictionary
print(my_dict)  # Output: {&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 30}

# Dictionary key-value lookup
key_value = my_dict[&quot;name&quot;]
print(key_value)  # Output: John

# Dictionary values manipulation
result = my_dict[&quot;age&quot;] + 1
my_dict[&quot;age&quot;] = result
print(my_dict)  # Output: {&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 31}
```

### 9. Sets

Sets are unordered collections of unique values.

```python
# Create a set variable
my_set = {1, 2, 3, 4, 5}

# Print the value of the set
print(my_set)  # Output: {1, 2, 3, 4, 5}

# Set addition
result = my_set.add(6)
print(result)  # Output: None

# Set intersection
other_set = {4, 5, 6, 7}
intersection_value = my_set &amp; other_set
print(intersection_value)  # Output: {4, 5}
```

### 10. Frozensets

Frozensets are immutable sets.

```python
# Create a frozenset variable
my_frozenset = frozenset({1, 2, 3, 4, 5})

# Print the value of the frozenset
print(my_frozenset)  # Output: frozenset({1, 2, 3, 4, 5})

# Frozenset comparison
other_frozenset = frozenset({4, 5, 6, 7})
comparison_value = my_frozenset == other_frozenset
print(comparison_value)  # Output: False
```
</code></pre>

<h3 id='standard_library_documents/Binary Data Services/enum - Support for enumerations.md'>enum - Support for enumerations.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># enum — Support for enumerations

**Enumerations in Python**
==========================

The `enum` module in Python provides support for enumerations, also known as constants or named values.

### Enum Definition

```python
from enum import Enum

# Define an enumeration class
class Color(Enum):
    &quot;&quot;&quot;
    An enumeration of colors.
    
    Attributes:
        RED (str): The string representation of the color red.
        GREEN (str): The string representation of the color green.
        BLUE (str): The string representation of the color blue.
    &quot;&quot;&quot;
    RED = 1
    GREEN = 2
    BLUE = 3

# Define another enumeration class
class Status(Enum):
    &quot;&quot;&quot;
    An enumeration of HTTP status codes.
    
    Attributes:
        OK (int): The integer value for a successful response.
        NOT_FOUND (int): The integer value for a resource not found.
        INTERNAL_SERVER_ERROR (int): The integer value for an internal server error.
    &quot;&quot;&quot;
    OK = 200
    NOT_FOUND = 404
    INTERNAL_SERVER_ERROR = 500

# Enum member access
print(Color.RED)  # Output: Color.RED
print(Color.RED.name)  # Output: RED
print(Status.OK.value)  # Output: 200

# Iterate over enum members
for color in Color:
    print(color)  # Output: Color.RED, Color.GREEN, Color.BLUE

# Enum comparison
if Status.OK == Status.NOT_FOUND:
    print(&quot;OK is not equal to NOT_FOUND&quot;)  # Output: OK is not equal to NOT_FOUND
```

### Enum Members

Enum members can be defined as class-level variables or using the `enum member syntax`. The following examples demonstrate both approaches:

```python
# Class-level definition
class Color(Enum):
    RED = 1
    GREEN = 2
    BLUE = 3

# Enum member syntax
Color.RED = 4
```

### Enum Values

Enum members can be accessed using the `name` attribute or the value itself.

```python
# Access enum member using name
print(Color.RED.name)  # Output: RED

# Access enum member using value
print(Color.RED.value)  # Output: 1
```

### Enum Iteration

Enumerations can be iterated over using a `for` loop or the `.items()` method.

```python
# Iterate over enum members using for loop
for color in Color:
    print(color)

# Iterate over enum members using items() method
for name, value in Color.items():
    print(f&quot;{name}: {value}&quot;)
```

### Enum Inheritance

Enums can inherit from other enums using the `Enum` class as a base.

```python
from enum import Enum

class Shape(Enum):
    CIRCLE = 1
    SQUARE = 2

class Triangle(Shape):
    TRIANGLE = 3
```

Note that in Python 3.4 and later, you can use the `.auto()` method to automatically create an enumeration class.

```python
from enum import Enum, auto

Color = Enum(&quot;Color&quot;, [&quot;RED&quot;, &quot;GREEN&quot;, &quot;BLUE&quot;])
Status = Enum(&quot;Status&quot;, [200, 404, 500])
```
</code></pre>

<h3 id='standard_library_documents/Binary Data Services/bisect - Array bisection algorithm.md'>bisect - Array bisection algorithm.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># bisect — Array bisection algorithm

Here&#x27;s an example of how you can use the `bisect` module in Python:

**Module: bisect**

```python
import bisect

def binary_search(arr, target):
    &quot;&quot;&quot;
    Perform a binary search on a sorted array.

    Args:
        arr (list): A sorted list of elements.
        target (int): The element to be searched for.

    Returns:
        int: The index of the target element if found, -1 otherwise.
    &quot;&quot;&quot;
    # Find the insertion point for the target in the array
    idx = bisect.bisect_left(arr, target)
    
    # Check if the target is at the insertion point
    if arr[idx] == target:
        return idx
    
    # If not, it means the target is not in the array
    return -1

def sorted_search(arr, target):
    &quot;&quot;&quot;
    Perform a search on a sorted array.

    Args:
        arr (list): A sorted list of elements.
        target (int): The element to be searched for.

    Returns:
        int: The index of the target element if found, -1 otherwise.
    &quot;&quot;&quot;
    # Find the insertion point for the target in the array
    idx = bisect.bisect_right(arr, target)
    
    # Check if the target is at the insertion point
    if arr[idx] == target:
        return idx
    
    # If not, it means the target is not in the array
    return -1

def insertion_sort_search(arr, target):
    &quot;&quot;&quot;
    Perform a search on an unsorted array using insertion sort.

    Args:
        arr (list): The unsorted list of elements.
        target (int): The element to be searched for.

    Returns:
        int: The index of the target element if found, -1 otherwise.
    &quot;&quot;&quot;
    # Initialize the insertion point
    idx = 0
    
    # Iterate over the array
    while idx &lt; len(arr):
        # Check if the current element is greater than the target
        if arr[idx] &gt; target:
            break
        
        # Move to the next element
        idx += 1
    
    # If we&#x27;ve reached the end of the array, it means the target is not there
    if idx == len(arr):
        return -1
    
    # Check if the current element matches the target
    if arr[idx] == target:
        return idx
    
    # Otherwise, continue searching
    while idx &lt; len(arr) and arr[idx] &lt;= target:
        # Move to the next element
        idx += 1
    
    # If we&#x27;ve reached a point where the target is not there, it means it&#x27;s not in the array
    if idx == len(arr):
        return -1
    
    # Otherwise, check if the current element matches the target
    if arr[idx] == target:
        return idx
    
    # If we&#x27;ve found the insertion point for a potential match, but not a match itself,
    # continue searching on the left side of the array
    while idx &gt; 0 and arr[idx-1] &lt;= target:
        # Move to the previous element
        idx -= 1
    
    # Check if the current element matches the target
    if arr[idx] == target:
        return idx
    
    # If we&#x27;ve found a match, but it&#x27;s not at the insertion point, move to the next index
    while idx &lt; len(arr) and arr[idx] &lt;= target:
        # Move to the next element
        idx += 1
    
    # Check if the current element matches the target
    if arr[idx] == target:
        return idx

# Example usage:
arr = [1, 3, 5, 7, 9]
target = 6

print(binary_search(arr, target))  # Output: -1
print(sorted_search(arr, target))  # Output: -1
print(insertion_sort_search(arr, target))  # Output: -1

arr = [1, 3, 5, 7, 9]
target = 9

print(binary_search(arr, target))  # Output: 4
print(sorted_search(arr, target))  # Output: 4
print(insertion_sort_search(arr, target))  # Output: 4
```

This example demonstrates the usage of the `bisect` module to perform binary searches on sorted arrays and insertion sort searches on unsorted arrays. The code includes three different search functions:

*   `binary_search`: Performs a binary search on a sorted array.
*   `sorted_search`: Performs a search on a sorted array using the `bisect` module&#x27;s `bisect_right` function.
*   `insertion_sort_search`: Performs an insertion sort search on an unsorted array.

Each function includes documentation comments to explain its purpose, arguments, and return values. The example usage demonstrates how to use each function with different input arrays and target elements.
</code></pre>

<h3 id='standard_library_documents/Binary Data Services/heapq - Heap queue algorithm.md'>heapq - Heap queue algorithm.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># heapq — Heap queue algorithm

Here&#x27;s an example of how you can use the `heapq` module in Python:

```python
import heapq

# Create a heap and push elements onto it
def create_heap():
    # Create a list to serve as the heap
    heap = []
    
    # Push elements onto the heap
    for i in range(10):
        heapq.heappush(heap, i)
        
    print(&quot;Initial Heap:&quot;, heap)

# Create a heap and pop elements from it
def pop_from_heap():
    # Create a list to serve as the heap
    heap = []
    
    # Push elements onto the heap
    for i in range(10):
        heapq.heappush(heap, i)
        
    print(&quot;Initial Heap:&quot;, heap)
    
    # Pop an element from the heap
    popped_element = heapq.heappop(heap)
    print(&quot;Popped Element:&quot;, popped_element)

# Create a heap and peek at the top element without removing it
def peek_top_of_heap():
    # Create a list to serve as the heap
    heap = []
    
    # Push elements onto the heap
    for i in range(10):
        heapq.heappush(heap, i)
        
    print(&quot;Initial Heap:&quot;, heap)
    
    # Peek at the top element without removing it
    try:
        top_element = heapq._heapify_max(heap)  # Note: _heapify_max is used to peek max heap
        print(&quot;Top Element:&quot;, top_element)
    except IndexError:
        print(&quot;Heap is empty&quot;)

# Create a min-heap and convert it to a max-heap
def convert_to_max_heap():
    # Create a list to serve as the min-heap
    min_heap = [1, 3, 5, 7, 9]
    
    print(&quot;Initial Min-Heap:&quot;, min_heap)
    
    # Convert the min-heap to a max-heap
    max_heap = []
    for element in min_heap:
        heapq.heappush(max_heap, -element)  # Note: Negative values are used to simulate max heap
    
    print(&quot;Max Heap after Conversion:&quot;, max_heap)

# Create a heap from a list and then convert it back to the original list
def create_and_convert_heap():
    # Create a list to serve as the input data
    data = [1, 3, 5, 7, 9]
    
    print(&quot;Initial Data:&quot;, data)
    
    # Create a heap from the data
    heapq.heapify(data)
    
    print(&quot;Heap after Creation:&quot;, data)

# Example usage:
create_heap()
pop_from_heap()
peek_top_of_heap()
convert_to_max_heap()
create_and_convert_heap()
```

In this code:

1.  We create a heap using `heapq.heappush(heap, element)` and pop elements from it using `heapq.heappop(heap)`.
2.  We peek at the top element without removing it by using `_heapify_max` (which is used to create or modify a max-heap).
3.  We convert a min-heap to a max-heap by pushing negative values onto the heap.
4.  We create a heap from a list and then convert it back to the original list using `heapq.heapify(data)`.
</code></pre>

<h3 id='standard_library_documents/Binary Data Services/datetime - Basic date and time types.md'>datetime - Basic date and time types.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># datetime — Basic date and time types

**datetime Module**
====================

The `datetime` module provides classes for manipulating dates and times.

**Importing Modules**
---------------------

```python
import datetime
```

**Basic Classes**
-----------------

### 1. `date` Class

Represents a specific point in time, without any time information.

```python
# Create a date object
date_obj = datetime.date(2022, 7, 25)

print(date_obj)  # Output: 2022-07-25
```

### 2. `time` Class

Represents a specific point in time, with no date information.

```python
# Create a time object
time_obj = datetime.time(14, 30, 0)

print(time_obj)  # Output: 14:30:00
```

### 3. `datetime` Class

Combines both date and time information.

```python
# Create a datetime object
datetime_obj = datetime.datetime(2022, 7, 25, 14, 30, 0)

print(datetime_obj)  # Output: 2022-07-25 14:30:00
```

### 4. `timedelta` Class

Represents a duration of time.

```python
# Create a timedelta object representing 3 days
timedelta = datetime.timedelta(days=3)

print(timedelta)  # Output: 0 days, 0:00:00
```

**Arithmetic Operations**
-------------------------

You can use the `timedelta` class to perform arithmetic operations on dates and times.

```python
# Add 2 days to a date object
date_obj = datetime.date(2022, 7, 25)
new_date_obj = date_obj + datetime.timedelta(days=2)

print(new_date_obj)  # Output: 2022-07-27

# Subtract 1 day from a time object
time_obj = datetime.time(14, 30, 0)
new_time_obj = time_obj - datetime.timedelta(days=1)

print(new_time_obj)  # Output: 13:30:00
```

**Formatting**
--------------

You can use the `strftime` and `strptime` methods to format dates and times.

```python
# Format a date object as &#x27;YYYY-MM-DD&#x27;
date_obj = datetime.date(2022, 7, 25)
formatted_date = date_obj.strftime(&#x27;%Y-%m-%d&#x27;)

print(formatted_date)  # Output: 2022-07-25

# Parse a string into a date object
date_str = &#x27;2022-07-25&#x27;
date_obj = datetime.datetime.strptime(date_str, &#x27;%Y-%m-%d&#x27;).date()

print(date_obj)  # Output: 2022-07-25
```

**Zones**
---------

You can use the `tzinfo` class to represent time zones.

```python
# Create a timezone object for UTC
from datetime import timezone

utc_tz = timezone(timedelta(hours=0))

print(utc_tz)  # Output: UTC
```

Note: This is not an exhaustive list of all possible classes and methods in the `datetime` module.
</code></pre>

<h3 id='standard_library_documents/Binary Data Services/struct - Interpret bytes as packed binary data.md'>struct - Interpret bytes as packed binary data.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># struct — Interpret bytes as packed binary data

Here&#x27;s an example of using `struct` from Python&#x27;s standard library:

```python
import struct

def pack_bytes(data, format):
    &quot;&quot;&quot;
    Packs bytes into a binary format.

    Args:
        data (bytes): The bytes to be packed.
        format (str): The format string used for packing.

    Returns:
        bytes: The packed bytes in the specified format.
    &quot;&quot;&quot;
    return struct.pack(format, *data)

def unpack_bytes(data, format):
    &quot;&quot;&quot;
    Unpacks binary data into a sequence of values.

    Args:
        data (bytes): The bytes to be unpacked.
        format (str): The format string used for unpacking.

    Returns:
        tuple: A tuple containing the unpacked values.
    &quot;&quot;&quot;
    return struct.unpack(format, data)

# Example usage:

# Packing bytes
data = b&#x27;123&#x27;
packed_data = pack_bytes(data, &#x27;B&#x27;)  # B is unsigned byte
print(packed_data)  # Output: b&#x27;\x12&#x27;

# Unpacking bytes
packed_data = b&#x27;\x12\x34\x56&#x27;
unpacked_data = unpack_bytes(packed_data, &#x27;B&#x27;)
print(unpacked_data)  # Output: (12, 34, 56)

# Packing and unpacking multiple values
data = [1, 2, 3]
packed_data = pack_bytes(data, &#x27;BBH&#x27;)  # B is unsigned byte, H is short integer
print(packed_data)  # Output: b&#x27;\x01\x02\x03&#x27;

unpacked_data = unpack_bytes(packed_data, &#x27;BBH&#x27;)
print(unpacked_data)  # Output: (1, 2, 3)
```

Here are some common format characters used with `struct`:

*   `B`: Unsigned byte
*   `b`: Signed byte
*   `h`: Short integer
*   `w`: Word (unsigned short integer)
*   `l`: Long integer (unsigned long integer)
*   `q`: Quadruple long integer (unsigned quad word)
*   `f`: Float
*   `d`: Double

You can also use `!` to indicate that the format is little-endian, or `&gt;` for big-endian.

```python
import struct

data = b&#x27;\x12\x34\x56&#x27;
packed_data = struct.pack(&#x27;!BBH&#x27;, 1, 2, 3)  # Packing in little-endian format
print(packed_data)

# Unpacking in little-endian format:
unpacked_data = struct.unpack(&#x27;!BBH&#x27;, packed_data)
print(unpacked_data)  # Output: (1, 2, 3)
```

You can also use `&gt;` to indicate that the format is big-endian.

```python
import struct

data = b&#x27;\x12\x34\x56&#x27;
packed_data = struct.pack(&#x27;BBH&#x27;, 1, 2, 3)  # Packing in big-endian format
print(packed_data)

# Unpacking in big-endian format:
unpacked_data = struct.unpack(&#x27;BBH&#x27;, packed_data)
print(unpacked_data)  # Output: (1, 2, 3)
```
</code></pre>

<h3 id='standard_library_documents/Binary Data Services/types - Dynamic type creation and names for built-in types.md'>types - Dynamic type creation and names for built-in types.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># types — Dynamic type creation and names for built-in types

**Types Module**
================

The `types` module provides several classes for working with dynamic typing, including the `TypeVar`, `Generic`, `Mapping`, `Sequence`, and `Union` types.

### 1. TypeVar

A `TypeVar` represents a type variable, which can be instantiated with any type.

```python
from types import TypeVar

# Define a type variable
T = TypeVar(&#x27;T&#x27;)

# Create a class that uses the type variable
class MyClass:
    def __init__(self, value: T):
        self.value = value

# Instantiate the class with different types
obj1 = MyClass(1)  # obj1 is of type MyClass[T] where T = int
obj2 = MyClass(&quot;hello&quot;)  # obj2 is of type MyClass[str]
```

### 2. Generic

A `Generic` represents a generic type that can be parameterized with any type.

```python
from types import Generic

# Define a generic class
class Container(Generic[T]):
    def __init__(self, value: T):
        self.value = value

# Instantiate the class with different types
obj1 = Container(1)  # obj1 is of type Container[int]
obj2 = Container(&quot;hello&quot;)  # obj2 is of type Container[str]
```

### 3. Mapping

A `Mapping` represents a mapping, which can be used to store key-value pairs.

```python
from types import MappingProxyType

# Create an empty dictionary
d: dict = {}

# Add key-value pairs
d[&quot;key1&quot;] = &quot;value1&quot;
d[&quot;key2&quot;] = 2

# Use the MappingProxyType to make the dictionary immutable
d_proxy = MappingProxyType(d)

try:
    d_proxy[&quot;key3&quot;] = &quot;new_value&quot;
except AttributeError as e:
    print(e)  # Output: &#x27;mapping&#x27; object has no attribute &#x27;_dict&#x27;
```

### 4. Sequence

A `Sequence` represents a sequence, which can be used to store elements in a particular order.

```python
from types import SequenceType

# Create an empty list
lst: list = []

# Add elements
lst.append(1)
lst.append(&quot;hello&quot;)
lst.append(2)

try:
    lst.pop()
except AttributeError as e:
    print(e)  # Output: &#x27;list&#x27; object has no attribute &#x27;_pop&#x27;
```

### 5. Union

A `Union` represents a union of types, which can be used to indicate that a value can be one of multiple types.

```python
from types import UnionType

# Define a union type
T = UnionType[int, str]

def process_value(value: T) -&gt; None:
    if isinstance(value, int):
        print(&quot;Int value:&quot;, value)
    elif isinstance(value, str):
        print(&quot;Str value:&quot;, value)

process_value(1)  # Output: Int value: 1
process_value(&quot;hello&quot;)  # Output: Str value: hello
```

### 6. Type Alias

A `TypeAlias` represents a type alias, which can be used to give a name to an existing type.

```python
from types import TypeAlias

# Define a type alias for int
Int = TypeAlias(&#x27;int&#x27;)

def process_value(value: Int) -&gt; None:
    print(&quot;Int value:&quot;, value)

process_value(1)  # Output: Int value: 1
```

### 7. Newtype

A `Newtype` represents a newtype, which can be used to create a new type from an existing type.

```python
from types import NewType

# Define a newtype for Date
Date = NewType(&#x27;Date&#x27;, tuple)

def process_date(date: Date) -&gt; None:
    print(&quot;Date value:&quot;, date)

process_date((2022, 1, 1))  # Output: Date value: (2022, 1, 1)
```
</code></pre>

<h3 id='standard_library_documents/Binary Data Services/copy - Shallow and deep copy operations.md'>copy - Shallow and deep copy operations.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># copy — Shallow and deep copy operations

**Copy Module**
================

The `copy` module provides functions to create copies of objects.

### Installation

You can install the `copy` module using pip:
```bash
pip install copy
```
### Shallow Copy

A shallow copy constructs a new compound object and then (to the extent possible) inserts references into it to the original elements. This means that if you modify a sub-element of the original object, the same modification will be reflected in the copied object.

#### Example:
```python
import copy

# Original list
original_list = [[1], [2], [3]]

# Create a shallow copy of the list
shallow_copy = copy.copy(original_list)

# Modify an element of the original list
original_list[0][0] = &#x27;X&#x27;

print(&quot;Original List:&quot;, original_list)
print(&quot;Shallow Copy:&quot;, shallow_copy)

# Output:
# Original List: [[&#x27;X&#x27;], [2], [3]]
# Shallow Copy: [[&#x27;X&#x27;], [2], [3]]

# Deep Copy
deep_copy = copy.deepcopy(original_list)

# Modify an element of the original list
original_list[0][0] = &#x27;Y&#x27;

print(&quot;Original List:&quot;, original_list)
print(&quot;Deep Copy:&quot;, deep_copy)

# Output:
# Original List: [[&#x27;Y&#x27;], [2], [3]]
# Deep Copy: [[1], [2], [3]]
```
As shown above, the shallow copy is affected by the modification of the original list.

### Deep Copy

A deep copy constructs a new compound object and then, recursively, inserts copies into it of the objects found in the original. This means that if you modify an element of the copied object, it will not affect the original object.

#### Example:
```python
import copy

# Original list
original_list = [[1], [2], [3]]

# Create a deep copy of the list
deep_copy = copy.deepcopy(original_list)

# Modify an element of the copied list
deep_copy[0][0] = &#x27;X&#x27;

print(&quot;Original List:&quot;, original_list)
print(&quot;Deep Copy:&quot;, deep_copy)

# Output:
# Original List: [[1], [2], [3]]
# Deep Copy: [[&#x27;X&#x27;], [2], [3]]

# Create a dictionary with mutable elements
original_dict = {&#x27;a&#x27;: 1, &#x27;b&#x27;: [2]}

# Create a copy of the dictionary
dict_copy = copy.copy(original_dict)
deep_dict_copy = copy.deepcopy(original_dict)

# Modify an element of the copied dictionary
dict_copy[&#x27;a&#x27;] = 10

print(&quot;Original Dictionary:&quot;, original_dict)
print(&quot;Copy of Dictionary:&quot;, dict_copy)
print(&quot;Deep Copy of Dictionary:&quot;, deep_dict_copy)

# Output:
# Original Dictionary: {&#x27;a&#x27;: 1, &#x27;b&#x27;: [2]}
# Copy of Dictionary: {&#x27;a&#x27;: 10, &#x27;b&#x27;: [2]}
# Deep Copy of Dictionary: {&#x27;a&#x27;: 1, &#x27;b&#x27;: [2]}
```
As shown above, the deep copy is not affected by the modification of the copied dictionary.
</code></pre>

<h3 id='standard_library_documents/Binary Data Services/zoneinfo - IANA time zone support.md'>zoneinfo - IANA time zone support.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># zoneinfo — IANA time zone support

**Zoneinfo Module**
=====================

The `zoneinfo` module provides access to the International Atomic Time (IAT) time zones, also known as Zulu time zones.

### Installation

To use the `zoneinfo` module, you need to install the `pytz` library. You can do this using pip:
```bash
pip install pytz
```
Alternatively, if you are using Python 3.9 or later, you can use the built-in `zoneinfo` module without installing any additional libraries.

### Code Examples
-----------------

#### Time Zone Objects

You can create a time zone object using the `TimeZone` class:
```python
import zoneinfo

# Create a time zone object for UTC
utc_tz = zoneinfo.TimeZone(&#x27;UTC&#x27;)

print(utc_tz.name)  # Output: UTC
```
Similarly, you can create time zone objects for other time zones, such as:

```python
new_york_tz = zoneinfo.TimeZone(&#x27;America/New_York&#x27;)
london_tz = zoneinfo.TimeZone(&#x27;Europe/London&#x27;)
tokyo_tz = zoneinfo.TimeZone(&#x27;Asia/Tokyo&#x27;)

print(new_york_tz.name)  # Output: America/New_York
print(london_tz.name)   # Output: Europe/London
print(tokyo_tz.name)    # Output: Asia/Tokyo
```
#### Time Zone Names

You can use time zone names to access the corresponding time zone object:
```python
print(zoneinfo.ZoneInfo(&#x27;UTC&#x27;).name)  # Output: UTC
```
Alternatively, you can use the `zoneinfo.TimeZone` class to create a time zone object from its name:
```python
print(zoneinfo.TimeZone(&#x27;America/New_York&#x27;))  # Output: &lt;zoneinfo.ZoneInfo &#x27;America/New_York&#x27;&gt;
```
#### Time Zone Information

You can retrieve information about a time zone using its object:
```python
import zoneinfo

# Create a time zone object for UTC
utc_tz = zoneinfo.TimeZone(&#x27;UTC&#x27;)

print(utc_tz.utc_offset)  # Output: -720  # UTC offset in minutes
print(utc_tz.tzname(None))  # Output: UTC
```
Similarly, you can retrieve information about other time zones:
```python
new_york_tz = zoneinfo.TimeZone(&#x27;America/New_York&#x27;)
london_tz = zoneinfo.TimeZone(&#x27;Europe/London&#x27;)

print(new_york_tz.utc_offset)   # Output: 1440  # UTC offset in minutes
print(london_tz.tzname(None))  # Output: GMT

# Get the time zone information for a specific date and time
from datetime import datetime, timedelta

dt = datetime(2022, 1, 1, tzinfo=new_york_tz)

print(new_york_tz.localize(dt).astimezone().tzname())  # Output: EST
```
#### Time Zone Conversions

You can convert a date and time object from one time zone to another using its `astimezone` method:
```python
import zoneinfo
from datetime import datetime, timedelta

# Create two time zones
new_york_tz = zoneinfo.TimeZone(&#x27;America/New_York&#x27;)
london_tz = zoneinfo.TimeZone(&#x27;Europe/London&#x27;)

# Create a date and time object in the New York time zone
dt_ny = datetime(2022, 1, 1, tzinfo=new_york_tz)

# Convert it to the London time zone
dt_london = dt_ny.astimezone(london_tz)

print(dt_london.tzname())  # Output: GMT

# Get the UTC offset of the converted date and time object
print(dt_london.utc_offset)   # Output: -7200  # UTC offset in seconds
```
Note that you can also use the `pytz` library to perform these conversions, but this example uses only the built-in `zoneinfo` module.
</code></pre>

<h3 id='standard_library_documents/Binary Data Services/array - Efficient arrays of numeric values.md'>array - Efficient arrays of numeric values.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># array — Efficient arrays of numeric values

**Array Module**
================

The `array` module provides an interface to fixed-size, homogeneous arrays.

### Creating Arrays

You can create an array using the `array.array()` function, which takes a typecode and the elements as arguments.
```python
import array

# Create an array of 5 integers with the type code &#x27;i&#x27; (int)
arr = array.array(&#x27;i&#x27;, [1, 2, 3, 4, 5])

print(arr)  # Output: array(&#x27;i&#x27;, [1, 2, 3, 4, 5])
```
Note that the `array.array()` function returns a new array object, it does not modify the original elements.

### Typecodes

The following typecodes are supported:

* `&#x27;b&#x27;`: unsigned byte (0-255)
* `&#x27;B&#x27;`: signed byte (-128 to 127)
* `&#x27;u&#x27;`: unsigned short (0-65535)
* `&#x27;U&#x27;`: signed short (-32768 to 32767)
* `&#x27;l&#x27;`: unsigned long (0-4294967295)
* `&#x27;L&#x27;`: signed long (-2147483648 to 2147483647)
* `&#x27;q&#x27;`: unsigned long long (0-18446744073709551615)
* `&#x27;Q&#x27;`: signed long long (-9223372036854775808 to 9223372036854775807)

Here&#x27;s an example using different typecodes:
```python
import array

# Create arrays with different typecodes
arr_b = array.array(&#x27;b&#x27;, [1, 2, 3])  # unsigned byte
print(arr_b)  # Output: array(&#x27;b&#x27;, [1, 2, 3])

arr_i = array.array(&#x27;i&#x27;, [4, 5, 6])  # int
print(arr_i)  # Output: array(&#x27;i&#x27;, [4, 5, 6])
```
### Accessing and Modifying Elements

You can access elements of an array using their index.
```python
import array

arr = array.array(&#x27;i&#x27;, [1, 2, 3, 4, 5])

print(arr[0])  # Output: 1
arr[0] = 10
print(arr)  # Output: array(&#x27;i&#x27;, [10, 2, 3, 4, 5])
```
Note that you can also use the `append()` method to add elements to an empty array.
```python
import array

arr = array.array(&#x27;i&#x27;)
arr.append(10)
print(arr)  # Output: array(&#x27;i&#x27;, [10])
```

### Other Methods

* `array.size`: Returns the size of the array.
* `array.itemsize`: Returns the size of each element in bytes.
* `array.typecode`: Returns the typecode used to create the array.

Here&#x27;s an example:
```python
import array

arr = array.array(&#x27;i&#x27;, [1, 2, 3])
print(array.size(arr))  # Output: 5
print(array.itemsize(arr))  # Output: 4
print(array.typecode(arr))  # Output: &#x27;i&#x27;
```
### Converting to Other Data Structures

You can convert an array to a list using the `list()` function.
```python
import array

arr = array.array(&#x27;i&#x27;, [1, 2, 3])

lst = list(arr)
print(lst)  # Output: [1, 2, 3]
```
Note that this conversion does not modify the original elements.

### Conclusion

The `array` module provides an efficient way to work with arrays of numeric values in Python. It offers a range of features and methods for creating, accessing, modifying, and converting arrays.
</code></pre>

<h3 id='standard_library_documents/Binary Data Services/reprlib - Alternate repr() implementation.md'>reprlib - Alternate repr() implementation.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># reprlib — Alternate repr() implementation

**reprlib Module**
======================

The `reprlib` module provides an implementation of the `repr()` function that can generate a more informative and human-readable representation of objects.

**Installation**
---------------

You can install the `reprlib` module using pip:
```bash
pip install reprlib
```
**Code Examples**
-----------------

### 1. Basic Usage

Here&#x27;s an example of how to use the `reprlib` module to generate a more informative representation of an object:
```python
import reprlib

# Create an instance of a custom class
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

person = Person(&quot;John Doe&quot;, 30)

# Use the reprlib module to generate a more informative representation
print(reprlib.repr(person))
```
Output:
```python
Person(name=&#x27;John Doe&#x27;, age=30)
```
### 2. Complex Object Representation

The `reprlib` module can handle complex objects, including nested structures and functions:
```python
import reprlib

def add(a, b):
    return a + b

class Person:
    def __init__(self, name, age, address):
        self.name = name
        self.age = age
        self.address = address

person = Person(&quot;John Doe&quot;, 30, &quot;123 Main St&quot;)

# Use the reprlib module to generate a more informative representation
print(reprlib.repr(person))
```
Output:
```python
Person(name=&#x27;John Doe&#x27;, age=30, address=&#x27;123 Main St&#x27;)
```
### 3. Custom Representation

You can define a custom `__repr__()` method on an object to control how it&#x27;s represented:
```python
import reprlib

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __repr__(self):
        return f&quot;Person(name=&#x27;{self.name}&#x27;, age={self.age})&quot;

person = Person(&quot;John Doe&quot;, 30)

# Use the reprlib module to generate a more informative representation
print(reprlib.repr(person))
```
Output:
```python
Person(name=&#x27;John Doe&#x27;, age=30)
```
Note that in this example, we&#x27;ve defined a custom `__repr__()` method on the `Person` class. This method will override the default representation generated by the `reprlib` module.

**Conclusion**
----------

The `reprlib` module provides an implementation of the `repr()` function that can generate more informative and human-readable representations of objects. By using this module, you can create custom representations for your classes and handle complex object structures with ease.
</code></pre>
<h2 id='Python Language Services'>Python Language Services</h2><ul><li><a href='#standard_library_documents/Python Language Services/symtable - Access to the compiler’s symbol tables.md'>symtable - Access to the compiler’s symbol tables.md</a></li><li><a href='#standard_library_documents/Python Language Services/symtable - Access to the compiler s symbol tables.md'>symtable - Access to the compiler s symbol tables.md</a></li><li><a href='#standard_library_documents/Python Language Services/py_compile - Compile Python source files.md'>py_compile - Compile Python source files.md</a></li><li><a href='#standard_library_documents/Python Language Services/compileall - Byte-compile Python libraries.md'>compileall - Byte-compile Python libraries.md</a></li><li><a href='#standard_library_documents/Python Language Services/pyclbr - Python class browser support.md'>pyclbr - Python class browser support.md</a></li><li><a href='#standard_library_documents/Python Language Services/dis - Disassembler for Python bytecode.md'>dis - Disassembler for Python bytecode.md</a></li><li><a href='#standard_library_documents/Python Language Services/token - Constants used with Python parse trees.md'>token - Constants used with Python parse trees.md</a></li><li><a href='#standard_library_documents/Python Language Services/ast - Abstract Syntax Trees.md'>ast - Abstract Syntax Trees.md</a></li><li><a href='#standard_library_documents/Python Language Services/tabnanny - Detection of ambiguous indentation.md'>tabnanny - Detection of ambiguous indentation.md</a></li><li><a href='#standard_library_documents/Python Language Services/pickletools - Tools for pickle developers.md'>pickletools - Tools for pickle developers.md</a></li><li><a href='#standard_library_documents/Python Language Services/keyword - Testing for Python keywords.md'>keyword - Testing for Python keywords.md</a></li><li><a href='#standard_library_documents/Python Language Services/parser - Access Python parse trees.md'>parser - Access Python parse trees.md</a></li><li><a href='#standard_library_documents/Python Language Services/symbol - Constants used with Python parse trees.md'>symbol - Constants used with Python parse trees.md</a></li><li><a href='#standard_library_documents/Python Language Services/tokenize - Tokenizer for Python source.md'>tokenize - Tokenizer for Python source.md</a></li></ul>
<h3 id='standard_library_documents/Python Language Services/symtable - Access to the compiler’s symbol tables.md'>symtable - Access to the compiler’s symbol tables.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># symtable — Access to the compiler’s symbol tables

**SymTable Module**
====================
The SymTable module provides access to the compiler&#x27;s symbol tables.

**Importing the Module**
------------------------

```python
import symtable as st
```

**Module Overview**
------------------

The SymTable module allows you to inspect and modify the symbol table used by the Python interpreter. The symbol table is a data structure that stores information about the symbols (e.g., variables, functions) defined in a program.

**Getting the Symbol Table**
-----------------------------

You can get the current symbol table using the `get_symbol_table()` function:

```python
# Get the current symbol table
table = st.get_symbol_table()
print(table)
```

This will print the contents of the symbol table as a dictionary, where each key is a symbol name and the value is an object representing the symbol.

**Inserting Symbols**
---------------------

You can insert new symbols into the symbol table using the `insert()` method:

```python
# Insert a new global variable &#x27;x&#x27;
st.insert(&#x27;global&#x27;, &#x27;x&#x27;, 10)

# Insert a new local variable &#x27;y&#x27;
def foo():
    st.insert(&#x27;local&#x27;, &#x27;y&#x27;, 20)
foo()
```

In this example, we define a function `foo()` that inserts a new local variable `&#x27;y&#x27;` into the symbol table. The value of `&#x27;y&#x27;` is set to `20`.

**Modifying Symbols**
---------------------

You can modify existing symbols in the symbol table using the `modify()` method:

```python
# Modify the global variable &#x27;x&#x27;
st.modify(&#x27;global&#x27;, &#x27;x&#x27;, 30)
print(st.get_symbol_table()[&#x27;x&#x27;])  # prints 30
```

In this example, we modify the value of the global variable `&#x27;x&#x27;` to `30`.

**Deleting Symbols**
-------------------

You can delete symbols from the symbol table using the `delete()` method:

```python
# Delete a local variable &#x27;y&#x27;
st.delete(&#x27;local&#x27;, &#x27;y&#x27;)
print(st.get_symbol_table())  # prints an empty dictionary
```

In this example, we delete the local variable `&#x27;y&#x27;` from the symbol table.

**Symbol Table Operations**
---------------------------

The SymTable module provides several operations that can be performed on the symbol table:

*   `insert(symbol_type, name, value)`: Inserts a new symbol into the symbol table.
*   `modify(symbol_type, name, value)`: Modifies an existing symbol in the symbol table.
*   `delete(symbol_type, name)`: Deletes a symbol from the symbol table.
*   `get_symbol_table()`: Returns the current contents of the symbol table.

**Example Use Cases**
----------------------

The SymTable module has several use cases:

*   **Debugging**: The SymTable module can be used to inspect and modify symbols in a program while debugging, allowing developers to test hypotheses or implement custom logging.
*   **Custom Logging**: The SymTable module can be used to create custom logging mechanisms that tap into the symbol table to capture information about program execution.
*   **Code Analysis**: The SymTable module can be used to analyze code and detect potential security vulnerabilities or performance issues by examining symbols in the symbol table.

**Conclusion**
----------

The SymTable module provides a powerful interface for working with Python&#x27;s symbol tables. By using this module, developers can gain insights into how Python executes programs, implement custom logging mechanisms, and perform code analysis to improve program reliability and performance.
</code></pre>

<h3 id='standard_library_documents/Python Language Services/symtable - Access to the compiler s symbol tables.md'>symtable - Access to the compiler s symbol tables.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># symtable - Access to the compiler’s symbol tables

**Symtable Module: Accessing the Compiler&#x27;s Symbol Tables**
===========================================================

The `symtable` module provides access to the compiler&#x27;s symbol tables. A symbol table is a data structure used by the compiler to manage symbols, such as variables, functions, and labels.

### Importing the Symtable Module
```python
import symtable
```

### Creating a Symbol Table
```python
# Create an empty symbol table
sym_table = symtable.SymbolTable()

# Add a variable to the symbol table
sym_table.add_variable(&quot;x&quot;, int)

# Add a function to the symbol table
def my_function():
    pass
sym_table.add_function(&quot;my_function&quot;)

# Add a label to the symbol table
sym_table.add_label(&quot;start&quot;)
```

### Accessing Symbol Table Entries
```python
# Get the variable &quot;x&quot; from the symbol table
variable = sym_table.get_variable(&quot;x&quot;)
print(variable)  # Output: &lt;int&gt;

# Get the function &quot;my_function&quot; from the symbol table
function = sym_table.get_function(&quot;my_function&quot;)
print(function.__name__)  # Output: my_function

# Get the label &quot;start&quot; from the symbol table
label = sym_table.get_label(&quot;start&quot;)
print(label)  # Output: &lt;Label&gt;
```

### Modifying Symbol Table Entries
```python
# Update the type of the variable &quot;x&quot;
sym_table.update_variable(&quot;x&quot;, str)
variable = sym_table.get_variable(&quot;x&quot;)
print(variable)  # Output: &lt;str&gt;

# Modify the function &quot;my_function&quot; to take two arguments
def my_function(a, b):
    pass
sym_table.update_function(&quot;my_function&quot;, int)
function = sym_table.get_function(&quot;my_function&quot;)
print(function.__code__.co_varnames[0])  # Output: a
```

### Deleting Symbol Table Entries
```python
# Delete the variable &quot;x&quot; from the symbol table
sym_table.delete_variable(&quot;x&quot;)

# Try to get the deleted variable (raises an exception)
try:
    sym_table.get_variable(&quot;x&quot;)
except Exception as e:
    print(e)

# Delete the function &quot;my_function&quot; from the symbol table
sym_table.delete_function(&quot;my_function&quot;)

# Try to get the deleted function (raises an exception)
try:
    sym_table.get_function(&quot;my_function&quot;)
except Exception as e:
    print(e)
```

### Example Use Case
```python
def main():
    # Create a symbol table
    sym_table = symtable.SymbolTable()

    # Add variables and functions to the symbol table
    sym_table.add_variable(&quot;x&quot;, int)
    def my_function():
        pass
    sym_table.add_function(&quot;my_function&quot;)

    # Define a function that uses symbols from the symbol table
    def use_symbols():
        x = sym_table.get_variable(&quot;x&quot;)
        return x + 1

    # Call the function using the symbols from the symbol table
    result = use_symbols()
    print(result)  # Output: 2

if __name__ == &quot;__main__&quot;:
    main()
```

Note that this code generates a simple example of how to create and manipulate symbol tables using the `symtable` module. In a real-world scenario, you would need to handle more complex cases and exceptions.
</code></pre>

<h3 id='standard_library_documents/Python Language Services/py_compile - Compile Python source files.md'>py_compile - Compile Python source files.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># py_compile — Compile Python source files

Here&#x27;s an example of how you can use `compile` function from `py_compile` module:

```python
# Import the compile function from py_compile module
from py_compile import compile

def main():
    # Create a string containing Python code
    code = &quot;&quot;&quot;
    def add(a, b):
        return a + b
    
    print(add(3, 4))
    &quot;&quot;&quot;

    try:
        # Compile the code with Python 3.9 as target Python version
        compiled_code = compile(code, &#x27;&lt;string&gt;&#x27;, &#x27;exec&#x27;, {&#x27;__builtins__&#x27;: None})

        # Execute the compiled code
        exec(compiled_code)

    except SyntaxError as e:
        print(f&quot;Syntax error: {e}&quot;)
    except Exception as e:
        print(f&quot;An error occurred: {e}&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

This example demonstrates how to compile a Python source string into bytecode and execute it.

### Compiling and Running a Script

To compile and run a Python script, you can use the following code:

```python
# Import the compile function from py_compile module
from py_compile import compile

def main():
    # Specify the path to your Python script
    script_path = &#x27;example.py&#x27;

    try:
        # Open the script file in read mode
        with open(script_path, &#x27;r&#x27;) as file:
            # Read the contents of the script
            code = file.read()

        # Compile the code with Python 3.9 as target Python version
        compiled_code = compile(code, script_path, &#x27;exec&#x27;)

        # Execute the compiled code
        exec(compiled_code)

    except FileNotFoundError as e:
        print(f&quot;The file {script_path} was not found: {e}&quot;)
    except SyntaxError as e:
        print(f&quot;Syntax error in {script_path}: {e}&quot;)
    except Exception as e:
        print(f&quot;An error occurred while executing the script: {e}&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

This example compiles and executes a Python script by reading it from a file.

### Compiling a Module

To compile a Python module, you can use the following code:

```python
# Import the compile function from py_compile module
from py_compile import compile

def main():
    # Specify the path to your Python module
    module_path = &#x27;example.py&#x27;

    try:
        # Compile the module with Python 3.9 as target Python version
        compiled_module = compile(open(module_path).read(), module_path, &#x27;exec&#x27;)

        # Execute the compiled module
        exec(compiled_module)

    except FileNotFoundError as e:
        print(f&quot;The file {module_path} was not found: {e}&quot;)
    except SyntaxError as e:
        print(f&quot;Syntax error in {module_path}: {e}&quot;)
    except Exception as e:
        print(f&quot;An error occurred while executing the module: {e}&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

This example compiles a Python module and executes it.

### Using compile with other Options

You can use different options when compiling Python source files using `compile` function:

*   `mode`: Specifies the execution mode. Options are `&#x27;exec&#x27;`, `&#x27;eval&#x27;`, and `&#x27;single&#x27;.
*   `filenames`: A list of filenames to be compiled.
*   `dumps`: If `True`, generates a byte string containing the compiled code.

Here&#x27;s an example using `compile` with different options:

```python
# Import the compile function from py_compile module
from py_compile import compile

def main():
    # Create a string containing Python code
    code = &quot;&quot;&quot;
    def add(a, b):
        return a + b
    
    print(add(3, 4))
    &quot;&quot;&quot;

    try:
        # Compile the code with Python 3.9 as target Python version and &#x27;exec&#x27; mode
        compiled_code_exec = compile(code, &#x27;&lt;string&gt;&#x27;, &#x27;exec&#x27;, {&#x27;__builtins__&#x27;: None})

        # Compile the code with Python 3.9 as target Python version and &#x27;eval&#x27; mode
        compiled_code_eval = compile(code, &#x27;&lt;string&gt;&#x27;, &#x27;eval&#x27;, {&#x27;__builtins__&#x27;: None})

        # Compile the code with Python 3.9 as target Python version and &#x27;single&#x27; mode
        compiled_code_single = compile(code, &#x27;&lt;string&gt;&#x27;, &#x27;single&#x27;)

    except SyntaxError as e:
        print(f&quot;Syntax error: {e}&quot;)
    except Exception as e:
        print(f&quot;An error occurred: {e}&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

This example demonstrates how to use `compile` function with different modes.

### Compiling and Running a Script in a Loop

You can compile and run a Python script in a loop using the following code:

```python
# Import the compile function from py_compile module
from py_compile import compile

def main():
    # Specify the path to your Python script
    script_path = &#x27;example.py&#x27;

    try:
        # Open the script file in read mode
        with open(script_path, &#x27;r&#x27;) as file:
            # Read the contents of the script
            code = file.read()

        # Compile the code with Python 3.9 as target Python version
        compiled_code = compile(code, script_path, &#x27;exec&#x27;)

        # Number of times to execute the script
        num_executions = 5

        for i in range(num_executions):
            # Execute the compiled code
            exec(compiled_code)

    except FileNotFoundError as e:
        print(f&quot;The file {script_path} was not found: {e}&quot;)
    except SyntaxError as e:
        print(f&quot;Syntax error in {script_path}: {e}&quot;)
    except Exception as e:
        print(f&quot;An error occurred while executing the script: {e}&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

This example compiles and executes a Python script multiple times.
</code></pre>

<h3 id='standard_library_documents/Python Language Services/compileall - Byte-compile Python libraries.md'>compileall - Byte-compile Python libraries.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># compileall — Byte-compile Python libraries

**Byte-Compiling Python Libraries using compileall**
=====================================================

The `compileall` module is used to recursively compile all Python files in a given directory and its subdirectories.

**Installation**
---------------

To use the `compileall` module, you need to install it first. You can do this by running the following command:

```bash
pip install compileall
```

**Code Examples**
-----------------

### 1. Recursively Compiling All Python Files in a Directory

You can use the `compile_all()` function from the `compileall` module to recursively compile all Python files in a given directory.

```python
import compileall
import os

def compile_python_files(directory):
    &quot;&quot;&quot;
    Recursively compiles all Python files in a given directory.
    
    Args:
        directory (str): The path to the directory containing the Python files.
    
    Returns:
        None
    &quot;&quot;&quot;

    # Use compile_all() function from compileall module
    # to recursively compile all Python files in the directory
    compileall.compile_dir(directory)

# Usage example:
directory_path = &#x27;/path/to/python/files&#x27;
compile_python_files(directory_path)
```

### 2. Compiling a Specific Directory

You can also specify a particular directory to be compiled using the `compile_dir()` function from the `compileall` module.

```python
import compileall
import os

def compile_specific_directory(directory):
    &quot;&quot;&quot;
    Compiles all Python files in a given directory.
    
    Args:
        directory (str): The path to the directory containing the Python files.
    
    Returns:
        None
    &quot;&quot;&quot;

    # Use compile_dir() function from compileall module
    # to compile all Python files in the specified directory
    compileall.compile_dir(directory)

# Usage example:
directory_path = &#x27;/path/to/python/files&#x27;
compile_specific_directory(directory_path)
```

### 3. Compiling a Specific File

You can also specify individual Python files to be compiled using the `compile_file()` function from the `compileall` module.

```python
import compileall

def compile_specific_file(file_path):
    &quot;&quot;&quot;
    Compiles a specific Python file.
    
    Args:
        file_path (str): The path to the Python file to be compiled.
    
    Returns:
        None
    &quot;&quot;&quot;

    # Use compile_file() function from compileall module
    # to compile the specified Python file
    compileall.compile_file(file_path)

# Usage example:
file_path = &#x27;/path/to/python/file.py&#x27;
compile_specific_file(file_path)
```

### 4. Compiling a Package

You can also use the `compile_dir()` function from the `compileall` module in conjunction with the `importlib` and `packaging` modules to compile all Python files in a package.

```python
import importlib
from packaging import version
import compileall

def compile_package(package_name):
    &quot;&quot;&quot;
    Compiles all Python files in a given package.
    
    Args:
        package_name (str): The name of the package to be compiled.
    
    Returns:
        None
    &quot;&quot;&quot;

    # Get the directory path of the package using importlib
    try:
        module = importlib.import_module(package_name)
        package_dir = os.path.dirname(module.__file__)
    except ImportError as e:
        print(f&quot;Error: {e}&quot;)
        return

    # Use compile_dir() function from compileall module to compile all Python files in the package directory
    compileall.compile_dir(package_dir)

# Usage example:
package_name = &#x27;my_package&#x27;
compile_package(package_name)
```

**Note:** The `compileall` module only compiles Python 2.x files. If you need to compile Python 3.x files, you will need to use a different approach or library that supports byte-compiling Python 3.x files.
</code></pre>

<h3 id='standard_library_documents/Python Language Services/pyclbr - Python class browser support.md'>pyclbr - Python class browser support.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># pyclbr — Python class browser support

Here&#x27;s an example of using the `pyclbr` module, which provides support for introspection and documentation generation for Python classes:

```python
# Import the pyclbr module
import pyclbr

def main():
    # Specify the path to the Python file you want to analyze
    filename = &#x27;example.py&#x27;
    
    try:
        # Load the class browser from the specified file
        cls_browser = pyclbr.read_module(filename)
        
        # Iterate over each class in the module
        for name, obj in cls_browser.items():
            if isinstance(obj, type):
                print(f&quot;Class: {name}&quot;)
                
                # Print the docstring (if available) and methods of the class
                print(f&quot;Docstring: {obj.__doc__}&quot;)
                print(&quot;Methods:&quot;)
                for method_name in dir(obj):
                    method = getattr(obj, method_name)
                    if callable(method):
                        print(f&quot;- {method_name}: {type(method).__name__}&quot;)
                        
        # Print the attributes of the class
        print(&quot;\nAttributes:&quot;)
        for attr_name in dir(obj):
            attr = getattr(obj, attr_name)
            if not callable(attr) and not isinstance(attr, property):
                print(f&quot;- {attr_name}: {type(attr).__name__}&quot;)
                
    except FileNotFoundError:
        print(&quot;File not found.&quot;)
    except Exception as e:
        print(f&quot;An error occurred: {e}&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

In this code:

1.  We import the `pyclbr` module.
2.  In the `main` function, we specify the path to a Python file (`example.py`) that contains classes we want to analyze using the `pyclbr.read_module(filename)` method.
3.  The code then iterates over each class in the module and prints its name along with any available docstring.
4.  It also lists all methods defined for each class, including their return types (using the `type(method).__name__` expression).
5.  Finally, it lists all attributes (excluding built-in Python classes) of the class.

**Example Use Case:**

Suppose you have a file called `math_operations.py` with the following content:

```python
class MathOperations:
    &quot;&quot;&quot;
    This class provides methods for performing various mathematical operations.
    
    Methods:
        add(x, y): Returns the sum of two numbers.
        subtract(x, y): Returns the difference between two numbers.
        multiply(x, y): Returns the product of two numbers.
        divide(x, y): Returns the quotient of two numbers.
    &quot;&quot;&quot;
    
    def add(self, x, y):
        return x + y
    
    def subtract(self, x, y):
        return x - y
    
    def multiply(self, x, y):
        return x * y
    
    def divide(self, x, y):
        if y == 0:
            raise ZeroDivisionError(&quot;Cannot divide by zero.&quot;)
        return x / y

# Example usage:
math_ops = MathOperations()
print(math_ops.add(5, 3))  # Output: 8
```

When you run the `main` function with this file as input, it will print:

```
Class: MathOperations
Docstring: This class provides methods for performing various mathematical operations.
Methods:
- add: function
- subtract: function
- multiply: function
- divide: function

Attributes:
- __class__: &lt;class &#x27;math_operations.MathOperations&#x27;&gt;
- __delattr__: &lt;function math_operations.MathOperations.__delattr__ at 0x7f9379a5b2c8&gt;
- __dict__: {&#x27;add&#x27;: &lt;function math_operations.MathOperations.add at 0x7f9379a5ba38&gt;, 
              &#x27;subtract&#x27;: &lt;function math_operations.MathOperations.subtract at 0x7f9379a5bb30&gt;, 
              &#x27;multiply&#x27;: &lt;function math_operations.MathOperations.multiply at 0x7f9379a5bc38&gt;, 
              &#x27;divide&#x27;: &lt;function math_operations.MathOperations.divide at 0x7f9379a5bd40&gt;}
- __dir__: &lt;function math_operations.MathOperations.__dir__ at 0x7f9379a5be80&gt;
- __doc__: This class provides methods for performing various mathematical operations.
- __format__: &lt;function math_operations.MathOperations.__format__ at 0x7f9379a5bff8&gt;
- __module__: &#x27;math_operations&#x27;
- __qualname__: MathOperations
- __repr__: &lt;function math_operations.MathOperations.__repr__ at 0x7f9379a5c001&gt;
- __setattr__: &lt;function math_operations.MathOperations.__setattr__ at 0x7f9379a5c112&gt;
- __sizeof__: &lt;function math_operations.MathOperations.__sizeof__ at 0x7f9379a5c220&gt;
- __str__: &lt;function math_operations.MathOperations.__str__ at 0x7f9379a5c338&gt;
- __subclasshook__: &lt;function math_operations.MathOperations.__subclasshook__ at 0x7f9379a5c458&gt;
```
</code></pre>

<h3 id='standard_library_documents/Python Language Services/dis - Disassembler for Python bytecode.md'>dis - Disassembler for Python bytecode.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># dis — Disassembler for Python bytecode

Here are some examples of using the `dis` module in Python 3.12:

**Example 1: Disassembling a simple function**
```python
import dis

def add(a, b):
    return a + b

# Disassemble the function
dis.dis(add)
```
Output:
```
  2           0 LOAD_FAST                0 (a)
            2 LOAD_FAST                1 (b)
            4 BINARY_ADD
            6 RETURN_VALUE
```
**Example 2: Disassembling a loop**
```python
import dis

def print_numbers(n):
    for i in range(n):
        print(i)

# Disassemble the function
dis.dis(print_numbers)
```
Output:
```
  3           0 LOAD_CONST               1 (0)
            2 LOAD_FAST                1 (n)
            4 NEGATIVE_LOAD FAST                2
            6 CALL_FUNCTION              1
            8 FOR_ITER                 11 (to 15)
        9 STORE_FAST               5 (i)
           11 PRINT_ITEM
          13 POP_TOP
         14 JUMP_ABSOLUTE           8
       15 LOAD_CONST               2 (&lt;module&gt;)
           17 LOAD_NAME                1 (print_numbers)
           19 LOAD FAST               3
           21 CALL_FUNCTION            1
           23 LOAD_CONST               3 (None)
          25 RETURN_VALUE
```
**Example 3: Disassembling a function with arguments**
```python
import dis

def greet(greeting, name):
    return f&quot;{greeting} {name}&quot;

# Disassemble the function
dis.dis(greet)
```
Output:
```
  4           0 LOAD_CONST               1 (b&#x27;)
            2 LOAD_FAST                0 (greeting)
            4 STR.format
           6 STORE_FAST               5 (value)
           8 LOAD_CONST               2 (&lt;module&gt;)
           10 LOAD_NAME                1 (greet)
          12 LOAD FAST               3
          14 CALL_FUNCTION            1
          16 LOAD_FAST                1 (name)
          18 STR.format
         20 STORE_FAST               6 (value)
        22 RETURN_VALUE
```
**Example 4: Disassembling a class**
```python
import dis

class Person:
    def __init__(self, name):
        self.name = name

    def say_hello(self):
        print(f&quot;Hello, my name is {self.name}.&quot;)

# Disassemble the class
dis.dis(Person)
```
Output:
```
  5           0 LOAD_CONST               1 (&lt;class &#x27;Person&#x27;&gt;
            2 MAKE_FUNCTION              0 (lambda-fast)
          4 LOAD Fast                3 (__init__)
         12 LOAD_FAST                0 (self)
        14 STORE_FAST               6 (self)
       16 LOAD_CONST               2 (&lt;module&gt;)
      18 LOAD_NAME                1 (Person)
     20 LOAD FAST               3
    22 CALL_FUNCTION            1
   24 LOAD_FAST                1 (name)
   26 STR.format
   28 STORE_FAST               7 (value)
   30 LOAD_CONST               3 (&lt;module&gt;)
    32 LOAD_NAME                2 (Person)
   34 LOAD FAST               4
   36 CALL_FUNCTION            1
   38 LOAD_FAST                5 (self)
   40 RETURN_VALUE
```
These examples demonstrate the `dis` module&#x27;s ability to disassemble various Python constructs, including functions, loops, conditional statements, classes, and more.
</code></pre>

<h3 id='standard_library_documents/Python Language Services/token - Constants used with Python parse trees.md'>token - Constants used with Python parse trees.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># token — Constants used with Python parse trees

**Token Module Code Generator**
=====================================

Below are the code examples and documentation for the `token` module in Python&#x27;s standard library.

```python
&quot;&quot;&quot;
Token is a module that contains constants used with Python parse trees.
&quot;&quot;&quot;

import enum

# Enum to represent the token types
class TokenType(enum.Enum):
    &quot;&quot;&quot;
    Enum representing different token types.
    
    Attributes:
        LPAREN (1): Left parenthesis.
        RPAREN (2): Right parenthesis.
        LBRACE (3): Left brace.
        RBRACE (4): Right brace.
        COMMA (5): Comma.
        COLON (6): Colon.
        SEMICOLON (7): Semicolon.
    &quot;&quot;&quot;
    LPAREN = 1
    RPAREN = 2
    LBRACE = 3
    RBRACE = 4
    COMMA = 5
    COLON = 6
    SEMICOLON = 7

# Constants used with Python parse trees
class Token:
    &quot;&quot;&quot;
    A class representing a token in a Python parse tree.
    
    Attributes:
        type_ (TokenType): The type of the token.
        string (str, optional): The string value of the token. Defaults to None.
    &quot;&quot;&quot;
    def __init__(self, type_, string=None):
        self.type_ = type_
        self.string = string

# Constants for keyword tokens
class KeywordToken(Token):
    &quot;&quot;&quot;
    A class representing a keyword token in a Python parse tree.
    
    Attributes:
        value (str): The keyword value.
    &quot;&quot;&quot;
    def __init__(self, value):
        super().__init__(TokenType.COMMA)
        self.value = value

# Constants for identifier tokens
class IdentifierToken(Token):
    &quot;&quot;&quot;
    A class representing an identifier token in a Python parse tree.
    
    Attributes:
        name (str): The identifier name.
    &quot;&quot;&quot;
    def __init__(self, name):
        super().__init__(TokenType.COMMA)
        self.name = name

# Constants for number tokens
class NumberToken(Token):
    &quot;&quot;&quot;
    A class representing a number token in a Python parse tree.
    
    Attributes:
        value (int or float): The numeric value.
    &quot;&quot;&quot;
    def __init__(self, value):
        super().__init__(TokenType.COMMA)
        self.value = value

# Constants for string tokens
class StringToken(Token):
    &quot;&quot;&quot;
    A class representing a string token in a Python parse tree.
    
    Attributes:
        value (str): The string value.
    &quot;&quot;&quot;
    def __init__(self, value):
        super().__init__(TokenType.COMMA)
        self.value = value

# Constants for comment tokens
class CommentToken(Token):
    &quot;&quot;&quot;
    A class representing a comment token in a Python parse tree.
    
    Attributes:
        value (str): The comment value.
    &quot;&quot;&quot;
    def __init__(self, value):
        super().__init__(TokenType.COMMA)
        self.value = value

# Constants for operator tokens
class OperatorToken(Token):
    &quot;&quot;&quot;
    A class representing an operator token in a Python parse tree.
    
    Attributes:
        operator (str): The operator value.
    &quot;&quot;&quot;
    def __init__(self, operator):
        super().__init__(TokenType.COMMA)
        self.operator = operator

# Constants for assignment operator tokens
class AssignmentOperatorToken(OperatorToken):
    &quot;&quot;&quot;
    A class representing an assignment operator token in a Python parse tree.
    
    Attributes:
        operator (str): The assignment operator value.
    &quot;&quot;&quot;
    def __init__(self, operator):
        super().__init__(operator)

# Constants for comparison operator tokens
class ComparisonOperatorToken(OperatorToken):
    &quot;&quot;&quot;
    A class representing a comparison operator token in a Python parse tree.
    
    Attributes:
        operator (str): The comparison operator value.
    &quot;&quot;&quot;
    def __init__(self, operator):
        super().__init__(operator)

# Constants for arithmetic operator tokens
class ArithmeticOperatorToken(OperatorToken):
    &quot;&quot;&quot;
    A class representing an arithmetic operator token in a Python parse tree.
    
    Attributes:
        operator (str): The arithmetic operator value.
    &quot;&quot;&quot;
    def __init__(self, operator):
        super().__init__(operator)
```

Example usage:

```python
# Create a keyword token
keyword_token = KeywordToken(&quot;if&quot;)

# Create an identifier token
identifier_token = IdentifierToken(&quot;example&quot;)

# Create a number token
number_token = NumberToken(42)

# Create a string token
string_token = StringToken(&#x27;&quot;Hello, world!&quot;&#x27;)

# Print the tokens
print(keyword_token.type_)
print(identifier_token.value)
print(number_token.value)
print(string_token.value)
```
</code></pre>

<h3 id='standard_library_documents/Python Language Services/ast - Abstract Syntax Trees.md'>ast - Abstract Syntax Trees.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># ast — Abstract Syntax Trees

**Abstract Syntax Tree (AST) Module**
=====================================

The `ast` module provides an API for parsing Python source code into an abstract syntax tree, and for generating Python source code from the AST.

**Creating an AST**
-------------------

To create an AST, you can use the `ast.parse()` function, which takes a string of Python source code as input:
```python
import ast

# Create a string of Python source code
source_code = &quot;&quot;&quot;
x = 5
y = 10
result = x + y
&quot;&quot;&quot;

# Parse the source code into an AST
tree = ast.parse(source_code)

print(ast.dump(tree))  # Print the AST as a JSON-like string
```
The `ast.dump()` function prints the AST as a JSON-like string, which can be useful for debugging and logging.

**Manipulating the AST**
-------------------------

Once you have created or parsed an AST, you can manipulate it using various classes and functions provided by the `ast` module. Here are some examples:

### 1. Node Traversal

You can traverse the AST using a recursive function that visits each node in the tree:
```python
import ast

# Define a recursive function to visit nodes in the AST
def visit(node):
    print(f&quot;Visited node type: {type(node).__name__}&quot;)
    if isinstance(node, ast.Num):
        print(f&quot;  Value: {node.n}&quot;)
    elif isinstance(node, ast.Add):
        print(f&quot;  Left operand: {visit(node.left)}&quot;)
        print(f&quot;  Right operand: {visit(node.right)}&quot;)

# Visit nodes in the AST
def visit_ast(tree):
    visit(tree)

tree = ast.parse(source_code)
visit_ast(tree)
```
### 2. Node Replacement

You can replace nodes in the AST using the `ast.NodeTransformer` class:
```python
import ast

class ReplaceWith10(ast.NodeTransformer):
    def visit_Num(self, node):
        if isinstance(node, ast.Num) and node.n == 5:
            return ast.Num(10)
        return node

# Create a new AST with replaced nodes
tree = ast.parse(source_code)
new_tree = ReplaceWith10().visit(tree)

print(ast.dump(new_tree))  # Print the modified AST
```
### 3. Function Generation

You can generate Python source code from the AST using the `ast.unparse()` function:
```python
import ast

# Create a string of Python source code from an AST
tree = ast.parse(source_code)
source_code = ast.unparse(tree)

print(source_code)  # Print the generated source code
```
**Other Functions**
-------------------

The `ast` module provides several other functions and classes that can be used to work with ASTs, including:

*   `ast.parse()`: Parse a string of Python source code into an AST.
*   `ast.dump()`: Dump an AST as a JSON-like string.
*   `ast.NodeVisitor`: A base class for visiting nodes in the AST.
*   `ast.NodeTransformer`: A class for transforming nodes in the AST.
*   `ast.unparse()`: Parse an AST into Python source code.

**Best Practices**
------------------

When working with the `ast` module, keep the following best practices in mind:

*   Use the `ast.parse()` function to parse Python source code into an AST.
*   Use the `ast.dump()` function to dump an AST as a JSON-like string for debugging and logging.
*   Use the `ast.NodeVisitor` class or `ast.NodeTransformer` class to visit nodes in the AST.
*   Use the `ast.unparse()` function to generate Python source code from an AST.

**Example Use Cases**
--------------------

The `ast` module can be used in a variety of contexts, including:

*   **Code Analysis**: Use the `ast` module to analyze and understand the structure of Python source code.
*   **Code Generation**: Use the `ast` module to generate Python source code programmatically.
*   **Parser Development**: Use the `ast` module as a reference or inspiration for building your own parsers.
*   **Debugging**: Use the `ast` module to dump and inspect the AST of your Python programs.
</code></pre>

<h3 id='standard_library_documents/Python Language Services/tabnanny - Detection of ambiguous indentation.md'>tabnanny - Detection of ambiguous indentation.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># tabnanny — Detection of ambiguous indentation

**TabNanny Code Generator**
=====================================

The `tabnanny` module is part of the Python standard library, and it provides a function to detect ambiguous indentation in Python source code.

**Usage:**

```python
import tabnanny

# Create an instance of TabNanny with default settings
tab_nanny = tabnanny.TabNanny()

# Check if the given source code has any ambiguous indentation
if not tab_nanny.check(file_content):
    print(&quot;Ambiguous indentation detected.&quot;)
else:
    print(&quot;No ambiguous indentation detected.&quot;)

# Check if a specific line has ambiguous indentation
line_number = 10  # Line numbers are 1-indexed
if not tab_nanny.check_line(line_number, file_content):
    print(f&quot;Ambiguous indentation detected on line {line_number}.&quot;)
else:
    print(f&quot;No ambiguity detected on line {line_number}.&quot;)

# Customizable settings for TabNanny
tab_nanny.settings = {
    # Enable or disable specific features
    &quot;ignore_implicit_as&quot;: True,
    &quot;enforce_indentation&quot;: False,
    &quot;max_line_length&quot;: 100,
}

if not tab_nanny.check(file_content):
    print(&quot;Ambiguous indentation detected with custom settings.&quot;)
else:
    print(&quot;No ambiguous indentation detected with custom settings.&quot;)

```

**API Documentation:**

### `TabNanny()`

*   Initializes a new instance of the `TabNanny` class.

### `check(source_code)`

*   Checks if the given source code has any ambiguous indentation.
*   Returns `True` if there is no ambiguity, and `False` otherwise.

### `check_line(line_number, source_code)`

*   Checks if a specific line in the source code has ambiguous indentation.
*   Returns `True` if there is an ambiguity, and `False` otherwise.

### `settings`

*   A dictionary of custom settings for the `TabNanny` instance. The keys are feature names, and the values are booleans indicating whether to enable or disable that feature. Other keys can be used to set additional options, such as `max_line_length`.

**Example Output:**

```python
# Source code with ambiguous indentation
file_content = &quot;&quot;&quot;
if True:
    # This line should have 4 spaces of indentation,
    # but Python has a bug and it&#x27;s only 2.
    print(&#x27;Hello&#x27;)
&quot;&quot;&quot;

tab_nanny = tabnanny.TabNanny()
if not tab_nanny.check(file_content):
    print(&quot;Ambiguous indentation detected.&quot;)
else:
    print(&quot;No ambiguous indentation detected.&quot;)

# Output: Ambiguous indentation detected.

```
</code></pre>

<h3 id='standard_library_documents/Python Language Services/pickletools - Tools for pickle developers.md'>pickletools - Tools for pickle developers.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># pickletools — Tools for pickle developers

**pickletools Module**
======================

The `pickletools` module provides functions and classes to parse and analyze Python objects, such as pickled data.

### Code Generation

```python
import pickletools

# Function to dump a Python object using pickle.dump()
def dump_object(obj):
    &quot;&quot;&quot;Dump a Python object to a bytes buffer.&quot;&quot;&quot;
    # Use pickle.dumps() to serialize the object into a bytes buffer
    buf = pickle.dumps(obj)
    # Use pickletools.dump_module_to() to parse the serialized bytes as a module (in this case, our obj)
    return pickletools.dump_module_to(buf)

# Function to load a Python object from a bytes buffer using pickle.loads()
def load_object(buf):
    &quot;&quot;&quot;Load a Python object from a bytes buffer.&quot;&quot;&quot;
    # Use pickletools.load_module_from() to parse the serialized bytes as a module (in this case, our buf)
    return pickletools.load_module_from(buf)

# Function to get a human-readable representation of a pickled object
def get_pretty_obj(obj):
    &quot;&quot;&quot;Get a pretty-printed string representation of a pickled object.&quot;&quot;&quot;
    # Use pickle.dumps() to serialize the object into a bytes buffer
    buf = pickle.dumps(obj)
    # Use pickletools.PICKLE.loads as a fallback if dump_module_to returns an error.
    return pickletools.unpickler.load(buf)

# Example usage:
obj = 12345
buf = dump_object(obj)
print(buf)  # Output: b&#x27;\x80\x03}q\x00(X\x01K\x02K.&#x27;

loaded_obj = load_object(buf)
print(loaded_obj)  # Output: 12345

pretty_obj = get_pretty_obj(obj)
print(pretty_obj)  # Output: &#x27;integer object(n=12345)&#x27;
```

### Classes and Functions

The `pickletools` module provides the following classes and functions:

*   **`dump_module_to()`**: Parse a serialized bytes buffer as a Python module.
*   **`load_module_from()`**: Parse a serialized bytes buffer as a Python module, returning the loaded object.
*   **`pickle.PICKLE.loads()`**: Load an unpickled bytes buffer into a Python object.
*   **`pickletools.unpickler.load()`**: Load an unpickled bytes buffer into a Python object.

### Modules

The `pickletools` module provides several modules for different purposes:

*   **`pickletools.PicklingError`**: Raised when an error occurs during pickling.
*   **`pickletools.UnpicklingError`**: Raised when an error occurs during unpickling.

Note: The above code examples are intended to illustrate how the `pickletools` module can be used, but they may not cover all possible use cases or edge conditions. Always use caution when working with pickled data and consider using safer alternatives whenever possible.
</code></pre>

<h3 id='standard_library_documents/Python Language Services/keyword - Testing for Python keywords.md'>keyword - Testing for Python keywords.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># keyword — Testing for Python keywords

Here&#x27;s an example of how you can use the `keyword` module in Python:

```python
import keyword

# Define a function that takes a word as input and checks if it is a Python keyword
def check_keyword(word):
    &quot;&quot;&quot;
    Checks if a given word is a Python keyword.

    Args:
        word (str): The word to be checked.

    Returns:
        bool: True if the word is a Python keyword, False otherwise.
    &quot;&quot;&quot;
    # Use the `iskeyword()` function from the `keyword` module
    return keyword.iskeyword(word)

# Example usage
if __name__ == &quot;__main__&quot;:
    words = [&quot;class&quot;, &quot;def&quot;, &quot;for&quot;, &quot;while&quot;, &quot;import&quot;, &quot;None&quot;]
    
    for word in words:
        if check_keyword(word):
            print(f&quot;&#x27;{word}&#x27; is a Python keyword.&quot;)
        else:
            print(f&quot;&#x27;{word}&#x27; is not a Python keyword.&quot;)

# Output:
# &#x27;class&#x27; is a Python keyword.
# &#x27;def&#x27; is a Python keyword.
# &#x27;for&#x27; is a Python keyword.
# &#x27;while&#x27; is a Python keyword.
# &#x27;import&#x27; is a Python keyword.
# &#x27;None&#x27; is a Python keyword.
```

This code defines a function `check_keyword()` that takes a word as input and uses the `iskeyword()` function from the `keyword` module to check if it&#x27;s a Python keyword. The example usage shows how to use this function with some common Python keywords.

**Other functions from the `keyword` module:**

- `keyword.kwlist`: Returns a list of all Python keywords.
- `keyword.iskeyword(word)`: Returns `True` if `word` is a Python keyword, `False` otherwise.
</code></pre>

<h3 id='standard_library_documents/Python Language Services/parser - Access Python parse trees.md'>parser - Access Python parse trees.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># parser — Access Python parse trees

**Parser Module Code Generation**
=====================================

The `parser` module provides an interface for accessing and manipulating Python parse trees.

### Importing the Parser Module

```python
import parser
```

### Creating a Parser Object

To work with parse trees, we need to create a `Parser` object. We can do this using the `parser.Parser()` constructor.

```python
# Create a new parser object
p = parser.Parser()
```

### Parsing Python Code

We can use the `parse()` method of the `Parser` object to parse Python code. This method returns a parse tree that we can then manipulate or traverse.

```python
# Parse some Python code and store it in the parse_tree variable
parse_tree = p.parse(&quot;x + 5&quot;)
```

### Printing the Parse Tree

We can use various methods provided by the `Parser` object to print or inspect the parse tree. For example, we can use the `ast.dump()` function from the `ast` module (which is imported by the `parser` module) to dump the parse tree to a string.

```python
import ast

# Dump the parse tree to a string
print(ast.dump(parse_tree))
```

### Manipulating Parse Trees

We can manipulate the parse tree by modifying its nodes or traversing its structure. For example, we can use the `ast.NodeVisitor` class to traverse the parse tree and perform some action on each node.

```python
class MyNodeVisitor(ast.NodeVisitor):
    def __init__(self):
        self visited_nodes = []

    def visit(self, node):
        # Perform some action on this node
        print(f&quot;Visited node of type {type(node).__name__}&quot;)
        self.visited_nodes.append(type(node).__name__)
        super().visit(node)

# Create a new visitor object
visitor = MyNodeVisitor()

# Traverse the parse tree and visit each node
visitor.visit(parse_tree)
print(&quot;Visited nodes:&quot;, visitor.visited_nodes)
```

### Conclusion

The `parser` module provides an interface for accessing and manipulating Python parse trees. By creating a parser object, parsing Python code, and manipulating the resulting parse tree, we can perform various actions on the parsed code.

**Note:** This is just a basic example of how to use the `parser` module in Python. In a real-world application, you would likely want to handle errors and exceptions more robustly, as well as add additional logic for handling specific cases or edge conditions.
</code></pre>

<h3 id='standard_library_documents/Python Language Services/symbol - Constants used with Python parse trees.md'>symbol - Constants used with Python parse trees.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># symbol — Constants used with Python parse trees

**Symbol Module Code Generation**

The `symbol` module provides constants and classes related to Python parse trees.

```python
# Importing necessary modules from the symbol module
from symbol import OP, NUMBER, STR, NAME, LOAD, STORE, PASS Statement, RETURN Statement, WHILE Statement, FOR Statement, IF Statement, WITH Statement

class SymbolTable:
    &quot;&quot;&quot;
    A class representing a symbol table used to manage Python parse trees.
    
    Attributes:
        symbols (dict): A dictionary of symbols with their corresponding values.
    &quot;&quot;&quot;
    def __init__(self):
        self.symbols = {}

    def define(self, name, value):
        &quot;&quot;&quot;
        Defines a new symbol in the symbol table.

        Args:
            name (str): The name of the symbol to be defined.
            value: The value of the symbol to be defined.
        &quot;&quot;&quot;
        self.symbols[name] = value

class Parser:
    &quot;&quot;&quot;
    A class representing a parser for Python parse trees.

    Attributes:
        symbol_table (SymbolTable): An instance of SymbolTable used by the parser.
    &quot;&quot;&quot;
    def __init__(self, symbol_table):
        self.symbol_table = symbol_table

    def parse(self, tree):
        &quot;&quot;&quot;
        Parses a Python parse tree using the provided symbol table.

        Args:
            tree: The Python parse tree to be parsed.

        Returns:
            A list of symbols representing the parsed tokens.
        &quot;&quot;&quot;
        # TO DO: Implement the parsing logic here
        pass

def print_symbol(s):
    &quot;&quot;&quot;
    Prints a symbol in a human-readable format.

    Args:
        s (str): The symbol to be printed.
    &quot;&quot;&quot;
    # Printing the symbol based on its type
    if isinstance(s, str):
        print(f&quot;String literal: &#x27;{s}&#x27;&quot;)
    elif isinstance(s, int):
        print(&quot;Integer literal:&quot;, s)
    elif isinstance(s, float):
        print(&quot;Float literal:&quot;, s)
    else:
        print(f&quot;Name: {s}&quot;)

# Example usage
if __name__ == &quot;__main__&quot;:
    # Creating a symbol table
    symbol_table = SymbolTable()

    # Defining symbols in the symbol table
    symbol_table.define(&#x27;var&#x27;, &#x27;variable&#x27;)
    symbol_table.define(&#x27;int&#x27;, 10)
    symbol_table.define(&#x27;float&#x27;, 20.5)

    # Printing symbols from the symbol table
    print_symbol(symbol_table.symbols[&#x27;var&#x27;])
    print_symbol(symbol_table.symbols[&#x27;int&#x27;])
    print_symbol(symbol_table.symbols[&#x27;float&#x27;])

    # Creating a parser instance with the symbol table
    parser = Parser(symbol_table)

    # Parsing a Python parse tree (TO DO: Implement parsing logic here)
    parsed_tokens = parser.parse(tree)  # Replace &#x27;tree&#x27; with the actual parse tree

    # Printing parsed tokens
    for token in parsed_tokens:
        print_symbol(token)
```

Note that this code generation example only covers some of the symbols and classes from the `symbol` module. For a comprehensive implementation, you would need to provide additional details on how these symbols and classes are used throughout your Python codebase.
</code></pre>

<h3 id='standard_library_documents/Python Language Services/tokenize - Tokenizer for Python source.md'>tokenize - Tokenizer for Python source.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># tokenize — Tokenizer for Python source

**Tokenizer Module**
======================

The `tokenizer` module provides a simple text tokenization tool.

### Creating a Tokenizer

To use the tokenizer, you need to create a `Tokenizer` object and feed it with a string or bytes sequence.
```python
import tokenizer

# Create a tokenizer
tokenizer = tokenizer.Tokenizer()

# Feed the tokenizer with a string
tokenizer.feed(&quot;Hello, World!&quot;)

# Feed the tokenizer with bytes
tokenizer.feed(b&quot;Hello, World!&quot;)
```
### Tokenization Options

You can customize the tokenization process by providing additional arguments to the `Tokenizer` constructor.
```python
import tokenizer

# Create a tokenizer with whitespace and punctuation as separators
tokenizer = tokenizer.Tokenizer(sep=&#x27;\s+&#x27;, punctuation=&#x27;[^\w\s]&#x27;)

# Feed the tokenizer with a string
tokenizer.feed(&quot;Hello, World!&quot;)

print(tokenizer.get_tokens())  # Output: [&#x27;Hello&#x27;, &#x27;,&#x27;, &#x27;World&#x27;]
```
### Token Types

The `Tokenizer` class provides several methods to access and manipulate the tokens.
```python
import tokenizer

# Create a tokenizer
tokenizer = tokenizer.Tokenizer()

# Feed the tokenizer with a string
tokenizer.feed(&quot;Hello, World!&quot;)

print(tokenizer.get_tokens())  # Output: [&#x27;Hello&#x27;, &#x27;,&#x27;, &#x27;World&#x27;]
```
*   `get_tokens()`: Returns a list of all tokens in the input sequence.
*   `get_token_type(index)`: Returns the type of token at the specified index. Can be one of `&#x27;WORD&#x27;`, `&#x27;PUNCT&#x27;`, or `&#x27;SPACE&#x27;`.
*   `add_token(token, type)`: Adds a new token to the tokenizer with the specified type.

### Tokenizer Methods

The following methods are available on the `Tokenizer` object.
```python
import tokenizer

# Create a tokenizer
tokenizer = tokenizer.Tokenizer()

# Feed the tokenizer with a string
tokenizer.feed(&quot;Hello, World!&quot;)

print(tokenizer.tokenize())  # Output: [&#x27;Hello&#x27;, &#x27;,&#x27;, &#x27;World&#x27;]
```
*   `tokenize()`: Returns a list of tokens in the input sequence.
*   `strip()`: Removes leading and trailing whitespace from the input sequence.
*   `reset()`: Resets the tokenizer to its initial state.

### Example Use Case

Here&#x27;s an example use case for the tokenizer:
```python
import tokenizer
from collections import Counter

# Create a tokenizer
tokenizer = tokenizer.Tokenizer()

# Feed the tokenizer with a large text file
with open(&#x27;example.txt&#x27;, &#x27;r&#x27;) as f:
    for line in f:
        tokenizer.feed(line)

# Get the token frequency count
token_freq = Counter(tokenizer.get_tokens())

print(token_freq.most_common(10))  # Output: [(&#x27;hello&#x27;, 20), (&#x27;world&#x27;, 15), ...]
```
This code uses the `Tokenizer` to tokenize a large text file and then counts the frequency of each token using the `Counter` class.
</code></pre>
<h2 id='Data Persistence'>Data Persistence</h2><ul><li><a href='#standard_library_documents/Data Persistence/dbm - Interfaces to Unix databases.md'>dbm - Interfaces to Unix databases.md</a></li><li><a href='#standard_library_documents/Data Persistence/copyreg - Register pickle support functions.md'>copyreg - Register pickle support functions.md</a></li><li><a href='#standard_library_documents/Data Persistence/pickle - Python object serialization.md'>pickle - Python object serialization.md</a></li><li><a href='#standard_library_documents/Data Persistence/shelve - Python object persistence.md'>shelve - Python object persistence.md</a></li><li><a href='#standard_library_documents/Data Persistence/sqlite3 - DB-API 2.0 interface for SQLite databases.md'>sqlite3 - DB-API 2.0 interface for SQLite databases.md</a></li><li><a href='#standard_library_documents/Data Persistence/marshal - Internal Python object serialization.md'>marshal - Internal Python object serialization.md</a></li></ul>
<h3 id='standard_library_documents/Data Persistence/dbm - Interfaces to Unix databases.md'>dbm - Interfaces to Unix databases.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># dbm - Interfaces to Unix “databases”

Here&#x27;s an example of how you can use the dbm module in Python:

```python
# Importing the dbm module
import dbm

# Connecting to a DBM file
try:
    # Specify the path to your DBM file
    conn = dbm.open(&#x27;example.db&#x27;, &#x27;r&#x27;)
except dbm.Error as e:
    print(f&quot;Failed to open the database: {e}&quot;)
    exit(1)

# Creating a new key-value pair in the DBM file
conn.set (&#x27;key&#x27;, &#x27;value&#x27;)

# Retrieving values from the DBM file
print(conn.get (&#x27;key&#x27;))

# Removing a value from the DBM file
conn.delete (&#x27;key&#x27;)

# Closing the connection to the DBM file
conn.close()

# Iterating over all keys and values in the DBM file
for key, value in conn.items():
    print(f&quot;Key: {key}, Value: {value}&quot;)

# Using dbm.open() with multiple arguments (creating a new DBM file)
try:
    conn = dbm.open(&#x27;example.db&#x27;, &#x27;w&#x27;)
except dbm.Error as e:
    print(f&quot;Failed to create the database: {e}&quot;)
    exit(1)

# Adding more key-value pairs
conn.set (&#x27;new_key&#x27;, &#x27;new_value&#x27;)

# Committing changes
conn.commit()

# Rolling back changes
conn.rollback()
```

Here&#x27;s an example of how you can use dbm&#x27;s transactional functionality:

```python
import dbm

try:
    # Connect to the database file
    conn = dbm.open(&#x27;example.db&#x27;, &#x27;r&#x27;)
except dbm.Error as e:
    print(f&quot;Failed to open the database: {e}&quot;)
    exit(1)

# Start a transaction
conn.start()

try:
    # Perform operations within the transaction
    conn.set (&#x27;key&#x27;, &#x27;value&#x27;)
    conn.delete (&#x27;other_key&#x27;)

    # Commit changes
    conn.commit()
except dbm.Error as e:
    print(f&quot;Transaction failed: {e}&quot;)
else:
    # Rollback changes if no exception occurs
    conn.rollback()

# Close the connection to the database file
conn.close()
```

This example shows how you can use the dbm module to interact with Unix &quot;databases&quot;. These databases are essentially in-memory data stores that contain key-value pairs. The `open()` function is used to connect to these files, and methods like `set()`, `get()`, `delete()`, and `items()` allow you to read and write from the database.
</code></pre>

<h3 id='standard_library_documents/Data Persistence/copyreg - Register pickle support functions.md'>copyreg - Register pickle support functions.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># copyreg — Register pickle support functions

**Module: copyreg**

The `copyreg` module provides a way to register custom pickle support, which allows you to customize how Python serializes and deserializes objects.

### Installing the Module
You don&#x27;t need to install any external libraries to use this module. It&#x27;s part of the standard library in Python.

### Importing the Module

```python
import copyreg
```

### Registering Custom Pickle Support Functions

You can register custom pickle support functions using the `register` function from the `copyreg` module.

```python
# Define a custom pickle support function for integers
def int_support():
    &quot;&quot;&quot;Register support for pickling and unpickling integers&quot;&quot;&quot;
    return (int, lambda c: int.from_bytes(c, &#x27;big&#x27;))

# Register the custom pickle support function
copyreg.register(int_support)
```

### Unpickling Custom Objects

To use a registered custom pickle support function to unpickle an object, you can use the `unpickle` function from the `copyreg` module.

```python
import pickle

# Pickle some data using the custom support function
data = b&#x27;\x80\x03]q\x00(X\x01\x02)&#x27;
pkl_data = pickle.loads(data)

print(pkl_data)  # Output: (1, 2)
```

### Deregistering Custom Pickle Support Functions

To deregister a custom pickle support function, you can use the `deregister` function from the `copyreg` module.

```python
# Deregister the custom pickle support function
copyreg.deregister(int_support)
```

Note: After deregistering a custom pickle support function, you won&#x27;t be able to unpickle objects that were previously pickled using that function.

### Example Use Cases

*   Serializing and deserializing custom object types with `pickle` module.
*   Registering custom serialization formats (e.g., binary data) for specific object types.

**Full Code**

```python
import copyreg
import pickle

def int_support():
    &quot;&quot;&quot;Register support for pickling and unpickling integers&quot;&quot;&quot;
    return (int, lambda c: int.from_bytes(c, &#x27;big&#x27;))

# Register the custom pickle support function
copyreg.register(int_support)

try:
    # Pickle some data using the custom support function
    data = b&#x27;\x80\x03]q\x00(X\x01\x02)&#x27;
    pkl_data = pickle.loads(data)
    print(pkl_data)  # Output: (1, 2)
except TypeError as e:
    print(e)

# Deregister the custom pickle support function
copyreg.deregister(int_support)

try:
    # Attempt to unpickle data using the deregistered custom support function
    data = b&#x27;\x80\x03]q\x00(X\x01\x02)&#x27;
    pkl_data = pickle.loads(data)
    print(pkl_data)  # Raises TypeError
except TypeError as e:
    print(e)

# Register a new custom pickle support function
def float_support():
    &quot;&quot;&quot;Register support for pickling and unpickling floats&quot;&quot;&quot;
    return (float, lambda c: float.from_bytes(c, &#x27;big&#x27;))

copyreg.register(float_support)
```
</code></pre>

<h3 id='standard_library_documents/Data Persistence/pickle - Python object serialization.md'>pickle - Python object serialization.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># pickle — Python object serialization

**pickle Module Example**
==========================

The `pickle` module provides methods for serializing and de-serializing Python objects.

### Serialization

Serialization is the process of converting an object into a format that can be written to a file or sent over a network. The `pickle.dumps()` function returns a bytes object representing the serialized form of the input object.

```python
import pickle

# Define a class
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def greet(self):
        return f&quot;Hello, my name is {self.name} and I&#x27;m {self.age} years old.&quot;

# Create an instance of the class
person = Person(&quot;John&quot;, 30)

# Serialize the object using pickle.dumps()
serialized_person = pickle.dumps(person)

print(f&quot;Serialized person: {serialized_person}&quot;)

# De-serialize the object using pickle.loads()
deerialized_person = pickle.loads(serialized_person)

print(f&quot;De-deerialized person: {dedecoded_person.greet()}&quot;)
```

### Custom Serialization

By default, `pickle` uses a very strict format to serialize Python objects. If you want more control over the serialization process, you can use the `HIGHEST_PROTOCOL` level or implement your own custom protocol.

```python
import pickle

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

person = Person(&quot;John&quot;, 30)

# Serialize the object using a custom protocol
serialized_person = pickle.dumps(person, protocol=pickle.HIGHEST_PROTOCOL)

print(f&quot;Serialized person (highest protocol): {serialized_person}&quot;)

# De-serialize the object using a custom protocol
deerialized_person = pickle.loads(serialized_person)

print(f&quot;De-deerialized person: {dedecoded_person.greet()}&quot;)
```

### Security Considerations

When serializing and de-serializing objects, be aware of security risks. The `pickle` module can execute arbitrary code when de-serializing objects, which makes it vulnerable to attacks like code injection.

To mitigate this risk, only serialize and de-serialize trusted data. You can also use the `HIGHEST_PROTOCOL` level with the `security` module, which provides additional security features.

```python
import pickle
import security

# Serialize the object using a secure protocol
serialized_person = pickle.dumps(person, protocol=pickle.HIGHEST_PROTOCOL)

print(f&quot;Serialized person (highest protocol): {serialized_person}&quot;)

# De-serialize the object using a secure protocol
deerialized_person = pickle.loads(serialized_person, fix_imports=True)

print(f&quot;De-deerialized person: {dedecoded_person.greet()}&quot;)
```

### Pickling Exceptions

When serializing or de-serializing objects, `pickle` raises exceptions if there&#x27;s an error during the process. You can catch these exceptions to handle any errors that occur.

```python
import pickle

try:
    # Serialize the object using pickle.dumps()
    serialized_person = pickle.dumps(person)
except pickle.PicklingError as e:
    print(f&quot;Picking error: {e}&quot;)
```

### Unpickling Exceptions

When de-serializing objects, `pickle` raises exceptions if there&#x27;s an error during the process. You can catch these exceptions to handle any errors that occur.

```python
import pickle

try:
    # De-serialize the object using pickle.loads()
    dedecoded_person = pickle.loads(serialized_person)
except pickle.UnpicklingError as e:
    print(f&quot;Unpicking error: {e}&quot;)
```

### Additional Methods

The `pickle` module provides several additional methods for serializing and de-serializing objects, including:

*   `pickle.load()`: De-serializes an object from a file or stream.
*   `pickle.dump()`: Serializes an object to a file or stream.
*   `pickle.dumps()`: Serializes an object to a bytes object.
*   `pickle.loads()`: De-serializes an object from a bytes object.

```python
import pickle

# Serialize the object using pickle.dumps()
serialized_person = pickle.dumps(person)

# De-serialize the object using pickle.loads()
dedecoded_person = pickle.loads(serialized_person)
```

### Usage with Files or Streams

The `pickle` module can serialize and de-serialize objects to files or streams. You can use the `open()` function to create a file or stream.

```python
import pickle

# Create a file object
with open(&quot;person.pkl&quot;, &quot;wb&quot;) as f:
    # Serialize the object using pickle.dump()
    pickle.dump(person, f)

# De-serialize the object using pickle.load()
with open(&quot;person.pkl&quot;, &quot;rb&quot;) as f:
    dedecoded_person = pickle.load(f)
```

### Usage with BytesIO

The `pickle` module can also serialize and de-serialize objects to bytes. You can use the `BytesIO` class from the `io` module.

```python
import pickle
from io import BytesIO

# Create a BytesIO object
buf = BytesIO()

# Serialize the object using pickle.dump()
pickle.dump(person, buf)

# De-serialize the object using pickle.load()
dedecoded_person = pickle.load(buf)
```

### Conclusion

The `pickle` module provides an efficient way to serialize and de-serialize Python objects. It&#x27;s a powerful tool for storing and transmitting data in various formats. However, be aware of security risks when serializing and de-serializing objects, especially if you&#x27;re working with untrusted data.
</code></pre>

<h3 id='standard_library_documents/Data Persistence/shelve - Python object persistence.md'>shelve - Python object persistence.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># shelve — Python object persistence

**Shelve Module Documentation**
=====================================

The `shelve` module provides an interface to serialize and deserialize Python objects to and from a file.

**Installation**
---------------

You can install the `shelve` module using pip:

```bash
pip install shelve
```

**Example Usage**
-----------------

Here is an example of how to use the `shelve` module to store and retrieve data:
```python
import shelve

# Open a database file for writing
with shelve.open(&#x27;example.db&#x27;) as db:
    # Store some data in the database
    db[&#x27;name&#x27;] = &#x27;John Doe&#x27;
    db[&#x27;age&#x27;] = 30
    
    # Retrieve some data from the database
    retrieved_data = db[&#x27;name&#x27;]
    
# Open a database file for reading
with shelve.open(&#x27;example.db&#x27;) as db:
    # Check if some data was stored in the database
    print(db.get(&#x27;name&#x27;))  # Output: John Doe

# Error handling
try:
    with shelve.open(&#x27;non_existent_file.db&#x27;) as db:
        pass
except FileNotFoundError:
    print(&quot;The file does not exist&quot;)
```

**Shelving an Object**
----------------------

You can shelved objects using the `shelve` module&#x27;s object methods:

```python
import shelve

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    # Shelved attribute: only serialized when shelving an instance of this class
    @property
    def __shelved_attributes__(self):
        return (&#x27;name&#x27;, &#x27;age&#x27;)

# Open a database file for writing
with shelve.open(&#x27;example.db&#x27;) as db:
    person = Person(&#x27;John Doe&#x27;, 30)
    
    # Shelved attribute is serialized and stored in the database
    db[&#x27;person&#x27;] = person
    
    # Retrieve the shelved object from the database
    retrieved_person = db[&#x27;person&#x27;]

# Shelving only a specific subset of attributes
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
        
    # Shelved attribute: only serialized when shelving an instance of this class
    @property
    def __shelved_attributes__(self):
        return (&#x27;name&#x27;,)

# Open a database file for writing
with shelve.open(&#x27;example.db&#x27;) as db:
    person = Person(&#x27;John Doe&#x27;, 30)
    
    # Shelved attribute is serialized and stored in the database
    db[&#x27;person&#x27;] = person

# Retrieve the shelved object from the database
retrieved_person = db[&#x27;person&#x27;]
```

**Unshelving an Object**
------------------------

You can unshelve objects using the `shelve` module&#x27;s `unshelf` method:

```python
import shelve

with shelve.open(&#x27;example.db&#x27;) as db:
    person = db[&#x27;person&#x27;]

# Unshelve the object from the database
unshelved_person = shelve.unshelf(person)

print(unshelved_person.name)  # Output: John Doe
```

**Error Handling**
------------------

The `shelve` module raises an exception when there is a problem with the file or data being shelved:

```python
import shelve

try:
    with shelve.open(&#x27;non_existent_file.db&#x27;) as db:
        pass
except FileNotFoundError:
    print(&quot;The file does not exist&quot;)
except Exception as e:
    print(f&quot;An error occurred: {e}&quot;)
```

**Custom Shelving**
-------------------

You can create custom shelving behavior using a class that implements the `shelve.ShelvedObject` interface:

```python
import shelve

class CustomShelvedObject(shelve.ShelvedObject):
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    # Method to be called when serializing an instance of this class
    def serialize(self):
        return {&#x27;name&#x27;: self.name, &#x27;age&#x27;: self.age}

# Open a database file for writing
with shelve.open(&#x27;example.db&#x27;) as db:
    person = CustomShelvedObject(&#x27;John Doe&#x27;, 30)
    
    # Shelved attribute is serialized and stored in the database
    db[&#x27;person&#x27;] = person

# Retrieve the shelved object from the database
retrieved_person = db[&#x27;person&#x27;]

# Unshelve the object from the database
unshelved_person = shelve.unshelf(retrieved_person)

print(unshelved_person.name)  # Output: John Doe
```
</code></pre>

<h3 id='standard_library_documents/Data Persistence/sqlite3 - DB-API 2.0 interface for SQLite databases.md'>sqlite3 - DB-API 2.0 interface for SQLite databases.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># sqlite3 — DB-API 2.0 interface for SQLite databases

Here&#x27;s an example of how you can use the `sqlite3` module in Python:

```python
# Importing sqlite3 module
import sqlite3

# Create a connection object
def create_connection(db_name):
    &quot;&quot;&quot;
    Creates a connection to the SQLite database.

    Args:
        db_name (str): The name of the database file.

    Returns:
        sqlite3.Connection: A connection object.
    &quot;&quot;&quot;
    try:
        # Attempt to connect to the database
        conn = sqlite3.connect(db_name)
        print(f&quot;Connected to {db_name}&quot;)
        return conn
    except sqlite3.Error as e:
        # Handle any errors that occur during connection
        print(e)

# Create a cursor object
def create_cursor(conn):
    &quot;&quot;&quot;
    Creates a cursor object from the connection.

    Args:
        conn (sqlite3.Connection): The connection object.

    Returns:
        sqlite3.Cursor: A cursor object.
    &quot;&quot;&quot;
    try:
        # Attempt to create a cursor
        cur = conn.cursor()
        print(&quot;Cursor created&quot;)
        return cur
    except sqlite3.Error as e:
        # Handle any errors that occur during cursor creation
        print(e)

# Create table
def create_table(conn, table_name):
    &quot;&quot;&quot;
    Creates a new table in the database.

    Args:
        conn (sqlite3.Connection): The connection object.
        table_name (str): The name of the table to create.
    &quot;&quot;&quot;
    try:
        # SQL query to create table
        cur = conn.cursor()
        sql_query = f&quot;&quot;&quot;
            CREATE TABLE IF NOT EXISTS {table_name} (
                id INTEGER PRIMARY KEY,
                name TEXT NOT NULL,
                age INTEGER
            )
        &quot;&quot;&quot;
        # Execute the SQL query
        cur.execute(sql_query)
        conn.commit()
        print(f&quot;Table {table_name} created&quot;)
    except sqlite3.Error as e:
        # Handle any errors that occur during table creation
        print(e)

# Insert data into table
def insert_data(conn, table_name, data):
    &quot;&quot;&quot;
    Inserts data into the specified table.

    Args:
        conn (sqlite3.Connection): The connection object.
        table_name (str): The name of the table to insert data into.
        data (dict): A dictionary containing the data to be inserted.
    &quot;&quot;&quot;
    try:
        # SQL query to insert data
        cur = conn.cursor()
        sql_query = f&quot;&quot;&quot;
            INSERT INTO {table_name} (name, age)
            VALUES (?, ?)
        &quot;&quot;&quot;
        # Execute the SQL query with parameters
        cur.execute(sql_query, tuple(data.values()))
        conn.commit()
        print(f&quot;Data inserted into table {table_name}&quot;)
    except sqlite3.Error as e:
        # Handle any errors that occur during data insertion
        print(e)

# Select data from table
def select_data(conn, table_name):
    &quot;&quot;&quot;
    Retrieves data from the specified table.

    Args:
        conn (sqlite3.Connection): The connection object.
        table_name (str): The name of the table to retrieve data from.

    Returns:
        list: A list of rows retrieved from the database.
    &quot;&quot;&quot;
    try:
        # SQL query to select data
        cur = conn.cursor()
        sql_query = f&quot;&quot;&quot;
            SELECT * FROM {table_name}
        &quot;&quot;&quot;
        # Execute the SQL query
        cur.execute(sql_query)
        rows = cur.fetchall()
        print(f&quot;Data retrieved from table {table_name}&quot;)
        return rows
    except sqlite3.Error as e:
        # Handle any errors that occur during data selection
        print(e)

# Update data in table
def update_data(conn, table_name, where_clause, data):
    &quot;&quot;&quot;
    Updates the specified data in the table.

    Args:
        conn (sqlite3.Connection): The connection object.
        table_name (str): The name of the table to update data in.
        where_clause (str): The WHERE clause for the UPDATE query.
        data (dict): A dictionary containing the new data values.
    &quot;&quot;&quot;
    try:
        # SQL query to update data
        cur = conn.cursor()
        sql_query = f&quot;&quot;&quot;
            UPDATE {table_name} SET name = ?, age = ?
            WHERE {where_clause}
        &quot;&quot;&quot;
        # Execute the SQL query with parameters
        cur.execute(sql_query, tuple(data.values()))
        conn.commit()
        print(f&quot;Data updated in table {table_name}&quot;)
    except sqlite3.Error as e:
        # Handle any errors that occur during data update
        print(e)

# Delete data from table
def delete_data(conn, table_name, where_clause):
    &quot;&quot;&quot;
    Deletes the specified data from the table.

    Args:
        conn (sqlite3.Connection): The connection object.
        table_name (str): The name of the table to delete data from.
        where_clause (str): The WHERE clause for the DELETE query.
    &quot;&quot;&quot;
    try:
        # SQL query to delete data
        cur = conn.cursor()
        sql_query = f&quot;&quot;&quot;
            DELETE FROM {table_name}
            WHERE {where_clause}
        &quot;&quot;&quot;
        # Execute the SQL query
        cur.execute(sql_query)
        conn.commit()
        print(f&quot;Data deleted from table {table_name}&quot;)
    except sqlite3.Error as e:
        # Handle any errors that occur during data deletion
        print(e)

# Main function
def main():
    # Create a connection to the database
    db_name = &quot;test.db&quot;
    conn = create_connection(db_name)
    
    # Create a cursor object
    cur = create_cursor(conn)

    # Create table
    table_name = &quot;users&quot;
    create_table(conn, table_name)

    # Insert data into table
    data = {&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30}
    insert_data(conn, table_name, data)

    # Select data from table
    rows = select_data(conn, table_name)
    for row in rows:
        print(row)

    # Update data in table
    where_clause = &quot;id = 1&quot;
    update_data(conn, table_name, where_clause, {&quot;name&quot;: &quot;Jane&quot;, &quot;age&quot;: 31})

    # Delete data from table
    delete_where_clause = &quot;id = 2&quot;
    delete_data(conn, table_name, delete_where_clause)

if __name__ == &quot;__main__&quot;:
    main()
```

This code covers the following topics:

1. Connecting to a SQLite database using `sqlite3.connect()`.
2. Creating a cursor object using `conn.cursor()`.
3. Executing SQL queries using the `execute()` method.
4. Committing changes using the `commit()` method.
5. Retrieving data from the database using the `fetchall()` method.
6. Updating data in the database using the `update()` method.
7. Deleting data from the database using the `delete()` method.

The example code demonstrates how to perform these tasks and provides a basic structure for working with SQLite databases using Python&#x27;s `sqlite3` module.
</code></pre>

<h3 id='standard_library_documents/Data Persistence/marshal - Internal Python object serialization.md'>marshal - Internal Python object serialization.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># marshal — Internal Python object serialization

**Marshal Module Example**
=====================================

The `marshal` module provides functions and classes for serializing and deserializing Python objects.

### Installation

You can install the `marshal` module using pip:
```bash
pip install PyYAML
```
Note: The `marshal` module uses the `yamllib` library under the hood, which is not included in Python&#x27;s standard library. You need to install a YAML parser separately if you want to use this module.

### Example Code

Here are some examples of using the `marshal` module:

```python
import marshal

# Create a dictionary object
obj = {&quot;key&quot;: &quot;value&quot;}

# Serialize the object to a bytes stream
serialized_obj = marshal.dumps(obj)

print(&quot;Serialized Object:&quot;, serialized_obj)

# Deserialize the object from the bytes stream
deserialized_obj = marshal.loads(serialized_obj)

print(&quot;Deserialized Object:&quot;, deserialized_obj)
```

### Class Serialization

The `marshal` module also provides functions for serializing and deserializing Python classes.

```python
import marshal

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __str__(self):
        return f&quot;{self.name} ({self.age})&quot;

# Create an instance of the Person class
person = Person(&quot;John Doe&quot;, 30)

# Serialize the object to a bytes stream
serialized_person = marshal.dumps(person.__dict__)

print(&quot;Serialized Object:&quot;, serialized_person)

# Deserialize the object from the bytes stream
deserialized_person = Person(*marshal.loads(serialized_person))

print(&quot;Deserialized Object:&quot;, deserialized_person)
```

### Binary Serialization

The `marshal` module also provides functions for serializing and deserializing binary objects.

```python
import marshal

# Create a bytearray object
byte_array = bytearray(b&quot;Hello, World!&quot;)

# Serialize the object to a bytes stream
serialized_byte_array = marshal.dumps(byte_array)

print(&quot;Serialized Byte Array:&quot;, serialized_byte_array)

# Deserialize the object from the bytes stream
deserialized_byte_array = marshal.loads(serialized_byte_array)

print(&quot;Deserialized Byte Array:&quot;, deserialized_byte_array)
```

### Error Handling

The `marshal` module can raise exceptions if there are errors during serialization or deserialization.

```python
import marshal

try:
    # Serialize an object to a bytes stream
    serialized_obj = marshal.dumps([1, 2, 3])
except OSError as e:
    print(&quot;Error serializing object:&quot;, e)

# Deserialize an object from the bytes stream
try:
    deserialized_obj = marshal.loads(b&#x27;\x80\x03}q\x00(X\x01\x00\x00\x00\x00\x00\x00.&#x27;)
except OSError as e:
    print(&quot;Error deserializing object:&quot;, e)
```

Note: These examples are just illustrations of how to use the `marshal` module. In real-world applications, you would typically handle errors and exceptions more robustly.
</code></pre>
<h2 id='Functional Programming Modules'>Functional Programming Modules</h2><ul><li><a href='#standard_library_documents/Functional Programming Modules/itertools - Functions creating iterators for efficient looping.md'>itertools - Functions creating iterators for efficient looping.md</a></li><li><a href='#standard_library_documents/Functional Programming Modules/functools - Higher-order functions and operations on callable objects.md'>functools - Higher-order functions and operations on callable objects.md</a></li><li><a href='#standard_library_documents/Functional Programming Modules/operator - Standard operators as functions.md'>operator - Standard operators as functions.md</a></li></ul>
<h3 id='standard_library_documents/Functional Programming Modules/itertools - Functions creating iterators for efficient looping.md'>itertools - Functions creating iterators for efficient looping.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># itertools — Functions creating iterators for efficient looping

Here are some examples of using the `itertools` module in Python 3.12:

**1. Counting**

```python
import itertools

# Create an iterator that counts from 0
counter = itertools.count(5)

print(next(counter))  # prints: 5
print(next(counter))  # prints: 6
```

**2. Cycles**

```python
import itertools

# Create a cycle of numbers from 1 to 3, repeating when exhausted
cycle = itertools.cycle([1, 2, 3])

for _ in range(7):
    print(next(cycle))  # prints: 1, 2, 3, 1, 2, 3, 1

# Create a cycle of strings
string_cycle = itertools.cycle(&#x27;abcdef&#x27;)

for _ in range(10):
    print(next(string_cycle))
```

**3. Accumulate**

```python
import itertools

numbers = [1, 2, 3]

# Use accumulate to calculate the cumulative sum
print(list(itertools.accumulate(numbers)))  # prints: [1, 3, 6]
```

**4. Combinations**

```python
import itertools

numbers = [1, 2, 3]

# Create combinations of length 2 from the numbers list
combinations = list(itertools.combinations(numbers, 2))
print(combinations)  # prints: [(1, 2), (1, 3), (2, 3)]

# Create combinations with repetition allowed
combination_with_repetition = list(itertools.combinations_with_replacement(numbers, 2))
print(combination_with_repetition)  # prints: [(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)]
```

**5. Product**

```python
import itertools

numbers = [1, 2]

# Create the Cartesian product of two lists
product = list(itertools.product(numbers, numbers))
print(product)  # prints: [(1, 1), (1, 2), (2, 1), (2, 2)]
```

**6. Groupby**

```python
import itertools

students = [
    {&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 20},
    {&#x27;name&#x27;: &#x27;Bob&#x27;, &#x27;age&#x27;: 21},
    {&#x27;name&#x27;: &#x27;Charlie&#x27;, &#x27;age&#x27;: 20},
    {&#x27;name&#x27;: &#x27;David&#x27;, &#x27;age&#x27;: 22}
]

# Group students by age
for age, group in itertools.groupby(students, key=lambda x: x[&#x27;age&#x27;]):
    print(f&quot;Age {age}:&quot;)
    for student in group:
        print(student[&#x27;name&#x27;])
```

**7. Permutations**

```python
import itertools

numbers = [1, 2, 3]

# Create permutations of a list
permutations = list(itertools.permutations(numbers))
print(permutations)  # prints: [(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)]

# Create permutations with repetition allowed
permutations_with_repetition = list(itertools.permutations(numbers, 3))
print(permutations_with_repetition)  # prints: [(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)]
```

**8. Chain**

```python
import itertools

# Create a chain of iterators
iterator_1 = [1, 2, 3]
iterator_2 = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]

chain = itertools.chain(iterator_1, iterator_2)
print(list(chain))  # prints: [1, 2, 3, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]
```

**9. Accumulate with an initial value**

```python
import itertools

numbers = [1, 2, 3]

# Use accumulate to calculate the cumulative sum with an initial value of 0
print(list(itertools.accumulate(numbers, initial=0)))  # prints: [0, 1, 3, 6]
```

**10. Tee**

```python
import itertools

numbers = [1, 2, 3]

# Create two independent iterators from the same list
iterator_1, iterator_2 = itertools.tee(numbers)
print(list(iterator_1))  # prints: [1, 2, 3]
print(list(iterator_2))  # prints: [1, 2, 3]

# Modify one of the iterators
for _ in range(3):
    print(next(iterator_1))
```

These examples demonstrate various functions provided by the `itertools` module, including creating iterators for efficient looping, combining multiple iterables into a single iterable, and performing various operations on iterables.
</code></pre>

<h3 id='standard_library_documents/Functional Programming Modules/functools - Higher-order functions and operations on callable objects.md'>functools - Higher-order functions and operations on callable objects.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># functools — Higher-order functions and operations on callable objects

Here&#x27;s an example of how you can use the `functools` module from Python&#x27;s standard library.

```python
import functools

# 1. Partial Application
def add(a, b):
    return a + b

partial_add_5 = functools.partial(add, 5)
print(partial_add_5(3))  # Outputs: 8

# 2. Higher-Order Functions (Functions as Arguments)
def multiply_by_2(f):
    return lambda x: f(x) * 2

double_values = multiply_by_2
print(double_values(4))  # Outputs: 8

# 3. Closures
def outer():
    x = 10
    def inner():
        y = 20
        print(&quot;Value of x:&quot;, x)
        print(&quot;Value of y:&quot;, y)
    return inner

func = outer()
func()

# 4. Reduce (Aggregate Function)
from functools import reduce

numbers = [1, 2, 3, 4, 5]
print(reduce(lambda x, y: x + y, numbers))  # Outputs: 15

# 5. Total Order Reducer
from functools import total_ordering

@total_ordering
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __eq__(self, other):
        return self.age == other.age

    def __lt__(self, other):
        return self.age &lt; other.age

p1 = Person(&quot;Alice&quot;, 25)
p2 = Person(&quot;Bob&quot;, 30)

print(p1 &lt; p2)  # Outputs: True
print(p1 == p2)  # Outputs: False

# 6. Singleton Function
def singleton(cls):
    instances = {}
    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    return get_instance

@singleton
class Logger:
    pass

logger1 = Logger()
logger2 = Logger()

print(logger1 is logger2)  # Outputs: True

# 7. LruCache (Cache for Function Results)
from functools import lru_cache

@lru_cache(maxsize=32)
def fibonacci(n):
    if n &lt; 2:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

print(fibonacci(10))  # Outputs: 55

# 8. singledispatch (Multi-Dispatch for Functions)
from functools import singledispatch

@singledispatch
def handle_event(event_type):
    print(&quot;Default event handled&quot;)

@handle_event.register
def _(event_type=&quot;button_click&quot;):
    print(&quot;Button click event handled&quot;)

handle_event(&quot;button_click&quot;)  # Outputs: Button click event handled
handle_event(&quot;unknown_event&quot;)  # Outputs: Default event handled

# 9. cmp_to_key (Key Function from Comparison Functions)
from functools import cmp_to_key

def compare_strings(a, b):
    if len(a) &lt; len(b):
        return -1
    elif len(a) &gt; len(b):
        return 1
    else:
        return 0

sorted_list = sorted([&quot;hello&quot;, &quot;world&quot;], key=cmp_to_key(compare_strings))
print(sorted_list)  # Outputs: [&#x27;world&#x27;, &#x27;hello&#x27;]

# 10. update_wrapper (Update the wrapper function&#x27;s docstring and __name__)
from functools import update_wrapper

def my_decorator(func):
    def wrapper(*args, **kwargs):
        print(&quot;Decorated function&quot;)
        return func(*args, **kwargs)
    update_wrapper(wrapper, func)  # Update the wrapper function&#x27;s docstring
    return wrapper

@my_decorator
def add(a, b):
    &quot;&quot;&quot;Add two numbers&quot;&quot;&quot;
    return a + b

print(add.__name__)  # Outputs: decorated_add
print(add.__doc__)   # Outputs: Add two numbers
```

These examples demonstrate how you can use various functions from the `functools` module to create higher-order functions, work with closures, and perform operations such as partial application, caching, and multi-dispatch.
</code></pre>

<h3 id='standard_library_documents/Functional Programming Modules/operator - Standard operators as functions.md'>operator - Standard operators as functions.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># operator — Standard operators as functions

Here&#x27;s an example of using the `operator` module in Python, which provides a comprehensive set of operators as functions:

```python
# Import the operator module
import operator

# Define variables for demonstration purposes
a = 10
b = 5
c = 20
d = 15

# Arithmetic Operators
print(&quot;Arithmetic Operators:&quot;)
# Add
add_result = operator.add(a, b)
print(f&quot;add({a}, {b}) = {add_result}&quot;)

# Subtract
subtract_result = operator.sub(a, c)
print(f&quot;sub({a}, {c}) = {subtract_result}&quot;)

# Multiply
multiply_result = operator.mul(a, d)
print(f&quot;mul({a}, {d}) = {multiply_result}&quot;)

# Divide (Note: Division can be both integer and floating-point)
divide_result = operator.truediv(a, c)
print(f&quot;truediv({a}, {c}) = {divide_result}&quot;)

# Modular Exponentiation
power_result = operator.pow(2, 3) # Using a constant for demonstration purposes
print(f&quot;pow(2, 3) = {power_result}&quot;)
```

This example demonstrates how to use various operators from the `operator` module, including arithmetic and exponentiation operations.

Here&#x27;s a brief explanation of each function:

- `operator.add(a, b)` - Adds two numbers.
- `operator.sub(a, b)` - Subtracts one number from another.
- `operator.mul(a, b)` - Multiplies two numbers.
- `operator.truediv(a, b)` - Divides one number by another (returns a float).
- `operator.pow(base, exponent)` - Calculates the power of `base` raised to `exponent`.

Here&#x27;s an example with more operators and their usage:

```python
print(&quot;Other Operators:&quot;)
# Comparison Operators
is_greater_result = operator.gt(5, 3)
print(f&quot;gt({5}, {3}) = {is_greater_result}&quot;)

# Equality Operator (True if both operands are equal)
is_equal_result = operator.eq(10, 10)
print(f&quot;eq({10}, {10}) = {is_equal_result}&quot;)

# Inequality Operator
is_not_equal_result = operator.ne(10, 5)
print(f&quot;ne({10}, {5}) = {is_not_equal_result}&quot;)

# Membership Operators
is_member_result = 2 in [1, 2, 3]
print(f&quot;in({2}, [1, 2, 3]) = {is_member_result}&quot;)

# Bitwise operators

# AND operator
and_result = operator.and_(5, 8)
print(f&quot;and(5, 8) = {and_result}&quot;)

# OR operator
or_result = operator.or_(5, 8)
print(f&quot;or(5, 8) = {or_result}&quot;)

# XOR operator
xor_result = operator.xor(5, 8)
print(f&quot;xor(5, 8) = {xor_result}&quot;)
```

This example demonstrates how to use comparison operators (`gt`, `eq`, `ne`), membership operators (`in`), and bitwise operators (`and_`, `or_`, `xor_`).
</code></pre>
<h2 id='Debugging and Profiling'>Debugging and Profiling</h2><ul><li><a href='#standard_library_documents/Debugging and Profiling/trace - Trace or track Python statement execution.md'>trace - Trace or track Python statement execution.md</a></li><li><a href='#standard_library_documents/Debugging and Profiling/pdb - The Python Debugger.md'>pdb - The Python Debugger.md</a></li><li><a href='#standard_library_documents/Debugging and Profiling/timeit - Measure execution time of small code snippets.md'>timeit - Measure execution time of small code snippets.md</a></li><li><a href='#standard_library_documents/Debugging and Profiling/tracemalloc - Trace memory allocations.md'>tracemalloc - Trace memory allocations.md</a></li><li><a href='#standard_library_documents/Debugging and Profiling/faulthandler - Dump the Python traceback.md'>faulthandler - Dump the Python traceback.md</a></li><li><a href='#standard_library_documents/Debugging and Profiling/bdb - Debugger framework.md'>bdb - Debugger framework.md</a></li></ul>
<h3 id='standard_library_documents/Debugging and Profiling/trace - Trace or track Python statement execution.md'>trace - Trace or track Python statement execution.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># trace — Trace or track Python statement execution

Here&#x27;s an example of how you can use the `trace` function from the `traceback` module in Python:

```python
import traceback

# Function to be traced
def add(a, b):
    &quot;&quot;&quot;
    Adds two numbers together.
    
    Args:
        a (int): The first number.
        b (int): The second number.
    
    Returns:
        int: The sum of the two numbers.
    &quot;&quot;&quot;
    print(f&quot;Inside add function with args {a} and {b}&quot;)
    return a + b

# Traceback an exception
try:
    # Simulate a division by zero error
    result = 1 / 0
except Exception as e:
    # Get the traceback of the current exception
    tb = traceback.format_exc()
    print(&quot;Traceback:&quot;)
    print(tb)

# Use trace to trace function execution
def traced_add(a, b):
    return add(a, b)

traced_result = traced_add(1, 2)
print(f&quot;Traced result: {traced_result}&quot;)

# Tracing a specific point in the call stack
import sys

def outer_function():
    try:
        # Simulate an exception
        raise Exception(&quot;Outer function raised&quot;)
    except Exception as e:
        print(&quot;Caught exception:&quot;, str(e))
        tb = traceback.extract_stack()
        print(&quot;Call stack:&quot;)
        for i, frame in enumerate(tb):
            print(f&quot;{i}: {frame.function} at line {frame.lineno}&quot;)

outer_function()

# Tracing the entire call stack
tb = traceback.extract_stack()
print(&quot;Call stack:&quot;)
for i, frame in enumerate(tb):
    print(f&quot;{i}: {frame.function} at line {frame.lineno}&quot;)
```

Here are some key points about `traceback`:

- **`format_exc()` function:** This function returns a string containing the formatted traceback of the current exception.
- **`extract_stack()` function:** This function returns a list of frames in the call stack. Each frame is a dictionary with keys like &#x27;function&#x27;, &#x27;filename&#x27;, and &#x27;lineno&#x27;.
- **`traceback.print_tb()` function:** This function prints the entire traceback directly to the output stream.

Here are some key points about tracing:

- **Tracing exceptions:** You can use `trace` to catch exceptions, log their type, value, and location in your program.
- **Tracing function calls:** You can use `trace` to track what&#x27;s happening inside your functions, like which arguments they&#x27;re using or where the function call came from.
- **Tracing entire call stack:** You can use `extract_stack()` to get the full history of function calls up to the current point in your program.

You can also use `traceback` with other modules such as `inspect`, `sys`, and `contextlib`. 

For instance:

```python
import inspect

def traced_function():
    result = func_to_trace(1, 2)
    print(f&quot;Result: {result}&quot;)
    return result

def func_to_trace(a, b):
    # Do something with the function arguments here...
    pass
```

Note that this example will run into a recursion error if `func_to_trace` calls itself directly.
</code></pre>

<h3 id='standard_library_documents/Debugging and Profiling/pdb - The Python Debugger.md'>pdb - The Python Debugger.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># pdb — The Python Debugger

**PDB Module: Python Debugger**
=====================================

The `pdb` module provides an interactive debugger for Python programs.

### Importing the PDB Module

To use the `pdb` module, you need to import it in your Python program.
```python
import pdb
```

### Basic Usage

Here&#x27;s a simple example of how to use the `pdb` module:
```python
def fibonacci(n):
    &quot;&quot;&quot;Return the nth Fibonacci number&quot;&quot;&quot;
    if n &lt;= 1:
        return n
    else:
        return fibonacci(n-1) + fibonacci(n-2)

def main():
    pdb.set_trace()  # Set a breakpoint at this line
    print(fibonacci(10))

if __name__ == &quot;__main__&quot;:
    main()
```

When you run this program, it will pause execution at the `pdb.set_trace()` line and present you with a debugger prompt. You can then type various commands to inspect variables, step through code, and continue execution.

### Debugger Commands

Here are some common debugger commands:

*   **b [lineno]**: Set a breakpoint at the specified line number.
*   **c**: Continue execution until the next breakpoint or the program completes.
*   **n**: Step into the current function call.
*   **s**: Step over the current function call and continue execution.
*   **r**: Return from the current function call.
*   **p [expression]**: Print the value of the specified expression.
*   **q**: Quit the debugger.
*   **l**: List the current source code file.
*   **h**: Help display the available commands.

### Example Debugger Session

Here&#x27;s an example of what you might see when you run the program and set a breakpoint:
```
$ python fibonacci.py
&gt; /path/to/fibonacci.py(9)fibonacci(n=10)
-&gt; return fibonacci(n-1) + fibonacci(n-2)
P &lt; FIBONACCI at 0x7f812c23d440 (main.fibonacci)&gt;
&gt;
```

You can then type various commands to inspect variables and step through code. For example:
```python
(p) print n
10

(s) Step over the current function call and continue execution.
&gt; /path/to/fibonacci.py(9)fibonacci(n=9)
-&gt; return fibonacci(n-1) + fibonacci(n-2)
P &lt; FIBONACCI at 0x7f812c23d440 (main.fibonacci)&gt;
&gt;
```

### Advanced Debugger Features

The `pdb` module also supports advanced features such as:

*   **Frames**: You can switch between frames in the debugger using the `c`, `n`, and `s` commands.
*   **Locals**: You can view the local variables of the current frame using the `p` command.
*   **Threads**: You can inspect threads in the debugger using the `t` command.

### Best Practices

Here are some best practices for using the `pdb` module:

*   Set breakpoints at meaningful locations in your code to debug logic flow and errors.
*   Use the `c` command to continue execution until the next breakpoint or the program completes.
*   Use the `n` command to step into function calls and inspect variable values.
*   Use the `p` command to print variable values and inspect local variables.
</code></pre>

<h3 id='standard_library_documents/Debugging and Profiling/timeit - Measure execution time of small code snippets.md'>timeit - Measure execution time of small code snippets.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># timeit — Measure execution time of small code snippets

**Timeit Module**
================

The `timeit` module provides a simple way to measure the execution time of small code snippets.

**Example Use Cases:**

*   Measuring performance of different algorithms
*   Comparing execution times of different code implementations
*   Optimizing code for better performance

**Code Examples:**

### 1. Basic Usage

```python
import timeit

# Define a simple function to measure
def add_numbers(a, b):
    return a + b

# Create a timer object
timer = timeit.Timer(lambda: add_numbers(2, 3))

# Measure the execution time of the function
execution_time = timer.timeit(number=1000000)

print(f&quot;Execution time: {execution_time:.6f} seconds&quot;)
```

### 2. Using Setup and Timeit

```python
import timeit

# Define a simple setup for the measurement
def add_numbers(a, b):
    return a + b

# Create a timer object with setup
timer = timeit.Timer(&#x27;add_numbers(2, 3)&#x27;, &#x27;a, b&#x27;)

# Measure the execution time of the function
execution_time = timer.timeit(number=1000000)

print(f&quot;Execution time: {execution_time:.6f} seconds&quot;)
```

### 3. Using Loop and Timeit

```python
import timeit

# Define a simple loop for the measurement
def add_numbers(a, b):
    result = 0
    for i in range(1000000):
        result += a + b
    return result

# Create a timer object with setup
timer = timeit.Timer(&#x27;add_numbers(2, 3)&#x27;, &#x27;a, b&#x27;)

# Measure the execution time of the function
execution_time = timer.timeit(number=1)

print(f&quot;Execution time: {execution_time:.6f} seconds&quot;)
```

### 4. Using Timer Function

```python
import timeit

# Define a simple function to measure
def add_numbers(a, b):
    return a + b

# Use the timer function to measure execution time
with timeit.timer(&#x27;add_numbers(2, 3)&#x27;) as timer:
    for i in range(1000000):
        result = add_numbers(2, 3)

print(f&quot;Execution time: {timer.total_time:.6f} seconds&quot;)
```

### 5. Measuring Execution Time with Multiple Runs

```python
import timeit

# Define a simple function to measure
def add_numbers(a, b):
    return a + b

# Create multiple timer objects with setup
timers = [
    timeit.Timer(&#x27;add_numbers(2, 3)&#x27;, &#x27;a, b&#x27;),
    timeit.Timer(&#x27;add_numbers(2, 4)&#x27;, &#x27;a, b&#x27;),
    timeit Timer(&#x27;add_numbers(5, 6)&#x27;, &#x27;a, b&#x27;)
]

# Measure the execution time of each function
execution_times = [timer.timeit(number=1000000) for timer in timers]

print(f&quot;Execution times: {execution_times}&quot;)
```

### 6. Using Setup and Timeit with Loop

```python
import timeit

# Define a simple setup for the measurement
def add_numbers(a, b):
    result = 0
    for i in range(1000000):
        result += a + b
    return result

# Create multiple timer objects with setup
timers = [
    timeit.Timer(&#x27;add_numbers(2, 3)&#x27;, &#x27;a, b&#x27;),
    timeit.Timer(&#x27;add_numbers(4, 5)&#x27;, &#x27;a, b&#x27;)
]

# Measure the execution time of each function
execution_times = [timer.timeit(number=1) for timer in timers]

print(f&quot;Execution times: {execution_times}&quot;)
```

Note that the `timeit` module uses a variety of techniques to measure execution time, including measuring the number of calls to a function, timing loops, and using benchmarking frameworks. The above examples demonstrate some of these techniques.
</code></pre>

<h3 id='standard_library_documents/Debugging and Profiling/tracemalloc - Trace memory allocations.md'>tracemalloc - Trace memory allocations.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># tracemalloc — Trace memory allocations

**Tracemalloc Example**
=====================

The `tracemalloc` module provides an interface for tracking object allocations and deallocations.

### Installing Tracemalloc

You can install the `tracemalloc` module using pip:

```bash
pip install py-trace
```

### Basic Usage

Here is a basic example of how to use `tracemalloc`:

```python
import tracemalloc

# Start tracing memory allocations
tracemalloc.start()

# Example usage: create a list and append elements to it
numbers = []
for i in range(1000):
    numbers.append(i)

# Stop tracing memory allocations
current, peak = tracemalloc.get_traced_memory()
print(f&quot;Current memory allocation: {current / 1024:.2f} KB&quot;)
print(f&quot;Peak memory allocation: {peak / 1024:.2f} KB&quot;)

# Get a snapshot of the current memory allocations
snapshot = tracemalloc.take_snapshot()

# Print the top 10 objects in the snapshot
for stat in snapshot.statistics(&#x27;lineno&#x27;):
    print(stat)

# Stop tracing memory allocations
tracemalloc.stop()
```

This will start tracking memory allocations, create a list and append elements to it, stop tracking memory allocations, and then print out the current and peak memory allocations. It also prints out the top 10 objects in the snapshot.

### Tracking Memory Allocations by Frame

You can use `tracemalloc.take_snapshot()` with a frame argument to get a more detailed view of memory allocations:

```python
import tracemalloc

# Start tracing memory allocations
tracemalloc.start()

try:
    # Example usage: create a list and append elements to it
    numbers = []
    for i in range(1000):
        numbers.append(i)
except Exception as e:
    print(e)

# Stop tracing memory allocations
current, peak = tracemalloc.get_traced_memory()
print(f&quot;Current memory allocation: {current / 1024:.2f} KB&quot;)
print(f&quot;Peak memory allocation: {peak / 1024:.2f} KB&quot;)

# Get a snapshot of the current memory allocations
snapshot = tracemalloc.take_snapshot()

# Print the top 10 objects in the snapshot, grouped by frame
for stat in snapshot.statistics(&#x27;lineno&#x27;):
    print(stat)

# Stop tracing memory allocations
tracemalloc.stop()
```

In this example, `tracemalloc.take_snapshot()` is called with a frame argument to get a more detailed view of memory allocations.

### Filtering Memory Allocations

You can use the `snapshot.filter` method to filter memory allocations by type:

```python
import tracemalloc

# Start tracing memory allocations
tracemalloc.start()

try:
    # Example usage: create a list and append elements to it
    numbers = []
    for i in range(1000):
        numbers.append(i)
except Exception as e:
    print(e)

# Stop tracing memory allocations
current, peak = tracemalloc.get_traced_memory()
print(f&quot;Current memory allocation: {current / 1024:.2f} KB&quot;)
print(f&quot;Peak memory allocation: {peak / 1024:.2f} KB&quot;)

# Get a snapshot of the current memory allocations
snapshot = tracemalloc.take_snapshot()

# Filter the snapshot to only show allocations for the &#x27;numbers&#x27; list
snapshot.filter(&#x27;frames&#x27;)

# Print the top 10 objects in the filtered snapshot, grouped by frame
for stat in snapshot.statistics(&#x27;lineno&#x27;):
    print(stat)

# Stop tracing memory allocations
tracemalloc.stop()
```

In this example, `snapshot.filter(&#x27;frames&#x27;)` is called to filter the snapshot to only show allocations for the `&#x27;numbers&#x27;` list.

### Capturing Memory Allocations

You can use `snapshot.capture()` to capture a snapshot of the current memory allocations:

```python
import tracemalloc

# Start tracing memory allocations
tracemalloc.start()

try:
    # Example usage: create a list and append elements to it
    numbers = []
    for i in range(1000):
        numbers.append(i)
except Exception as e:
    print(e)

# Capture a snapshot of the current memory allocations
snapshot = tracemalloc.take_snapshot()
capture = snapshot.capture()

print(capture.top(10))
```

In this example, `snapshot.capture()` is called to capture a snapshot of the current memory allocations. The resulting dictionary can be printed using `print(capture.top(10))`.
</code></pre>

<h3 id='standard_library_documents/Debugging and Profiling/faulthandler - Dump the Python traceback.md'>faulthandler - Dump the Python traceback.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># faulthandler — Dump the Python traceback

Here&#x27;s an example of how you can use `functools` and `traceback` modules to dump the Python traceback.

```python
# Import necessary modules
import functools
import traceback

def exception_handler(exctype, value, tb):
    &quot;&quot;&quot;
    Custom exception handler to print the entire traceback.
    &quot;&quot;&quot;
    # Print the exception type and value
    print(f&quot;Exception Type: {exctype.__name__}&quot;)
    print(f&quot;Value: {value}&quot;)

    # Get the entire traceback
    tb = traceback.format_tb(tb)

    # Combine the exception type, value, and traceback into a single string
    tb_str = exctype.__name__ + &quot;:\n&quot; + str(value) + &quot;\n&quot; + &quot;&quot;.join(tb)

    print(tb_str)


# Create a custom exception handler
exception_handler_func = functools.partial(exception_handler, None, None, sys.exc_info()[2])

def main():
    try:
        # Code that might raise an exception
        x = 1 / 0

    except Exception as e:
        # Use the custom exception handler
        print(&quot;An error occurred:&quot;)
        exception_handler_func(e)

if __name__ == &quot;__main__&quot;:
    main()
```

However, in Python 3.12 and later versions, you can use `functools.set_trace()` to set a breakpoint that will dump the traceback.

```python
# Import necessary modules
import functools

def main():
    try:
        # Code that might raise an exception
        x = 1 / 0
    except Exception as e:
        print(&quot;An error occurred:&quot;)
        print(functools.format_traceback(e))

if __name__ == &quot;__main__&quot;:
    main()
```

In this example, when the exception occurs, `functools.format_traceback()` will dump the traceback.
</code></pre>

<h3 id='standard_library_documents/Debugging and Profiling/bdb - Debugger framework.md'>bdb - Debugger framework.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># bdb — Debugger framework

**bdb Module Documentation**
==========================

The `bdb` module provides a basic implementation of a debugger framework.

### Importing the Module

```python
import bdb as pdb
```

### Using the Debugger

Here&#x27;s an example of how to use the `pdb` module:

```python
# Create a simple function to test the debugger
def add(a, b):
    return a + b

try:
    result = add(2, 3)
except Exception as e:
    # Start the debugger when an exception occurs
    pdb.set_trace()
```

In this example, when an exception occurs in the `add` function, the debugger will be triggered.

### Debugger Commands

The following are some common commands that can be used with the debugger:

*   `n(ext)`: Continue execution until the next line.
*   `s(tep)`: Continue execution until the next unhandled exception or until a breakpoint is hit.
*   `c(ontinue)`: Continue execution without hitting any breakpoints.
*   `(break)` : Set a breakpoint at the current location.
*   `l(inepath)`: Display the source code of the current file.
*   `w(here)`: Show the current command history.
*   `p(expression)`: Evaluate an expression and print the result.
*   `q(uit)`: Quit the debugger.

```python
def add(a, b):
    return a + b

try:
    result = add(2, 3)
except Exception as e:
    # Start the debugger when an exception occurs
    pdb.set_trace()

# Set a breakpoint at the start of the function
pdb.set_trace()
```

### Disabling Breakpoints

By default, breakpoints are enabled. To disable them, you can use the `set_trace()` function with the `breakpoint=False` argument:

```python
def add(a, b):
    return a + b

try:
    result = add(2, 3)
except Exception as e:
    # Start the debugger when an exception occurs
    import pdb; pdb.set_trace(breakpoint=False)  # Disable breakpoints
```

### Installing Breakpoints Manually

If you want to install breakpoints manually, you can use the `set_trace()` function with the `breakpoint=True` argument:

```python
def add(a, b):
    return a + b

# Set a breakpoint at the start of the function
import pdb; pdb.set_trace(breakpoint=True)  # Enable breakpoints
```

### Using Breakpoints with Conditional Statements

Breakpoints can also be used with conditional statements. Here&#x27;s an example:

```python
def add(a, b):
    if a &gt; b:
        return a + b
    else:
        raise ValueError(&quot;a is not greater than b&quot;)

try:
    result = add(2, 3)
except Exception as e:
    # Start the debugger when an exception occurs
    import pdb; pdb.set_trace(breakpoint=True)  # Enable breakpoints
```

In this example, a breakpoint will be triggered if `a` is not greater than `b`.
</code></pre>
<h2 id='Superseded Modules'>Superseded Modules</h2><ul><li><a href='#standard_library_documents/Superseded Modules/imp - Access the import internals.md'>imp - Access the import internals.md</a></li><li><a href='#standard_library_documents/Superseded Modules/optparse - Parser for command line options.md'>optparse - Parser for command line options.md</a></li></ul>
<h3 id='standard_library_documents/Superseded Modules/imp - Access the import internals.md'>imp - Access the import internals.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># imp — Access the import internals

Here&#x27;s an example of how you can access and manipulate the `import` module in Python:

```python
# Import the import module directly
import importlib

# Get a list of all registered modules
registered_modules = [m[0] for m in importlib.machinery.module_specifiers()]
print(&quot;Registered Modules:&quot;)
for module in registered_modules:
    print(module)

# Get a list of all loaded modules
loaded_modules = [m.name for m in importlib.util.find_spec &quot;__import__&quot;).names]
print(&quot;\nLoaded Modules:&quot;)
for module in loaded_modules:
    print(module)

# Import a specific module using the `alias` function
from importlib.machinery import ModuleSpec

# Create a new module spec with a custom name and location
module_spec = ModuleSpec(&quot;custom_module&quot;, &quot;path/to/custom_module.py&quot;)

# Use the `alias` function to register the module
importlib.util.module_from_spec(module_spec)
importlib.util.setup_module(module_spec)

# Get the imported module using the `__name__` attribute
imported_module = __import__(&quot;custom_module&quot;)
print(&quot;\nImported Module:&quot;)
print(imported_module.__name__)
```

**Accessing Import Errors**

To access import errors, you can use the following code:

```python
try:
    # Attempt to import a module with an error
    __import__(&quot;non_existent_module&quot;)
except ImportError as e:
    # Print the error message
    print(f&quot;Import Error: {e}&quot;)

# Get all import errors using the `errors` attribute of the `module_specifier`
errors = [m[1].__name__ for m in importlib.machinery.module_specifiers() if m[1].errors]
print(&quot;\nImport Errors:&quot;)
for error in errors:
    print(error)
```

**Manipulating Import Settings**

To manipulate import settings, you can use the following code:

```python
import sys

# Get the current import path
sys.path.append(&quot;path/to/new/directory&quot;)

try:
    # Attempt to import a module again after modifying the import path
    __import__(&quot;module&quot;)
except ImportError as e:
    print(f&quot;Import Error: {e}&quot;)

# Reset the import path to its original value
sys.path.pop()

# Get all import paths using the `sys.modules` dictionary
import_paths = sys.modules.keys()
print(&quot;\nImport Paths:&quot;)
for path in import_paths:
    print(path)

# Create a new import path and add it to the list of paths
new_path = &quot;path/to/new/directory&quot;
sys.path.append(new_path)
del sys.modules[new_path]
```

**Accessing Import Hooks**

To access import hooks, you can use the following code:

```python
import importlib.util

# Get a list of all installed hooks using the `hooks` attribute of the `module_specifier`
hooks = [m[1].__name__ for m in importlib.machinery.module_specifiers()]
print(&quot;\nImport Hooks:&quot;)
for hook in hooks:
    print(hook)

# Define a new import hook function
def custom_hook(module):
    print(f&quot;Custom Hook: {module.__name__}&quot;)

import importlib.util

# Register the custom hook using the `setup_hook` function
importlib.util.setup_hook(&quot;custom_module&quot;, custom_hook)

# Get the imported module using the `__name__` attribute
imported_module = __import__(&quot;custom_module&quot;)
print(&quot;\nImported Module:&quot;)
print(imported_module.__name__)

# Define a new import error hook function
def custom_error_hook(error):
    print(f&quot;Custom Error Hook: {error}&quot;)

import importlib.util

# Register the custom error hook using the `setup_error_hook` function
importlib.util.setup_error_hook(&quot;custom_module&quot;, custom_error_hook)
```
</code></pre>

<h3 id='standard_library_documents/Superseded Modules/optparse - Parser for command line options.md'>optparse - Parser for command line options.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># optparse — Parser for command line options

**Optparse Code Examples**
==========================

The `optparse` module provides support for parsing command-line options and arguments.

### Example 1: Basic Usage

```python
import optparse

def main():
    # Create an OptionParser object
    parser = optparse.OptionParser(&quot;Usage: python script.py [options]&quot;)

    # Add options
    parser.add_option(&quot;--foo&quot;, action=&quot;store_true&quot;, dest=&quot;foo&quot;,
                      help=&quot;Show foo&quot;)
    parser.add_option(&quot;--bar&quot;, action=&quot;store_true&quot;, dest=&quot;bar&quot;,
                      help=&quot;Show bar&quot;)
    parser.add_option(&quot;-v&quot;, &quot;--verbose&quot;, action=&quot;store_true&quot;, dest=&quot;verbose&quot;,
                      help=&quot;Verbose mode&quot;)

    # Parse the command-line options
    (options, args) = parser.parse_args()

    if options.foo:
        print(&quot;Option foo is set&quot;)
    if options.bar:
        print(&quot;Option bar is set&quot;)
    if options.verbose:
        print(&quot;Verbose mode is enabled&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

### Example 2: Positional Arguments

```python
import optparse

def main():
    # Create an OptionParser object
    parser = optparse.OptionParser(&quot;Usage: python script.py [options] &lt;filename&gt;&quot;)

    # Add options
    parser.add_option(&quot;--foo&quot;, action=&quot;store_true&quot;, dest=&quot;foo&quot;,
                      help=&quot;Show foo&quot;)
    parser.add_option(&quot;--bar&quot;, action=&quot;store_true&quot;, dest=&quot;bar&quot;,
                      help=&quot;Show bar&quot;)
    parser.add_option(&quot;-v&quot;, &quot;--verbose&quot;, action=&quot;store_true&quot;, dest=&quot;verbose&quot;,
                      help=&quot;Verbose mode&quot;)

    # Parse the command-line options
    (options, args) = parser.parse_args()

    if len(args) != 1:
        parser.error(&quot;Please provide a filename&quot;)

    filename = args[0]
    print(f&quot;Loaded file: {filename}&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

### Example 3: Grouping Options

```python
import optparse

def main():
    # Create an OptionParser object
    parser = optparse.OptionParser(&quot;Usage: python script.py [options]&quot;)

    # Add options grouped by section
    group = parser.add_option_group(
        &quot;Configuration Options&quot;,
        &quot;These are configuration-related options&quot;)
    group.add_option(&quot;--config-level&quot;, action=&quot;store&quot;, dest=&quot;config_level&quot;,
                     help=&quot;Set the config level (e.g., DEBUG, INFO, WARNING, ERROR)&quot;)
    group.add_option(&quot;--config-file&quot;, action=&quot;store&quot;, dest=&quot;config_file&quot;,
                     help=&quot;Path to the configuration file&quot;)

    # Parse the command-line options
    (options, args) = parser.parse_args()

    print(f&quot;Config Level: {options.config_level}&quot;)
    print(f&quot;Config File: {options.config_file}&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

### Example 4: Default Values

```python
import optparse

def main():
    # Create an OptionParser object
    parser = optparse.OptionParser(&quot;Usage: python script.py [options]&quot;)

    # Add options with default values
    parser.add_option(&quot;--foo&quot;, action=&quot;store_true&quot;, dest=&quot;foo&quot;,
                      help=&quot;Show foo (default: False)&quot;)
    parser.add_option(&quot;--bar&quot;, action=&quot;store&quot;, type=&quot;int&quot;, dest=&quot;bar&quot;,
                      help=&quot;Show bar (default: 0)&quot;)

    # Parse the command-line options
    (options, args) = parser.parse_args()

    print(f&quot;Option foo is set: {options.foo}&quot;)
    print(f&quot;Option bar is set to {options.bar}&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

### Example 5: Help Message

```python
import optparse

def main():
    # Create an OptionParser object
    parser = optparse.OptionParser(&quot;Usage: python script.py [options]&quot;)

    # Add options
    parser.add_option(&quot;--foo&quot;, action=&quot;store_true&quot;, dest=&quot;foo&quot;,
                      help=&quot;Show foo&quot;)
    parser.add_option(&quot;--bar&quot;, action=&quot;store&quot;, type=&quot;int&quot;, dest=&quot;bar&quot;,
                      help=&quot;Show bar (default: 0)&quot;)

    # Print the help message
    print(&quot;Options:&quot;)
    parser.print_help()

if __name__ == &quot;__main__&quot;:
    main()
```
</code></pre>
<h2 id='Graphical User Interfaces with Tk'>Graphical User Interfaces with Tk</h2><ul><li><a href='#standard_library_documents/Graphical User Interfaces with Tk/tkinter - Python interface to Tcl Tk.md'>tkinter - Python interface to Tcl Tk.md</a></li><li><a href='#standard_library_documents/Graphical User Interfaces with Tk/tkinter.ttk - Tk themed widgets.md'>tkinter.ttk - Tk themed widgets.md</a></li><li><a href='#standard_library_documents/Graphical User Interfaces with Tk/tkinter.tix - Extension widgets for Tk.md'>tkinter.tix - Extension widgets for Tk.md</a></li><li><a href='#standard_library_documents/Graphical User Interfaces with Tk/tkinter.scrolledtext - Scrolled Text Widget.md'>tkinter.scrolledtext - Scrolled Text Widget.md</a></li></ul>
<h3 id='standard_library_documents/Graphical User Interfaces with Tk/tkinter - Python interface to Tcl Tk.md'>tkinter - Python interface to Tcl Tk.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># tkinter - Python interface to Tcl/Tk

**Tkinter Module Code Examples**
=====================================

### Importing Tkinter

```python
# Importing Tkinter module
import tkinter as tk

# Creating a new Tk instance
root = tk.Tk()

# Setting the window title
root.title(&quot;My Tkinter App&quot;)

# Setting the window size
root.geometry(&quot;500x300&quot;)
```

### Creating Widgets

#### Labels

```python
# Creating a label widget
label = tk.Label(root, text=&quot;Hello, World!&quot;)

# Adding the label to the window
label.pack()

# Configuring the label&#x27;s font and color
label.config(font=(&quot;Arial&quot;, 24), fg=&quot;blue&quot;)
```

#### Buttons

```python
# Creating a button widget
button = tk.Button(root, text=&quot;Click Me!&quot;, command=lambda: print(&quot;Button clicked!&quot;))

# Adding the button to the window
button.pack()

# Configuring the button&#x27;s font and color
button.config(font=(&quot;Arial&quot;, 18), fg=&quot;red&quot;)
```

#### Text Boxes

```python
# Creating a text box widget
text_box = tk.Text(root, height=10, width=30)

# Adding the text box to the window
text_box.pack()

# Writing some text into the text box
text_box.insert(tk.END, &quot;Hello, World!&quot;)
```

#### Checkboxes

```python
# Creating a checkbox widget
checkbox_var = tk.BooleanVar()
checkbox = tk.Checkbutton(root, variable=checkbox_var)

# Adding the checkbox to the window
checkbox.pack()

# Configuring the checkbox&#x27;s text and font
checkbox.config(text=&quot;Check me!&quot;, font=(&quot;Arial&quot;, 16))
```

#### Radio Buttons

```python
# Creating radio button widgets
radio_var = tk.StringVar()
radio1 = tk.Radiobutton(root, variable=radio_var, value=&quot;Option 1&quot;)
radio2 = tk.Radiobutton(root, variable=radio_var, value=&quot;Option 2&quot;)

# Adding the radio buttons to the window
radio1.pack()
radio2.pack()

# Configuring the radio buttons&#x27; text and font
radio1.config(text=&quot;Option 1&quot;, font=(&quot;Arial&quot;, 16))
radio2.config(text=&quot;Option 2&quot;, font=(&quot;Arial&quot;, 16))
```

### Event Handling

```python
# Binding an event to a button widget
def on_button_click():
    print(&quot;Button clicked!&quot;)

button = tk.Button(root, text=&quot;Click Me!&quot;, command=on_button_click)
```

### Layout Management

```python
# Using the grid layout manager
label = tk.Label(root, text=&quot;Hello, World!&quot;)
label.grid(row=0, column=0)

button = tk.Button(root, text=&quot;Click Me!&quot;)
button.grid(row=1, column=0)
```

### Frame and Pack Methods

```python
# Creating a frame widget
frame = tk.Frame(root)

# Adding widgets to the frame
label = tk.Label(frame, text=&quot;Hello, World!&quot;)
label.pack()

button = tk.Button(frame, text=&quot;Click Me!&quot;)
button.pack()

# Adding the frame to the window
frame.pack()
```

### Message Box

```python
# Importing messagebox module
import tkinter.messagebox as mb

# Showing a message box with an OK button
mb.showinfo(&quot;Hello&quot;, &quot;World!&quot;)

# Showing a message box with cancel and OK buttons
mb.askokcancel(&quot;Hello&quot;, &quot;World!&quot;)
```

### Window Closing

```python
# Binding the window close event to a function
def on_close():
    print(&quot;Window closed!&quot;)

root.protocol(&quot;WM_DELETE_WINDOW&quot;, on_close)

# Running the application&#x27;s main loop
root.mainloop()
```

**Full Code Example:**

```python
import tkinter as tk
from tkinter import messagebox

def on_button_click():
    print(&quot;Button clicked!&quot;)

def on_close():
    print(&quot;Window closed!&quot;)

root = tk.Tk()

label = tk.Label(root, text=&quot;Hello, World!&quot;)
label.pack()

button = tk.Button(root, text=&quot;Click Me!&quot;, command=on_button_click)
button.pack()

checkbox_var = tk.BooleanVar()
checkbox = tk.Checkbutton(root, variable=checkbox_var)
checkbox.pack()

radio_var = tk.StringVar()
radio1 = tk.Radiobutton(root, variable=radio_var, value=&quot;Option 1&quot;)
radio2 = tk.Radiobutton(root, variable=radio_var, value=&quot;Option 2&quot;)

root.title(&quot;My Tkinter App&quot;)
root.geometry(&quot;500x300&quot;)

frame = tk.Frame(root)
label_frame = tk.Label(frame, text=&quot;Hello, World!&quot;)
label_frame.pack()

button_frame = tk.Button(frame, text=&quot;Click Me!&quot;, command=lambda: print(&quot;Button clicked!&quot;))
button_frame.pack()

checkbox_frame = tk.Checkbutton(frame, variable=checkbox_var)
checkbox_frame.pack()

radio_frame = tk.Frame(root)
radio1.pack()
radio2.pack()

frame.pack()

def show_message():
    messagebox.showinfo(&quot;Hello&quot;, &quot;World!&quot;)

root.protocol(&quot;WM_DELETE_WINDOW&quot;, on_close)

root.mainloop()
```

This example demonstrates various aspects of the Tkinter module, including creating widgets, event handling, layout management, and more.
</code></pre>

<h3 id='standard_library_documents/Graphical User Interfaces with Tk/tkinter.ttk - Tk themed widgets.md'>tkinter.ttk - Tk themed widgets.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># tkinter.ttk — Tk themed widgets

Here are some examples of using the `ttk` module from the `tkinter` package:

```python
import tkinter as tk
from tkinter import ttk

# Create a Tkinter window
root = tk.Tk()
root.title(&quot;TTK Widgets&quot;)

# Create a Frame widget with TTK theme
frame = ttk.Frame(root, padding=&quot;10 10 10 10&quot;)
frame.pack(fill=tk.X)

# Add some buttons to the frame
button1 = ttk.Button(frame, text=&quot;Button 1&quot;, command=lambda: print(&quot;Button 1 clicked&quot;))
button2 = ttk.Button(frame, text=&quot;Button 2&quot;, command=lambda: print(&quot;Button 2 clicked&quot;))

button1.pack(side=tk.LEFT)
button2.pack(side=tk.LEFT)

# Create a Notebook widget
notebook = ttk.Notebook(root)
notebook.pack(fill=tk.BOTH, expand=True)

# Add two tabs to the notebook
tab1 = ttk.Frame(notebook)
tab2 = ttk.Frame(notebook)

notebook.add(tab1, text=&quot;Tab 1&quot;)
notebook.add(tab2, text=&quot;Tab 2&quot;)

# Create a Treeview widget
tree = ttk.Treeview(root)

# Define columns for the treeview
tree[&quot;columns&quot;] = (&quot;Name&quot;, &quot;Age&quot;)

# Format the columns
tree.column(&quot;#0&quot;, width=200)
tree.column(&quot;Name&quot;, anchor=tk.W, width=150)
tree.column(&quot;Age&quot;, anchor=tk.E, width=100)

# Create headings for the treeview
tree.heading(&quot;#0&quot;, text=&quot;Full Name&quot;, anchor=tk.W)
tree.heading(&quot;Name&quot;, text=&quot;First Name&quot;)
tree.heading(&quot;Age&quot;, text=&quot;Age&quot;)

# Insert some data into the treeview
for i in range(5):
    tree.insert(&quot;&quot;, &quot;end&quot;, values=(f&quot;John {i}&quot;, i))

# Pack the treeview widget
tree.pack(fill=tk.BOTH, expand=True)

# Create a Checkbutton widget
checkbutton = ttk.Checkbutton(root, text=&quot;Check me&quot;)
checkbutton.pack()

# Create a OptionMenu widget
option = ttk.OptionMenu(root, None, &quot;Option 1&quot;, &quot;Option 2&quot;, &quot;Option 3&quot;)
option.pack()

root.mainloop()
```

This code creates a window with several TTK widgets:

*   A frame with two buttons
*   A notebook with two tabs
*   A treeview widget with columns and data
*   A checkbutton widget
*   An option menu widget

Each of these examples demonstrates how to use the corresponding TTK class or function in a `tkinter` application.
</code></pre>

<h3 id='standard_library_documents/Graphical User Interfaces with Tk/tkinter.tix - Extension widgets for Tk.md'>tkinter.tix - Extension widgets for Tk.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># tkinter.tix — Extension widgets for Tk

Here&#x27;s an example of using tkinter.Tix extension widgets:

```python
import tkinter as tk
from tkinter import tix

# Create main window
root = tk.Tk()
root.title(&quot;TIX Extension Widgets&quot;)

# Tix Label
tix_label = tix.Label(root, text=&quot;This is a TIX Label&quot;)
tix_label.pack()

# Tix Text Widget
tix_text = tix.Text(root)
tix_text.insert(tk.END, &quot;This is a TIX Text widget\n&quot;)
tix_text.insert(tk.END, &quot;You can use multiple lines of text.&quot;)
tix_text.pack()

# Tix Notebook (Note: Tix Notebook was removed in Tk 8.5, but we can emulate it)
def create_notebook():
    notebook = tix.Notebook(root)
    notebook.pack(fill=&quot;both&quot;, expand=True)

    # Create tabs
    tab1 = tix.Frame(notebook, text=&quot;Tab 1&quot;)
    tab2 = tix.Frame(notebook, text=&quot;Tab 2&quot;)

    # Add tabs to notebook
    notebook.add(tab1, text=&quot;Tab 1&quot;)
    notebook.add(tab2, text=&quot;Tab 2&quot;)

create_notebook()

# Tix Dialog (Note: Tix Dialog was removed in Tk 8.5, but we can use tkinter&#x27;s built-in dialog box)
def create_dialog():
    def say_hello(name):
        print(f&quot;Hello, {name}!&quot;)

    tix.Toplevel(root).title(&quot;TIX Dialog&quot;)
    label = tix.Label(tix.Toplevel(root), text=&quot;What is your name?&quot;)
    label.pack()
    entry = tix.Entry(tix.Toplevel(root))
    entry.pack()
    button = tix.Button(tix.Toplevel(root), text=&quot;Say Hello&quot;, command=lambda: say_hello(entry.get()))
    button.pack()

create_dialog()

# Tix Treeview
def create_treeview():
    treeview = tix.Treeview(root)
    treeview[&quot;columns&quot;] = (&quot;Name&quot;, &quot;Age&quot;)
    treeview.column(&quot;#0&quot;, width=100)
    treeview.column(&quot;Name&quot;, anchor=tk.W, width=200)
    treeview.column(&quot;Age&quot;, anchor=tk.W, width=50)

    # Create headers
    treeview.heading(&quot;#0&quot;, text=&quot;Name&quot;, anchor=tk.W)
    treeview.heading(&quot;Name&quot;, text=&quot;Name&quot;, anchor=tk.W)
    treeview.heading(&quot;Age&quot;, text=&quot;Age&quot;, anchor=tk.W)

    # Insert data into treeview
    for i in range(5):
        treeview.insert(&quot;&quot;, tk.END, values=(f&quot;Person {i}&quot;, f&quot;{i}&quot;))

create_treeview()

# Tix Note (Note: Tix Note was removed in Tk 8.5)
def create_note():
    tix.Notebook(root).pack(fill=&quot;both&quot;, expand=True)

create_note()

root.mainloop()
```

This example shows how to use some of the TIX extension widgets, including `Label`, `Text`, `Notebook` (emulated), `Dialog`, and `Treeview`.
</code></pre>

<h3 id='standard_library_documents/Graphical User Interfaces with Tk/tkinter.scrolledtext - Scrolled Text Widget.md'>tkinter.scrolledtext - Scrolled Text Widget.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># tkinter.scrolledtext — Scrolled Text Widget

**Scrolled Text Widget (tkinter.scrolledtext)**
====================================================

The `tkinter.scrolledtext` module provides a widget that allows for editing of text, with additional functionality for scrolling.

### Example Use Cases:

1. Creating a scrolled text area for displaying log messages or error logs.
2. Building an email client interface with a large text area for composing and viewing emails.

### Code Examples:
```python
import tkinter as tk
from tkinter import scrolledtext

# Create the main window
root = tk.Tk()
root.title(&quot;Scrolled Text Widget&quot;)

# Create a frame to hold the widget
frame = tk.Frame(root)
frame.pack(padx=10, pady=10)

# Create a scrolled text area with a fixed width and height
text_area = scrolledtext.ScrolledText(frame,
                                    width=60,
                                    height=20,
                                    wrap=tk.WORD)
text_area.pack()

# Add some sample text to the widget
sample_text = &quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.&quot;
text_area.insert(tk.INSERT, sample_text)

# Create a button to insert new text into the widget
def insert_new_text():
    new_text = input(&quot;Enter new text: &quot;)
    text_area.insert(tk.END, new_text)

button = tk.Button(frame, text=&quot;Insert New Text&quot;, command=insert_new_text)
button.pack()

# Run the application
root.mainloop()
```

### Usage:

1. Import the `scrolledtext` module from the `tkinter` library.
2. Create a `ScrolledText` widget by passing the required arguments (width, height, and wrap mode) to its constructor.
3. Use the `insert` method to add text to the widget at the specified location.
4. Use the `delete` method to delete text from the widget.

### Methods:

*   `insert(location, text)`: Inserts the given text at the specified location in the widget.
*   `delete(start, stop)`: Deletes the text between the start and stop indices in the widget.
*   `get(from_idx, to_idx)`: Returns the text contained within the specified range of indices.

### Attributes:

*   `width` (int): The width of the widget&#x27;s text area.
*   `height` (int): The height of the widget&#x27;s text area.
*   `wrap` (tkinter.WORD | tkinter.NONE | tkinter.ALL): Specifies how to wrap the text in the widget. Can be set to `tkinter.WORD`, `tkinter.NONE`, or `tkinter.ALL`.

### Event-Driven Programming:

The `ScrolledText` widget raises several events when the user interacts with it, including:

*   `key_press`: Raised when a key is pressed while focusing on the widget.
*   `key_release`: Raised when a key is released while focusing on the widget.
*   `focus_in`: Raised when the widget receives focus.
*   `focus_out`: Raised when the widget loses focus.
</code></pre>
<h2 id='File Formats'>File Formats</h2><ul><li><a href='#standard_library_documents/File Formats/plistlib - Generate and parse Apple .plist files.md'>plistlib - Generate and parse Apple .plist files.md</a></li><li><a href='#standard_library_documents/File Formats/configparser - Configuration file parser.md'>configparser - Configuration file parser.md</a></li><li><a href='#standard_library_documents/File Formats/plistlib_Generate_and_parse_Apple_plist_files.md'>plistlib_Generate_and_parse_Apple_plist_files.md</a></li><li><a href='#standard_library_documents/File Formats/tomllib_Parse_TOML_files.md'>tomllib_Parse_TOML_files.md</a></li><li><a href='#standard_library_documents/File Formats/csv_CSV_File_Reading_and_Writing.md'>csv_CSV_File_Reading_and_Writing.md</a></li><li><a href='#standard_library_documents/File Formats/csv - CSV File Reading and Writing.md'>csv - CSV File Reading and Writing.md</a></li><li><a href='#standard_library_documents/File Formats/netrc - netrc file processing.md'>netrc - netrc file processing.md</a></li><li><a href='#standard_library_documents/File Formats/configparser_Configuration_file_parser.md'>configparser_Configuration_file_parser.md</a></li><li><a href='#standard_library_documents/File Formats/tomllib - Parse TOML files.md'>tomllib - Parse TOML files.md</a></li><li><a href='#standard_library_documents/File Formats/netrc_netrc_file_processing.md'>netrc_netrc_file_processing.md</a></li></ul>
<h3 id='standard_library_documents/File Formats/plistlib - Generate and parse Apple .plist files.md'>plistlib - Generate and parse Apple .plist files.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># plistlib — Generate and parse Apple .plist files

** plistlib Example Code **
=====================================

The `plistlib` module is part of Python&#x27;s standard library, providing functions for generating and parsing Apple `.plist` (Property List) files.

### Installing Required Libraries

Before running the code below, ensure you have installed required libraries by running:
```bash
pip install pyobjc
```
**`plistlib.py` Code Example **
-------------------------------

```python
import plistlib

# Create a dictionary to represent a .plist file
plist_data = {
    &#x27;CFBundleDisplayName&#x27;: &#x27;My App&#x27;,
    &#x27;CFBundleVersion&#x27;: &#x27;1.0&#x27;,
    &#x27;CFBundleShortVersionString&#x27;: &#x27;1.0&#x27;,
}

def generate_plist(plist_data):
    &quot;&quot;&quot;
    Generate a .plist file from the provided dictionary.

    Args:
        plist_data (dict): Dictionary containing .plist data.

    Returns:
        bytes: Bytes representing the generated .plist file.
    &quot;&quot;&quot;
    return plistlib.dumps(plist_data)

# Generate a .plist file
plist_bytes = generate_plist(plist_data)
print(&quot;Generated .plist bytes:&quot;, plist_bytes)

def parse_plist(plist_bytes):
    &quot;&quot;&quot;
    Parse a .plist file from the provided bytes.

    Args:
        plist_bytes (bytes): Bytes representing the .plist file.

    Returns:
        dict: Dictionary containing parsed .plist data.
    &quot;&quot;&quot;
    return plistlib.loads(plist_bytes)

# Parse a sample .plist file
sample_plist_data = {
    &#x27;CFBundleVersion&#x27;: &#x27;1.0&#x27;,
    &#x27;CFBundleShortVersionString&#x27;: &#x27;1.0&#x27;,
}

sample_plist_bytes = b&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;
&lt;plist version=&quot;1.0&quot;&gt;
    &lt;dict&gt;
        &lt;key&gt;CFBundleVersion&lt;/key&gt;
        &lt;string&gt;1.0&lt;/string&gt;
        &lt;key&gt;CFBundleShortVersionString&lt;/key&gt;
        &lt;string&gt;1.0&lt;/string&gt;
    &lt;/dict&gt;
&lt;/plist&gt;
&quot;&quot;&quot;

parsed_plist_data = parse_plist(sample_plist_bytes)
print(&quot;Parsed .plist data:&quot;, parsed_plist_data)

# Generate a new .plist file with updated data
updated_plist_data = {
    &#x27;CFBundleDisplayName&#x27;: &#x27;My App&#x27;,
    &#x27;CFBundleVersion&#x27;: &#x27;2.0&#x27;,
    &#x27;CFBundleShortVersionString&#x27;: &#x27;2.0&#x27;,
}

new_plist_bytes = generate_plist(updated_plist_data)
print(&quot;New generated .plist bytes:&quot;, new_plist_bytes)

# Parse the updated .plist file
updated_plist_data_parsed = parse_plist(new_plist_bytes)
print(&quot;Updated parsed .plist data:&quot;, updated_plist_data_parsed)
```

This code example demonstrates how to:

1.  Generate a `.plist` file from a dictionary using `generate_plist()`.
2.  Parse a sample `.plist` file from bytes using `parse_plist()`.
3.  Update the data in the parsed `.plist` file and generate a new one using `generate_plist()`.

**Note:** This code example assumes you are working with Python 3.x, as it is compatible with that version of the language.
</code></pre>

<h3 id='standard_library_documents/File Formats/configparser - Configuration file parser.md'>configparser - Configuration file parser.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># configparser — Configuration file parser

Here&#x27;s an example of how you can use the `configparser` module to read and write configuration files:

```python
import configparser

# Create a new ConfigParser object
config = configparser.ConfigParser()

# Read a configuration file
def read_config_file(file_path):
    &quot;&quot;&quot;
    Reads a configuration file using ConfigParser.
    
    Args:
        file_path (str): The path to the configuration file.
    
    Returns:
        dict: A dictionary of configuration values.
    &quot;&quot;&quot;
    config.read(file_path)
    return dict(config.items())

# Write a new configuration file
def write_config_file(file_path, sections=None):
    &quot;&quot;&quot;
    Writes a new configuration file using ConfigParser.
    
    Args:
        file_path (str): The path to the configuration file.
        sections (dict, optional): A dictionary of section names and values. Defaults to None.
    &quot;&quot;&quot;
    if sections is None:
        return
    
    with open(file_path, &#x27;w&#x27;) as config_file:
        for section_name in sections.keys():
            config.add_section(section_name)
            config.set(section_name, &#x27;value&#x27;, sections[section_name])
        
        # Write the configuration to the file
        config.write(config_file)

# Create a new configuration file
write_config_file(&#x27;example.ini&#x27;, {&#x27;Section1&#x27;: {&#x27;key1&#x27;: &#x27;value1&#x27;, &#x27;key2&#x27;: &#x27;value2&#x27;}})

# Read the configuration file
print(read_config_file(&#x27;example.ini&#x27;))

# Update a section in the configuration file
def update_config_file(file_path, section_name, key, value):
    &quot;&quot;&quot;
    Updates a section in a configuration file using ConfigParser.
    
    Args:
        file_path (str): The path to the configuration file.
        section_name (str): The name of the section to update.
        key (str): The key of the value to update.
        value (str): The new value for the key.
    &quot;&quot;&quot;
    config.read(file_path)
    config.set(section_name, key, value)
    
    # Write the updated configuration to the file
    with open(file_path, &#x27;w&#x27;) as config_file:
        config.write(config_file)

# Update a section in the configuration file
update_config_file(&#x27;example.ini&#x27;, &#x27;Section1&#x27;, &#x27;key2&#x27;, &#x27;new_value&#x27;)

# Read the updated configuration file
print(read_config_file(&#x27;example.ini&#x27;))

# Remove a section from the configuration file
def remove_config_section(file_path, section_name):
    &quot;&quot;&quot;
    Removes a section from a configuration file using ConfigParser.
    
    Args:
        file_path (str): The path to the configuration file.
        section_name (str): The name of the section to remove.
    &quot;&quot;&quot;
    config.read(file_path)
    
    # Check if the section exists
    if section_name in config.sections():
        # Remove the section from the configuration
        del config[section_name]
        
        # Write the updated configuration to the file
        with open(file_path, &#x27;w&#x27;) as config_file:
            config.write(config_file)

# Remove a section from the configuration file
remove_config_section(&#x27;example.ini&#x27;, &#x27;Section1&#x27;)
```

This example demonstrates how you can use `configparser` to:

*   Read and write configuration files
*   Update sections in a configuration file
*   Remove sections from a configuration file

These functions are useful for parsing and generating configuration files, which is essential for many applications.
</code></pre>

<h3 id='standard_library_documents/File Formats/plistlib_Generate_and_parse_Apple_plist_files.md'>plistlib_Generate_and_parse_Apple_plist_files.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># plistlib — Generate and parse Apple .plist files

Here are some examples of using `plistlib`:

```python
import plistlib
from pathlib import Path
from io import StringIO

# Example 1: Create a new PLIST file
def create_plist(plist_data):
    &quot;&quot;&quot;
    Creates a new PLIST file with the given data.

    Args:
        plist_data (dict): The data to write to the PLIST file.
    &quot;&quot;&quot;
    with open(&quot;example.plist&quot;, &quot;wb&quot;) as f:
        plistlib.dump(plist_data, f)

# Example 2: Parse an existing PLIST file
def parse_plist(plist_path):
    &quot;&quot;&quot;
    Parses an existing PLIST file.

    Args:
        plist_path (Path): The path to the PLIST file.
    &quot;&quot;&quot;
    with open(plist_path, &quot;rb&quot;) as f:
        plist_data = plistlib.load(f)
        print(plist_data)

# Example 3: Parse a string representation of a PLIST
def parse_plist_string(plist_str):
    &quot;&quot;&quot;
    Parses a string representation of a PLIST.

    Args:
        plist_str (str): The string representation of the PLIST.
    &quot;&quot;&quot;
    plist_data = plistlib.loads(StringIO(plist_str))
    print(plist_data)

# Example 4: Update an existing PLIST file
def update_plist(plist_path, updated_data):
    &quot;&quot;&quot;
    Updates an existing PLIST file with the given data.

    Args:
        plist_path (Path): The path to the PLIST file.
        updated_data (dict): The updated data to write to the PLIST file.
    &quot;&quot;&quot;
    with open(plist_path, &quot;rb&quot;) as f:
        old_plist_data = plistlib.load(f)
    updated_plist_data = {**old_plist_data, **updated_data}
    with open(plist_path, &quot;wb&quot;) as f:
        plistlib.dump(updated_plist_data, f)

# Example 5: Create a PLIST dictionary from scratch
def create_plist_dict():
    &quot;&quot;&quot;
    Creates an empty PLIST dictionary.
    &quot;&quot;&quot;
    return {}

# Example 6: Add data to the created PLIST dictionary
def add_to_plist(plist_dict):
    &quot;&quot;&quot;
    Adds new data to the created PLIST dictionary.

    Args:
        plist_dict (dict): The PLIST dictionary.
    &quot;&quot;&quot;
    plist_dict[&quot;key&quot;] = &quot;value&quot;
    return plist_dict

# Example 7: Write the updated PLIST dictionary to a file
def write_plist(plist_path, plist_data):
    &quot;&quot;&quot;
    Writes the given PLIST data to a file.

    Args:
        plist_path (Path): The path to the output file.
        plist_data (dict): The PLIST data to write.
    &quot;&quot;&quot;
    with open(plist_path, &quot;wb&quot;) as f:
        plistlib.dump(plist_data, f)
```

Here is an example of how you can use these functions:

```python
plist_data = {
    &quot;CFBundleIdentifier&quot;: &quot;com.example.plist&quot;,
    &quot;CFBundleName&quot;: &quot;Example App&quot;,
    &quot;CFBundleVersion&quot;: &quot;1.0&quot;
}

create_plist(plist_data)

parse_plist(Path(&quot;example.plist&quot;))

updated_data = {&quot;CFBundleShortVersionString&quot;: &quot;2.0&quot;}
update_plist(Path(&quot;example.plist&quot;), updated_data)

created_plist_dict = create_plist_dict()
added_data = add_to_plist(created_plist_dict)
write_plist(&quot;new_example.plist&quot;, added_data)
```

This will create a new PLIST file with the given data, parse an existing PLIST file, update an existing PLIST file with new data, create a new empty PLIST dictionary, add data to the dictionary, and write the updated dictionary to a new file.
</code></pre>

<h3 id='standard_library_documents/File Formats/tomllib_Parse_TOML_files.md'>tomllib_Parse_TOML_files.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># tomllib — Parse TOML files

**Tomlib Module: Parsing TOML Files**
=====================================

The `tomllib` module is part of the Python Standard Library, which provides support for parsing and encoding Tom&#x27;s Obvious, Minimal Language (TOML) files.

### Module Overview

Here&#x27;s an overview of the main functions provided by the `tomllib` module:

*   **Loading a TOML file**: The `tomllib.load()` function loads a TOML file into a Python dictionary.
*   **Encoding a dictionary to TOML**: The `tomllib.dumps()` function encodes a Python dictionary to a TOML string.

### Code Examples

#### Loading a TOML File

Here&#x27;s an example of how to load a TOML file using the `tomllib.load()` function:

```python
import tomllib

def load_toml_file(file_path):
    &quot;&quot;&quot;
    Load a TOML file into a Python dictionary.
    
    Args:
        file_path (str): Path to the TOML file.

    Returns:
        dict: The loaded TOML data as a Python dictionary.
    &quot;&quot;&quot;
    try:
        with open(file_path, &#x27;rb&#x27;) as file:
            # Use the `tomllib.load()` function to load the TOML file
            data = tomllib.load(file)
            return data
    except tomllib.TomlibParserError as e:
        print(f&quot;Error parsing TOML file: {e}&quot;)
        return None

# Example usage:
file_path = &#x27;example.toml&#x27;
data = load_toml_file(file_path)
if data is not None:
    print(data)
```

#### Encoding a Dictionary to TOML

Here&#x27;s an example of how to encode a Python dictionary to a TOML string using the `tomllib.dumps()` function:

```python
import tomllib

def dump_toml_dict(data):
    &quot;&quot;&quot;
    Encode a Python dictionary to a TOML string.
    
    Args:
        data (dict): The Python dictionary to be encoded.

    Returns:
        str: The encoded TOML string.
    &quot;&quot;&quot;
    try:
        # Use the `tomllib.dumps()` function to encode the dictionary
        tomldata = tomllib.dumps(data, sort_keys=True)
        return tomldata
    except Exception as e:
        print(f&quot;Error encoding dictionary: {e}&quot;)
        return None

# Example usage:
data = {&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 30}
toml_string = dump_toml_dict(data)
if toml_string is not None:
    print(toml_string)
```

### Best Practices

Here are some best practices for working with the `tomllib` module:

*   Always use the `try-except` block when loading or encoding TOML data to handle potential errors.
*   Use the `tomllib.load()` function to load TOML files, and the `tomllib.dumps()` function to encode Python dictionaries.
*   Consider using the `sort_keys=True` argument when encoding dictionaries to ensure consistent ordering of keys in the generated TOML string.
</code></pre>

<h3 id='standard_library_documents/File Formats/csv_CSV_File_Reading_and_Writing.md'>csv_CSV_File_Reading_and_Writing.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># csv — CSV File Reading and Writing

**CSV Module Code Generator**
=====================================

The `csv` module in Python provides several functions for reading and writing CSV (Comma Separated Values) files.

### Installation

No installation is required as it comes pre-installed with Python.

### Usage

Here are some examples of how to use the `csv` module:

```python
import csv

# Example 1: Reading a CSV file
def read_csv_file(filename):
    &quot;&quot;&quot;
    Reads a CSV file and returns its content.
    
    Args:
        filename (str): The name of the CSV file.
    
    Returns:
        list: A list of lists, where each sublist represents a row in the CSV file.
    &quot;&quot;&quot;
    with open(filename, &#x27;r&#x27;) as csvfile:
        reader = csv.reader(csvfile)
        data = [row for row in reader]
    return data

# Example 2: Writing to a CSV file
def write_csv_file(filename, data):
    &quot;&quot;&quot;
    Writes a list of lists (data) to a CSV file.
    
    Args:
        filename (str): The name of the CSV file.
        data (list): A list of lists, where each sublist represents a row in the CSV file.
    &quot;&quot;&quot;
    with open(filename, &#x27;w&#x27;, newline=&#x27;&#x27;) as csvfile:
        writer = csv.writer(csvfile)
        writer.writerows(data)

# Example 3: Reading and writing a CSV file
def read_and_write_csv_file(filename):
    &quot;&quot;&quot;
    Reads a CSV file, modifies its content, and writes it back to the same file.
    
    Args:
        filename (str): The name of the CSV file.
    &quot;&quot;&quot;
    data = read_csv_file(filename)
    # Modify the data here...
    modified_data = [(x + 1) for x in data]
    write_csv_file(filename, modified_data)

# Example 4: Handling quoted values
def handle_quoted_values(data):
    &quot;&quot;&quot;
    Modifies a list of lists by removing quotes from quoted values.
    
    Args:
        data (list): A list of lists, where each sublist represents a row in the CSV file.
    
    Returns:
        list: The modified data with quotes removed from quoted values.
    &quot;&quot;&quot;
    return [[x.strip(&#x27;&quot;&#x27;) for x in row] for row in data]

# Example 5: Using the DictReader and Writer
def use_dictreader_writer(filename):
    &quot;&quot;&quot;
    Reads a CSV file using DictReader and writes it to another file using DictWriter.
    
    Args:
        filename (str): The name of the input CSV file.
        output_filename (str): The name of the output CSV file.
    &quot;&quot;&quot;
    with open(filename, &#x27;r&#x27;) as csvfile:
        reader = csv.DictReader(csvfile)
    data = [row for row in reader]
    # Create a new writer
    with open(output_filename, &#x27;w&#x27;, newline=&#x27;&#x27;) as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=data[0].keys())
        writer.writeheader()
        writer.writerows(data)

# Example 6: Using the StreamReader and StreamWriter
def use_stream_reader_writer(input_filename, output_filename):
    &quot;&quot;&quot;
    Reads a CSV file using StreamReader and writes it to another file using StreamWriter.
    
    Args:
        input_filename (str): The name of the input CSV file.
        output_filename (str): The name of the output CSV file.
    &quot;&quot;&quot;
    with open(input_filename, &#x27;r&#x27;) as csvfile:
        reader = csv.reader(csvfile)
    data = [row for row in reader]
    # Create a new writer
    with open(output_filename, &#x27;w&#x27;, newline=&#x27;&#x27;) as csvfile:
        writer = csv.writer(csvfile)
        writer.writerows(data)

# Example 7: Handling Unicode CSV files
def handle_unicode_csv(filename):
    &quot;&quot;&quot;
    Reads a Unicode CSV file.
    
    Args:
        filename (str): The name of the Unicode CSV file.
    
    Returns:
        list: A list of lists, where each sublist represents a row in the CSV file.
    &quot;&quot;&quot;
    with open(filename, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as csvfile:
        reader = csv.reader(csvfile)
        data = [row for row in reader]
    return data
```

### Explanation

The code above shows how to use the `csv` module for various tasks such as reading and writing CSV files, handling quoted values, using the `DictReader` and `DictWriter`, and more. The examples are designed to be easy to understand and follow.

You can replace the example data with your own data to test these functions in different scenarios. Make sure to handle any potential errors and exceptions that may occur during file operations or parsing.

Note that you should use the `with` statement when working with files to ensure they are properly closed after use, regardless of whether an exception occurs or not.
</code></pre>

<h3 id='standard_library_documents/File Formats/csv - CSV File Reading and Writing.md'>csv - CSV File Reading and Writing.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># csv — CSV File Reading and Writing

**CSV Module Documentation**
=====================================

The `csv` module provides classes for reading and writing tabular data in CSV (Comma Separated Values) format.

### Importing the csv Module
```python
import csv
```

### Reading a CSV File
------------------------

You can use the `reader` function to read a CSV file:
```python
with open(&#x27;data.csv&#x27;, &#x27;r&#x27;) as csvfile:
    reader = csv.reader(csvfile)
    
    # Iterate over each row in the CSV file
    for row in reader:
        print(row)
```

This will output:
```
[&#x27;Name,Age,Country&#x27;]
[&#x27;John,25,USA&#x27;]
[&#x27;Alice,30,UK&#x27;]
```

### Writing a CSV File
-----------------------

You can use the `writer` function to write data to a CSV file:
```python
with open(&#x27;data.csv&#x27;, &#x27;w&#x27;) as csvfile:
    writer = csv.writer(csvfile)
    
    # Write data to the CSV file
    writer.writerow([&#x27;Name&#x27;, &#x27;Age&#x27;, &#x27;Country&#x27;])
    writer.writerow([&#x27;John&#x27;, 25, &#x27;USA&#x27;])
    writer.writerow([&#x27;Alice&#x27;, 30, &#x27;UK&#x27;])
```

This will create a new CSV file `data.csv` with the following content:
```
Name,Age,Country
John,25,USA
Alice,30,UK
```

### Specifying Field Names
---------------------------

You can specify field names when writing data to a CSV file using the `fieldnames` parameter:
```python
with open(&#x27;data.csv&#x27;, &#x27;w&#x27;) as csvfile:
    writer = csv.writer(csvfile, fieldnames=[&#x27;Name&#x27;, &#x27;Age&#x27;, &#x27;Country&#x27;])
    
    # Write data to the CSV file
    writer.writerow([&#x27;John&#x27;, 25, &#x27;USA&#x27;])
    writer.writerow([&#x27;Alice&#x27;, 30, &#x27;UK&#x27;])
```

This will create a new CSV file `data.csv` with the following content:
```
Name,Age,Country
John,25,USA
Alice,30,UK
```

### Error Handling
------------------

You can use try-except blocks to handle errors when reading or writing CSV files:
```python
try:
    with open(&#x27;non_existent_file.csv&#x27;, &#x27;r&#x27;) as csvfile:
        reader = csv.reader(csvfile)
        for row in reader:
            print(row)
except FileNotFoundError:
    print(&quot;File not found.&quot;)
```

This will output &quot;File not found.&quot; instead of raising an error.

### CSV Reader Options
-----------------------

You can use the `reader` function with various options to customize its behavior:

*   ` delimiter`: specifies the delimiter character (default: `,`)
*   ` quotechar`: specifies the character used for quoting (default: `&#x27;`)
*   `escapechar`: specifies the character used for escaping (default: `\`)
*   `lineterminator`: specifies the line terminator character (default: `\n`)

```python
with open(&#x27;data.csv&#x27;, &#x27;r&#x27;) as csvfile:
    reader = csv.reader(csvfile, delimiter=&#x27;;&#x27;, quotechar=&#x27;&quot;&#x27;, escapechar=&#x27;\\&#x27;, lineterminator=&#x27;\r\n&#x27;)
    
    # Iterate over each row in the CSV file
    for row in reader:
        print(row)
```

This will output rows with semicolon (`;`) delimiters and double quotes (`&quot;`) for quoting.

### CSV Writer Options
-----------------------

You can use the `writer` function with various options to customize its behavior:

*   `delimiter`: specifies the delimiter character (default: `,`)
*   `quotechar`: specifies the character used for quoting (default: `&#x27;`)
*   `escapechar`: specifies the character used for escaping (default: `\`)
*   `lineterminator`: specifies the line terminator character (default: `\n`)

```python
with open(&#x27;data.csv&#x27;, &#x27;w&#x27;) as csvfile:
    writer = csv.writer(csvfile, delimiter=&#x27;;&#x27;, quotechar=&#x27;&quot;&#x27;, escapechar=&#x27;\\&#x27;, lineterminator=&#x27;\r\n&#x27;)
    
    # Write data to the CSV file
    writer.writerow([&#x27;Name&#x27;, &#x27;Age&#x27;, &#x27;Country&#x27;])
    writer.writerow([&#x27;John&#x27;, 25, &#x27;USA&#x27;])
    writer.writerow([&#x27;Alice&#x27;, 30, &#x27;UK&#x27;])
```

This will create a new CSV file `data.csv` with semicolon (`;`) delimiters and double quotes (`&quot;`) for quoting.
</code></pre>

<h3 id='standard_library_documents/File Formats/netrc - netrc file processing.md'>netrc - netrc file processing.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># netrc — netrc file processing

**Netrc File Processing Module**
=====================================

The `netrc` module is used to process and manipulate Netrc files, which are used by clients such as SSH, FTP, and HTTP to store login credentials.

### Installing the Module

To use the `netrc` module, you need to install it using pip:
```bash
pip install python-netrc
```
### Importing the Module

To access the functions and classes provided by the `netrc` module, import it in your Python code:
```python
import netrc
```
### Creating a Netrc File Object

You can create a new `Netrc` object using the following function:
```python
def read_netrc(filename=&#x27;~/.netrc&#x27;):
    &quot;&quot;&quot;
    Reads and parses the Netrc file.

    Args:
        filename (str): The path to the Netrc file. Defaults to ~/.netrc.

    Returns:
        Netrc: A dictionary-like object containing the parsed credentials.
    &quot;&quot;&quot;
    with open(filename, &#x27;r&#x27;) as f:
        netrc_file = netrc.Netrc()
        for section in netrc_file.sections():
            for (key, value) in netrc_file.passwords()[section].items():
                # Comment: Set a default password if none is provided
                if not value:
                    value = input(f&quot;Enter default password for {section} user: &quot;)
                    print(f&quot;{value} set as default password&quot;)
        return netrc_file

# Example usage:
netrc_file = read_netrc()
print(netrc_file)
```
### Parsing Credentials from a Netrc File

To parse credentials from a Netrc file, use the following methods:

*   `sections()`: Returns an iterable of section names.
*   `passwords(section)`: Returns an iterable of key-value pairs for the specified section.
*   `get(password, default=None)`: Returns the value for the specified password. If no value is found, returns the default.

Here&#x27;s an example:
```python
netrc_file = read_netrc()

for section in netrc_file.sections():
    print(f&quot;Section: {section}&quot;)
    for (key, value) in netrc_file.passwords(section).items():
        print(f&quot;{key}: {value}&quot;)

# Example usage:
print(netrc_file.get(&#x27;ssh&#x27;, &#x27;default_password&#x27;))
```
### Updating Credentials in a Netrc File

To update credentials in a Netrc file, use the following methods:

*   `add(section, key, value)`: Adds a new password for the specified section.
*   `update(section, key, value)`: Updates an existing password for the specified section.

Here&#x27;s an example:
```python
netrc_file = read_netrc()

netrc_file.add(&#x27;ssh&#x27;, &#x27;username&#x27;, &#x27;new_password&#x27;)
print(netrc_file.get(&#x27;ssh&#x27;))

netrc_file.update(&#x27;ssh&#x27;, &#x27;username&#x27;, &#x27;another_new_password&#x27;)
print(netrc_file.get(&#x27;ssh&#x27;))
```
### Writing to a Netrc File

To write to a Netrc file, use the `write()` method.

Here&#x27;s an example:
```python
netrc_file = read_netrc()
netrc_file.add(&#x27;ssh&#x27;, &#x27;username&#x27;, &#x27;new_password&#x27;)

with open(&#x27;.netrc&#x27;, &#x27;w&#x27;) as f:
    netrc_file.write(f)
```
Note: You should be careful when writing to the Netrc file, as it contains sensitive information.

### Usage

Here are some usage examples:

```python
# Get a list of all sections in the Netrc file
sections = [section for section in read_netrc().sections()]
print(sections)

# Get all credentials from a specific section
credentials = read_netrc().passwords(&#x27;ssh&#x27;)
for (key, value) in credentials.items():
    print(f&quot;{key}: {value}&quot;)

# Write to the Netrc file
netrc_file = netrc.Netrc()
netrc_file.add(&#x27;ssh&#x27;, &#x27;username&#x27;, &#x27;new_password&#x27;)
with open(&#x27;.netrc&#x27;, &#x27;w&#x27;) as f:
    netrc_file.write(f)

# Get a list of all sections in the Netrc file
sections = [section for section in read_netrc().sections()]
print(sections)
```
</code></pre>

<h3 id='standard_library_documents/File Formats/configparser_Configuration_file_parser.md'>configparser_Configuration_file_parser.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># configparser — Configuration file parser

**configparser Module Code Examples**
======================================

### Overview

The `configparser` module is part of Python&#x27;s standard library and allows you to read and write configuration files in various formats, including INI, YAML, and TOML.

### Reading a Configuration File

```python
import configparser

# Create a ConfigParser object
config = configparser.ConfigParser()

# Read the configuration file
config.read(&#x27;example.ini&#x27;)

# Print the configuration values
print(config[&#x27;DEFAULT&#x27;])
print(config[&#x27;section1&#x27;])

# Access specific values
print(config.get(&#x27;DEFAULT&#x27;, &#x27;variable&#x27;))
print(config.get(&#x27;section1&#x27;, &#x27;variable&#x27;))

# Get all section names
print(config.sections())

# Get all variable names in a section
print(config.options(&#x27;section1&#x27;))
```

### Writing to a Configuration File

```python
import configparser

# Create a ConfigParser object
config = configparser.ConfigParser()

# Add values to the configuration file
config[&#x27;DEFAULT&#x27;] = {&#x27;variable&#x27;: &#x27;value&#x27;}
config[&#x27;section1&#x27;] = {&#x27;variable&#x27;: &#x27;value&#x27;}

# Write the configuration file
with open(&#x27;example.ini&#x27;, &#x27;w&#x27;) as configfile:
    config.write(configfile)

# Print the configuration file contents
print(config[&#x27;DEFAULT&#x27;])
print(config[&#x27;section1&#x27;])

# Update values in the configuration file
config[&#x27;DEFAULT&#x27;][&#x27;variable&#x27;] = &#x27;new_value&#x27;
config[&#x27;section1&#x27;][&#x27;variable&#x27;] = &#x27;new_value&#x27;

# Write the updated configuration file
with open(&#x27;example.ini&#x27;, &#x27;w&#x27;) as configfile:
    config.write(configfile)
```

### Creating a Custom ConfigParser Object

```python
import configparser

class CustomConfigParser(configparser.ConfigParser):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

# Create a custom ConfigParser object with additional options
custom_config = CustomConfigParser()

# Add values to the configuration file
custom_config[&#x27;DEFAULT&#x27;] = {&#x27;variable&#x27;: &#x27;value&#x27;}
custom_config[&#x27;section1&#x27;] = {&#x27;variable&#x27;: &#x27;value&#x27;}

# Write the configuration file
with open(&#x27;example.ini&#x27;, &#x27;w&#x27;) as configfile:
    custom_config.write(configfile)
```

### Handling Invalid File Formats

```python
import configparser

try:
    # Attempt to read a non-existent configuration file
    config.read(&#x27;non_existent_file.txt&#x27;)
except FileNotFoundError:
    print(&quot;Configuration file not found.&quot;)

try:
    # Attempt to read an invalid configuration file format
    config = configparser.ConfigParser()
    with open(&#x27;invalid_format.txt&#x27;, &#x27;r&#x27;) as configfile:
        config.read(configfile)
except configparser.Error:
    print(&quot;Invalid configuration file format.&quot;)
```

### Using a Custom Format

```python
import configparser

class CustomFormat(configparser.ConfigParser):
    def getvalue(self, section, option, defaults=None):
        # Custom value retrieval logic
        return &quot;Custom value&quot;

# Create a custom ConfigParser object with a custom format
custom_config = CustomFormat()

# Add values to the configuration file
custom_config[&#x27;DEFAULT&#x27;] = {&#x27;variable&#x27;: &#x27;value&#x27;}
custom_config[&#x27;section1&#x27;] = {&#x27;variable&#x27;: &#x27;value&#x27;}

# Write the configuration file
with open(&#x27;example.txt&#x27;, &#x27;w&#x27;) as configfile:
    custom_config.write(configfile)
```
</code></pre>

<h3 id='standard_library_documents/File Formats/tomllib - Parse TOML files.md'>tomllib - Parse TOML files.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># tomllib — Parse TOML files

**Tomllib Module Code Generator**
=====================================

The `tomllib` module provides classes and functions to parse, serialize, and manipulate TOML (Tom&#x27;s Obvious, Minimal Language) files.

### Importing the tomllib Module
```python
import tomllib
```

### Parsing a TOML File
```python
def parse_toml(file_path):
    &quot;&quot;&quot;
    Parse a TOML file from a given file path.

    Args:
        file_path (str): The path to the TOML file.

    Returns:
        dict: A dictionary representation of the parsed TOML data.
    &quot;&quot;&quot;
    try:
        with open(file_path, &#x27;rb&#x27;) as f:
            # Read the entire file into memory
            data = f.read()
            
            # Parse the TOML data using tomllib.unparse
            parsed_data = tomllib.unparse(data)
            
            return parsed_data
    
    except FileNotFoundError:
        print(f&quot;File not found: {file_path}&quot;)
        return None
```

### Serializing Data to a TOML File
```python
def serialize_toml(data, file_path):
    &quot;&quot;&quot;
    Serialize data into a TOML file.

    Args:
        data (dict): The data to be serialized.
        file_path (str): The path where the serialized TOML file will be saved.
    &quot;&quot;&quot;
    try:
        # Convert the dictionary to TOML format using tomllib.dump
        with open(file_path, &#x27;wb&#x27;) as f:
            tomllib.dump(data, f)
    
    except Exception as e:
        print(f&quot;Error serializing data: {e}&quot;)
```

### Example Usage
```python
# Parse a sample TOML file
data = parse_toml(&#x27;example.toml&#x27;)

if data is not None:
    # Print the parsed data
    print(data)

# Serialize some sample data to a TOML file
sample_data = {
    &quot;title&quot;: &quot;Example TOML File&quot;,
    &quot;version&quot;: 1.0,
    &quot;author&quot;: &quot;John Doe&quot;
}

serialize_toml(sample_data, &#x27;example.toml&#x27;)
```

### Full Code Example
```python
import tomllib

def parse_toml(file_path):
    &quot;&quot;&quot;
    Parse a TOML file from a given file path.

    Args:
        file_path (str): The path to the TOML file.

    Returns:
        dict: A dictionary representation of the parsed TOML data.
    &quot;&quot;&quot;
    try:
        with open(file_path, &#x27;rb&#x27;) as f:
            # Read the entire file into memory
            data = f.read()
            
            # Parse the TOML data using tomllib.unparse
            parsed_data = tomllib.unparse(data)
            
            return parsed_data
    
    except FileNotFoundError:
        print(f&quot;File not found: {file_path}&quot;)
        return None

def serialize_toml(data, file_path):
    &quot;&quot;&quot;
    Serialize data into a TOML file.

    Args:
        data (dict): The data to be serialized.
        file_path (str): The path where the serialized TOML file will be saved.
    &quot;&quot;&quot;
    try:
        # Convert the dictionary to TOML format using tomllib.dump
        with open(file_path, &#x27;wb&#x27;) as f:
            tomllib.dump(data, f)
    
    except Exception as e:
        print(f&quot;Error serializing data: {e}&quot;)

# Example usage
if __name__ == &quot;__main__&quot;:
    # Parse a sample TOML file
    data = parse_toml(&#x27;example.toml&#x27;)

    if data is not None:
        # Print the parsed data
        print(data)

    # Serialize some sample data to a TOML file
    sample_data = {
        &quot;title&quot;: &quot;Example TOML File&quot;,
        &quot;version&quot;: 1.0,
        &quot;author&quot;: &quot;John Doe&quot;
    }

    serialize_toml(sample_data, &#x27;example.toml&#x27;)
```
</code></pre>

<h3 id='standard_library_documents/File Formats/netrc_netrc_file_processing.md'>netrc_netrc_file_processing.md</h3>
<button onclick="history.back()">Back</button>
<pre><code># netrc — netrc file processing

**Netrc File Processing in Python**
=====================================

The `netrc` module is used to parse and process netrc files, which are used by many applications to store network login credentials.

**Example Code**
---------------

```python
import netrc

def main():
    # Create a netrc object from the default location (~/.netrc)
    try:
        n = netrc.Netrc()
    except FileNotFoundError:
        print(&quot;No ~/.netrc file found. Using default location.&quot;)
        n = netrc.Netrc()

    # Get credentials for a specific host
    host = &#x27;example.com&#x27;
    try:
        auth = n.authenticators(host)
    except KeyError:
        print(f&quot;No authentication method found for {host}.&quot;)
        return

    if not isinstance(auth, list):
        print(f&quot;Multiple authentication methods found for {host}:&quot;)
        print(auth)

    # Get a specific credential
    cred = n.passwords.get(host, None)
    if cred is not None:
        print(f&quot;Credential for {host}: {cred}&quot;)
    else:
        print(f&quot;No credentials found for {host}.&quot;)

if __name__ == &quot;__main__&quot;:
    main()
```

**Explanation**
---------------

1. Import the `netrc` module.
2. Create a `Netrc()` object, which represents the netrc file located at the default location (`~/.netrc`).
3. Get authentication methods for a specific host using `n.authenticators(host)`.
4. Get credentials for a specific host using `n.passwords.get(host)`.

**Other Methods**
-----------------

*   `Netrc().authenticators()`: Returns a dictionary of authentication methods.
*   `Netrc().passwords`: Returns a dictionary of password entries.
*   `Netrc().servers`: Returns a list of server names.

**Example Use Cases**
---------------------

1.  **Authenticating to an FTP Server**: Use the netrc module to store your login credentials for an FTP server, and then use the credentials to connect to the server using an FTP client or library.
2.  **Configuring SSH Connections**: Store your SSH login credentials in a netrc file, and then use the netrc module to retrieve the credentials when connecting to an SSH server.

**Note**
----

*   The `netrc` module only reads from the local file system, so be cautious about storing sensitive information in the netrc file.
*   Many applications assume that the netrc file is located at `~/.netrc`, but this can vary depending on the application.
</code></pre>

        
        <button id="scrollToTopBtn">Top</button>
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.3.0/marked.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
        <script>
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightBlock(block);
            });
            window.onscroll = function() {
                var btn = document.getElementById("scrollToTopBtn");
                if (document.body.scrollTop > 100 || document.documentElement.scrollTop > 100) {
                    btn.style.display = "block";
                } else {
                    btn.style.display = "none";
                }
            };
            document.getElementById("scrollToTopBtn").onclick = function() {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            };
        </script>
    </body>
    </html>